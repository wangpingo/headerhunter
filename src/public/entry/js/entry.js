(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var shim = require("es5-shim");
var router = require("./router.js");


router.start({ html5: false, root: ""});



},{"./router.js":41,"es5-shim":44}],2:[function(require,module,exports){
'use strict';

var Regular = require('regularjs');
var filter = require('./filter.js');
var path = require('path');

var dom = Regular.dom; 

var Component = Regular.extend({
	// request
	$request: function(){},

    $login:function () {

    }
})
.filter(filter)
.directive({
    // if expression evaluated to true then addClass z-crt.
    // otherwise, remove it
    // <li z-crt={this.$state.current.name==='app.test.exam.choice'}>
    'z-crt': function(elem, value){
        this.$watch(value, function(val){
            dom[val? 'addClass': 'delClass'](elem, 'z-crt');
        })
    },
    'q-render': function(elem, value){
        this.$watch(value, function(val){
            if(val) elem.innerHTML = qs.render(val)
        })
    },
    'r-autofocus': function(elem, value){
        setTimeout(function() {
            elem.focus();
        }, 0);
    },
    'r-scroll': function(elem, value) {
        this.$watch(value, function(newValue) {
            if(newValue && elem) {
                var grid_db = elem.parentElement.parentElement.parentElement;
                grid_db.scrollTop = elem.offsetTop;
            }
        });
    },
    'r-href': function(elem, value) {
        this.$watch(value, function(newValue) {
            var hash = location.href.split('#');
            hash = hash[1] || '';
            dom.attr(elem, 'href', '#' + path.join(hash, newValue + ''));
        });
    }
})
.event('enter', function(elem, fire){

    function update(ev){
        if(ev.which == 13){ // ENTER key
            ev.preventDefault();
            fire(ev); // if key is enter , we fire the event;
        }
    }
    dom.on(elem, "keypress", update);
    return function destroy(){ // return a destroy function
        dom.off(elem, "keypress", update);
    }
});

module.exports = Component;
},{"./filter.js":5,"path":47,"regularjs":70}],3:[function(require,module,exports){

module.exports ={
    NOTIFYNUM:0,
    ADMIN:1,                   //管理员
    USER:2,                    //普通用户（猎头）
    USERNAVS:[{                //普通用户导航栏
        name:'首   页',
        url:'#/home',
        match:'home|detail|upload'
    },{
        name:'我的推荐',
        url:'#/recommend',
        match:'recommend'
    },{
        name:'关于猎头',
        url:'#/headhunter',
        match:'headhunter'
    }],
    ADMINNAVS:[{               // 管理员导航栏
        name:'猎头管理',
        url:'#/admin',
        match:'admin|hunterDetail'
    }]

}
},{}],4:[function(require,module,exports){
/**
 *
 * @hzzhangzhang1@corp.netease.com;
 * @ 全局事件注册
 * @ use
 * _.observer.regist('everything', function(res){
 *          console.log(res.data);// {key:value}
        })
 * _.observer.fire('everything', {key:value})
 */

var _ = {};

_.observer = (function(){

    var hanlder = {};

    return {

        /**
         * 注册事件
         * @param  {[type]}   type [description]
         * @param  {Function} fn   [description]
         * @return {[type]}        [description]
         */
        regist: function(type, fn) {       //navShow   funntion(res){self.navShow()};
            if (typeof hanlder[type] === 'undefined') {
                hanlder[type] = [fn];
            } else {
                hanlder[type].push(fn);   //hanlder[navShow].push(funntion(res){self.navShow()};)
            }
        },

        /**
         * 执行事件
         * @param  {[type]} type [description]
         * @param  {[type]} data [description]
         * @return {[type]}      [description]
         */
        fire: function(type, data) {  //navShow data
            if (!hanlder[type]) {
                return;
            }
            var events = {
                type: type,
                data: data || {}
            };
            for (var i = 0, len = hanlder[type].length; i < len; i++) {
                hanlder[type][i](events); //handle[navShow][0]
            }
        },

        /**
         * 移除事件
         * @param  {[type]}   type [description]
         * @param  {Function} fn   [description]
         * @return {[type]}        [description]
         */
        remove: function(type, fn) {
            if (!hanlder[type]) {
                return;
            }
            hanlder[type] = hanlder[type].filter(function(item){
                return item !== fn;
            })
        }
    }
})();

module.exports = _;
},{}],5:[function(require,module,exports){
'use strict';

var filter = {};

/**
 * <p>{time| format: 'yyyy-MM-dd HH:mm'}</p>
 * @return {[type]} [description]
 */
filter.format = function() {
    function fix(str) {
        str = '' + (String(str) || '');
        return str.length <= 1? '0' + str : str;
    }
    var maps = {
        'yyyy': function(date){return date.getFullYear()},
        'MM': function(date){return fix(date.getMonth() + 1); },
        'dd': function(date){ return fix(date.getDate()) },
        'HH': function(date){return fix(date.getHours()) },
        'mm': function(date){ return fix(date.getMinutes())},
        'ss': function(date){ return fix(date.getSeconds())}
    };

    var trunk = new RegExp(Object.keys(maps).join('|'),'g');

    return function(value, format) {
        if(!value){return '';}

        format = format || 'yyyy-MM-dd HH:mm';
        value = new Date(value);

        return format.replace(trunk, function(capture){
            return maps[capture]? maps[capture](value): '';
        });
    }
}();

filter.total = function(array, key) {
    var total = 0;
    if(!array) return;
    array.forEach(function( item ){
        total += key? item[key] : item;
    });
    return total;
};

filter.filter = function(array, filterFn) {
    if(!array || !array.length) return;
    return array.filter(function(item, index){
        return filterFn(item, index);
    })
};

filter.permission = function(value, permission) {
    if(permission === 'modify')
        return (value>>2)%2;
    else if(permission === 'remove')
        return (value>>3)%2;
    else if(permission === 'recheck')
        return (value>>4)%2;

};

filter.render = function(value, answer){
    return ques.render(value, answer);
};

/**
 * 过滤input 输入 防止脚本注入
 * @param  {[type]} val [description]
 * @return {[type]}     [description]
 */
filter.escape = function(val){

  return (val || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')
};

filter.average = function(array, key){
    array = array || [];
    return array.length? filter.total(array, key)/ array.length : 0;
};

filter.bitand  = function(value, bit){
    return (value||0) & bit;
};

filter.join = function(value,splitor){
    return value.join(splitor || ',');
};
filter.json = function(value){
    return JSON.stringify(value);
};
module.exports = filter;

},{}],6:[function(require,module,exports){
'use strict';

var reqwest = require('reqwest');
var ajax = {};

var constant = require('../base/constant.js');
var Mask = require('../common/notify.js');
var Notify = require('../common/notify.js');
var Cookie  = require('../../../../node_modules/js-cookie/src/js.cookie.js');
var cacheServer = require('../service.js');

ajax.request = function(opt) {
    var optError = function(data,result) {

        if(result.code == 'TO'){
            if(constant.NOTIFYNUM++ && constant.NOTIFYNUM>1){
                return;
            }
            var mask = new Mask().$inject(document.body);
            Notify.warning('登录超时，自动跳转至登录页面~');
            clearTimeout(timer)
            var timer = setTimeout(function(){
                Cookie.remove('passport');

                mask.close();
                window.location = '#/login';
                location.reload(true);
            },1000);

        }

        if(result.code == '500'){

            window.location = '/50x.html';
        }
        //opt.progress && progress.end(true);
        //oldError(data.result, data);
    }
    var noop = function(){};
    var oldError = opt.error || optError,
        oldSuccess = opt.success || noop,
        oldComplete = opt.complete || noop;

    opt.data = opt.data || {};

    if(opt.method && opt.method.toLowerCase() !== 'get')
        opt.contentType = opt.contentType || 'application/json';
    else
        opt.data.timestamp = +new Date;

    if(opt.contentType === 'application/json' || opt.headers && opt.headers.contentType === 'application/json' ) {

        opt.data = JSON.stringify(opt.data);
    }

    //ajax.$emit('start', opt);
    //opt.progress && progress.start();

    opt.success = function(data) {

        //ajax.$emit('success', data);
        //opt.progress && progress.end();
        if(data.code != 200) {

           // Notify.success(data.msg);
            oldError(data.result||data.data, data);
            return;
        }
        oldSuccess(data.result||data.data, data);
    }


    opt.complete = function(data) {
        //ajax.$emit(ecomplete', data);
        oldComplete(data.result, data);
    }

    if(opt.method && opt.method.toLowerCase() == 'post'){
        cacheServer.getToken(function(data,result){
            /*opt.data = JSON.parse(opt.data);
            opt.data.token = data;
            opt.data = JSON.stringify(opt.data)*/
            opt.headers = {token:data};
            reqwest(opt);
        })
        return;
    }

    reqwest(opt);
}

module.exports = ajax;
},{"../../../../node_modules/js-cookie/src/js.cookie.js":45,"../base/constant.js":3,"../common/notify.js":13,"../service.js":42,"reqwest":79}],7:[function(require,module,exports){
'use strict';

var Regular = require('regularjs');

var toString = Object.prototype.toString;
var _ = {
    extend: function(o1, o2, override) {
        for(var i in o2)
            if(override || o1[i] === undefined)
                o1[i] = o2[i];
        return o1;
    },
    dom: Regular.dom,
    multiline: function(func) {
        return func.toString().replace(/^function\s*\(\)\s*\{\s*\/\*+/, '').replace(/\*+\/\s*\}$/, '').trim();
    },
    isArray: function(target) {
        return typeof target === 'object' && toString.call(target) === '[object Array]';
    },
    clone:function(obj){
        var newObj = {};
        for(var elements in obj){
          newObj[elements] = obj[elements];
        }
        return newObj;
    }   
};

var o2str = ({}).toString;
_.extend(_, {
    $: function(id) {
        return document.getElementById(id);
    },

    //获取url中的参数
    getParams: function (url) {
        var reg = /(\w+)=([^&]+)/g,
            params = {},
            result = [];

        url = (url.split('?')[1] || '');

        while(result = reg.exec(url)) {
            params[result[1]] = result[2];
        }

        return params;
    },



    array2map:function(list, key, prefix) {
        var result={}, i, l, p, item;
        for(i = 0, l = list.length; i < l; i++){
            item = list[i];
            p = prefix + list[i][key];
            result[p] = list[i];
        }
        return result;
    },
    /*extend:  function(o1, o2, override){
        for(var i in o2) if(override || o1[i] === undefined){
            o1[i] = o2[i]
        }
        return o1;
    },*/
    //判断类型
    typeOf: function(o){
        return o == null ? String(o) : o2str.call(o).slice(8, -1).toLowerCase();
    },
    //判断是否是手机号
    mobile: function (mobile) {
        /* 号码段来自 http://t.cn/Rv6QvRr */
        return /^(13[0-9]|14[57]|15[0-35-9]|17[0-9]|18[0-9])\d{8}$|170[0125789]\d{7}$/.test(mobile);
    },
    //判断是否是email
    email: function (email) {
        return /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/i.test(email)
    },
    //中国身份证号判断
    idNumber:function (str) {
        var isIdCard = function(e) {
            function n(e) {
                var t = 0;
                e[17].toLowerCase() == "x" && (e[17] = 10);
                for (var n = 0; n < 17; n++) t += o[n] * e[n];
                var valCodePosition = t % 11;
                return e[17] == u[valCodePosition] ? !0 : !1;
            }
            function r(e) {
                var t = e.substring(6, 10), n = e.substring(10, 12), r = e.substring(12, 14), i = new Date(t, parseFloat(n) - 1, parseFloat(r));
                return (new Date).getFullYear() - parseInt(t) < 18 ? !1 : i.getFullYear() != parseFloat(t) || i.getMonth() != parseFloat(n) - 1 || i.getDate() != parseFloat(r) ? !1 : !0;
            }
            function i(e) {
                var t = e.substring(6, 8), n = e.substring(8, 10), r = e.substring(10, 12), i = new Date(t, parseFloat(n) - 1, parseFloat(r));
                return i.getYear() != parseFloat(t) || i.getMonth() != parseFloat(n) - 1 || i.getDate() != parseFloat(r) ? !1 : !0;
            }
            function s(e) {
                e = e.replace(/ /g, "").trim();
                if (e.length == 15) return !1;
                if (e.length == 18) {
                    var i = e.split("");
                    return r(e) && n(i) ? !0 : !1;
                }
                return !1;
            }
            var o = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2, 1 ], u = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ];
            return s(e);
        };
        if (!str) return;
        var str = str.toUpperCase();
        return isIdCard(String(str));
    },

    //外国身份证号判断
    foreignIdNumber:function (str) {
       return str.length<18?true:false;
    },

    //判断target是否在obj内
    contains:function(obj, target) {
        if (obj == null) return false;
        for(var i = 0, l = obj.length; i < l; i++){
            if(obj[i] === target){
                return true;
            }
        }
        return false;
    },
    //判断data是否为type类型
    isTypeOf : function(_data,_type){
        try{
                _type = _type.toLowerCase();
                if (_data===null) return _type=='null';
                if (_data===undefined) return _type=='undefined';
                return Object.prototype.toString.call(_data).toLowerCase()=='[object '+_type+']';
        }catch(e){
                return !1;
        }
    },
    isString : function(data){
        return util.isTypeOf(data,'string');
    },
    getCalendarI18n:function(){
        return {
                previousMonth : '上月',
                nextMonth     : '下月',
                months        : ['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月'],
                weekdays      : ['日','一','二','三','四','五','六'],
                weekdaysShort : ['日','一','二','三','四','五','六'],
                midnight:'凌晨',
                noon:'中午'
        }
    },



    wrapReq: function(callback){
        return {
            method: "get",
            type: "json",
            success: function(json){
                if(json && json.code < 300){
                    callback(null, json);
                }else{
                    callback(json);
                }
            },
            error: function(json){
                callback(json);
            }
        }
    },
    findQuestion: function(qid, test){
        var compelete = test.questions[3];
        var coding = test.questions[4];
        var checker = function(item){ return item.questionId == qid };
        if(!compelete) return null;

        var question = compelete.filter(checker)[0];
        if(!question) question = coding.filter(checker)[0];
        return question;
    },
    hasAuthority: function(num, authority){
        return authority & Math.pow(2, num)
    },
    uniqueArr:function(data){
      data = data || [];
            var a = {};
      for (var i=0; i<data.length; i++) {
        var v = data[i];
        if (typeof(a[v]) == 'undefined'){
          a[v] = 1;
        }
      }
        data.length=0;
      for (var i in a){
        data[data.length] = i;
      }
      return data;
    },
    spliceArray:function(arr1, arr2, key){
        var type = Object.prototype.toString.call(arr1[0]);
        var tempArr = JSON.parse(JSON.stringify(arr1));
        if(type == '[object Object]'){
            for(var i = 0,len2 = arr2.length; i <len2; i++)
                for(var j=0,len1 = arr1.length; j<len1;j++){
                    // console.log(arr2[i][key]+','+arr1[j][key]);
                    if(arr2[i][key] == arr1[j][key])
                        tempArr.splice(j,1);
                }
            return tempArr;
        }else{
             for(var len = arr2.length; len--; )
                tempArr.splice(arr1.indexOf(arr2[len]),1);
            return tempArr;
        }

    },
    multiline:function(func){
        var reg = /^function\s*\(\)\s*\{\s*\/\*+\s*([\s\S]*)\s*\*+\/\s*\}$/;
        return reg.exec(func)[1];
    },
    hasClass: function (obj, cls) {

        return obj.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
    },

    addClass:function (obj, cls) {
        if (!this.hasClass(obj, cls)) obj.className += " " + cls;
    },

    hide:function (el) {
        el.style.display = 'none';
    },
    show:function (el) {
        el.style.display = '';
    },
       
    removeClass: function (obj, cls) {
        if (this.hasClass(obj, cls)) {
            var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
            obj.className = obj.className.replace(reg, ' ');
        }
    },
    randomNum:function(minNum, maxNum){
        switch(arguments.length){ 
            case 1: 
                return parseInt(Math.random()*minNum+1); 
            break; 
            case 2: 
                return parseInt(Math.random()*(maxNum-minNum+1)+minNum); 
            break; 
            default: 
                return 0; 
            break;
        }
    },
    //验证是否为空对象
    isEmptyObject:function(obj){
        for(var item in  obj){
            return false;
        }
        return true;
    }

});

_.COLOR_SUCCESS = '#5cb85c';
_.COLOR_INFO = '#5bc0de';
_.COLOR_DANGER = '#d9534f';
_.COLOR_WARNING = '#f0ad4e';

module.exports = _;
},{"regularjs":70}],8:[function(require,module,exports){
module.exports="<div class=\"u-mask\"></div><div class=\"u-loading\"></div>"
},{}],9:[function(require,module,exports){
var Component = require('../base/component.js');
var template = require('./mask.html');

var Mask = Component.extend({
	template: template,
	config: function(data){
        
	},
	init: function(){
		
	},
	close: function(result) {
        this.destroy();
    }
});
module.exports = Mask;

},{"../base/component.js":2,"./mask.html":8}],10:[function(require,module,exports){
module.exports="<div class=\"m-modal {@(class)}\" on-keyup={this.keyup($event)}  >    <div class=\"modal_dialog\" {#if width}style=\"width: {width}px\"{/if}>        <div class=\"modal_hd\">            <a class=\"modal_close\" on-click={this.close(!cancelButton)}><i class=\"u-icon-close\" r-hide={toggleClose}></i><i class=\"u-icon-close-1\" r-hide={!toggleClose}></i></a>            <h3 class=\"modal_title\"><i class=\"u-icon-notice\" r-hide={!hasIcon}></i> {title}</h3>        </div>        <div class=\"modal_bd\">            {#if contentTemplate}{#include contentTemplate}{#else}{content}{/if}        </div>        <div class=\"modal_ft\">            {#if okButton}            <button class=\"button btn-active\" on-click={this.close(true)}>{okButton === true ? (okValue || \'确认\') : okButton}</button>            {/if}            {#if cancelButton}            <button class=\"button btn-gray\" on-click={this.close(false)}>{cancelButton === true ? \'取消\' : cancelButton}</button>            {/if}        </div>    </div></div>"
},{}],11:[function(require,module,exports){
/**
 * ------------------------------------------------------------
 * Modal     模态对话框
 * @author   sensen(rainforest92@126.com)
 * ------------------------------------------------------------
 */

'use strict';

var Component = require('../base/component.js');
var template = require('./modal.html');
var _ = require('../base/util.js');

/**
 * @class Modal
 * @extend Component
 * @param {object}                  options.data                    绑定属性 | Binding Properties
 * @param {string='提示'}           options.data.title              对话框标题 | Title of Dialog
 * @param {string=''}               options.data.content            对话框内容
 * @param {string|boolean=true}     options.data.okButton           是否显示确定按钮。值为`string`时显示该段文字。
 * @param {string|boolean=false}    options.data.cancelButton       是否显示取消按钮。值为`string`时显示该段文字。
 * @param {number=null}             options.data.width              对话框宽度。值为否定时宽度为CSS设置的宽度。
 * @param {string=''}               options.data.class              补充class
 * @param {function}                options.ok                      当点击确定的时候执行
 * @param {function}                options.cancel                  当点击取消的时候执行
 */
var Modal = Component.extend({
    name: 'modal',
    template: template,
    /**
     * @protected
     */
    config: function() {
        _.extend(this.data, {
            title: '提示',
            content: '',
            okButton: true,
            cancelButton: false,
            width: null,
            "class":''
        });

        // setTimeout(function(){
        //     this.data.class +=  ' m-modal-open';
        //     this.$update();
        // }.bind(this),400);
        this.supr();
    },
    /**
     * @protected
     */
    init: function() {

        this.supr();
        // 证明不是内嵌组件
        if(this.$root === this)
            this.$inject(document.body);

        this.selectPage();
    },


    /**
     * 监听pager组件的页数变化
     */
    selectPage() {
        this.$on('selectPage',(obj)=>{
            this.pageNow(obj);
        });
    },

    /**
     * @method close(result) 关闭模态对话框
     * @public
     * @param  {boolean} result 点击确定还是取消
     * @return {void}
     */
    close: function(result) {
        /**
         * @event close 关闭对话框时触发
         * @property {boolean} result 点击了确定还是取消
         */
        this.$emit('close', {
            result: result
        });

        result ? this.ok() : this.cancel();
    },
    /**
     * @override
     */
    ok: function() {
        /**
         * @event ok 确定对话框时触发
         */
        this.$emit('ok');
        this.destroy();
    },
    /**
     * @override
     */
    cancel: function() {
        /**
         * @event close 取消对话框时触发
         */

        this.$emit('cancel');

        this.destroy();
    },
    keyup: function($event) {
        if($event.which == 13){
            this.ok();
            $event.event.preventDefault();
        }
    }
});

/**
 * @method alert([content][,title]) 弹出一个alert对话框。关闭时始终触发确定事件。
 * @static
 * @param  {string=''} content 对话框内容
 * @param  {string='提示'} title 对话框标题
 * @return {void}
 */
Modal.alert = function(content, title, okButton) {
    var modal = new Modal({
        data: {
            content: content,
            title: title,
            okButton: okButton
        }
    });
    return modal;
};

/**
 * @method confirm([content][,title]) 弹出一个confirm对话框
 * @static
 * @param  {string=''} content 对话框内容
 * @param  {string='提示'} title 对话框标题
 * @return {void}
 */
Modal.confirm = function(content, title, okButton, cancelButton) {
    var modal = new Modal({
        data: {
            content: content,
            title: title,
            okButton: okButton,
            cancelButton: cancelButton || true
        }
    });

    return modal;
};

module.exports = Modal;

},{"../base/component.js":2,"../base/util.js":7,"./modal.html":10}],12:[function(require,module,exports){
module.exports="<div class=\"m-notify m-notify-{@(position)} {@(class)}\">    {#list messages as message}    <div class=\"notify_message notify_message-{@(message.type)}\" r-animation=\'on: enter; class: animated fadeIn fast; on: leave; class: animated fadeOut fast;\'>        <div class=\"notify_text\">{@(message.text)}</div>    </div>    {/list}</div>"
},{}],13:[function(require,module,exports){
/**
 * ------------------------------------------------------------
 * Notify    通知
 * @author   sensen(rainforest92@126.com)
 * ------------------------------------------------------------
 */

'use strict';

var Component = require('../base/component.js');
var template = require('./notify.html');
var _ = require('../base/util.js');

/**
 * @class Notify
 * @extend Component
 * @param {object}                  options.data                    监听数据
 * @param {string='topcenter'}      options.data.position           通知的位置，可选参数：`topcenter`、`topleft`、`topright`、`bottomcenter`、`bottomleft`、`bottomright`、`static`
 * @param {number=2000}             options.data.duration           每条消息的停留毫秒数，如果为0，则表示消息常驻不消失。
 * @param {string=''}               options.data.class              补充class
 */
var Notify = Component.extend({
    name: 'notify',
    template: template,
    /**
     * @protected
     */
    config: function() {
        _.extend(this.data, {
            messages: [],
            position: 'topcenter',
            duration: 1000
        });
        this.supr();
    },
    /**
     * @protected
     */
    init: function() {
        this.supr();
        // 证明不是内嵌组件
        if(this.$root === this)
            this.$inject(document.body);
    },
    /**
     * @method show(text[,type][,duration]) 弹出一个消息
     * @public
     * @param  {string=''} text 消息内容
     * @param  {string=null} type 消息类型，可选参数：`info`、`success`、`warning`、`error`
     * @param  {number=notify.duration} duration 该条消息的停留毫秒数，如果为0，则表示消息常驻不消失。
     * @return {void}
     */
    show: function(text, type, duration) {

        var message = {
            text: text,
            type: type,
            duration: duration >= 0 ? duration : this.data.duration
        };
        this.data.messages.unshift(message);
        this.$update();

        if(message.duration)
            this.$timeout(this.close.bind(this, message), message.duration);


        /**
         * @event show 弹出一个消息时触发
         * @property {object} message 弹出的消息对象
         */
        this.$emit('show', {
            message: message
        });

    },
    /**
     * @method close(message) 关闭某条消息
     * @public
     * @param  {object} message 需要关闭的消息对象
     * @return {void}
     */
    close: function(message) {
        var index = this.data.messages.indexOf(message);
        this.data.messages.splice(index, 1);
        this.$update();
        /**
         * @event close 关闭某条消息时触发
         * @property {object} message 关闭了的消息对象
         */
        this.$emit('close', {
            message: message
        });
    },
    /**
     * @method closeAll() 关闭所有消息
     * @public
     * @return {void}
     */
    closeAll: function() {
        this.$update('messages', []);
    }
}).use('$timeout');


/**
 * 直接初始化一个实例
 * @type {Notify}
 */
var notify = new Notify();
Notify.notify = notify;

/**
 * @method show(text[,type][,duration]) 弹出一个消息
 * @static
 * @param  {string=''} text 消息内容
 * @param  {string=null} type 消息类型，可选参数：`info`、`success`、`warning`、`error`
 * @param  {number=notify.duration} duration 该条消息的停留毫秒数，如果为0，则表示消息常驻不消失。
 * @return {void}
 */
Notify.show = function() {
    notify.show.apply(notify, arguments);
};
/**
 * @method close(message) 关闭某条消息
 * @static
 * @param  {object} message 需要关闭的消息对象
 * @return {void}
 */
Notify.close = function() {
    notify.close.apply(notify, arguments);
};
/**
 * @method closeAll() 关闭所有消息
 * @static
 * @return {void}
 */
Notify.closeAll = function() {
    notify.closeAll.apply(notify, arguments);
};

Notify.$on = function(){
    notify.$on.apply(notify,arguments);
};

var types = ['success', 'warning', 'info', 'error'];
types.forEach(function(type) {
    Notify[type] = function(text,duration) {
        Notify.show(text, type,duration);
    }
});

module.exports = Notify;
},{"../base/component.js":2,"../base/util.js":7,"./notify.html":12}],14:[function(require,module,exports){
module.exports="<!--r-hide={!visible}--><ul class=\"m-pager m-pager-{@(position)} {class}\" z-dis={disabled} >    <li class=\"pager_prev\" z-dis={current <= 1} on-click={this.select(current - 1)}><a>上一页</a></li>    {#if total - middle > side * 2 + 1}        {#list 1..side as i}        <li z-crt={current == i} on-click={this.select(i)}><a>{i}</a></li>        {/list}        {#if _start > side + 1}<li><span>...</span></li>{/if}        {#list _start.._end as i}        <li z-crt={current == i} on-click={this.select(i)}><a>{i}</a></li>        {/list}        {#if _end < total - side}<li><span>...</span></li>{/if}        {#list (total - side + 1)..total as i}        <li z-crt={current == i} on-click={this.select(i)}><a>{i}</a></li>        {/list}    {#else}        {#list 1..total as i}        <li z-crt={current == i} on-click={this.select(i)}><a>{i}</a></li>        {/list}    {/if}    <li class=\"pager_next\" z-dis={current >= total} on-click={this.select(current + 1)}><a>下一页</a></li></ul>"
},{}],15:[function(require,module,exports){
/**
 * ------------------------------------------------------------
 * Pager     分页
 * ------------------------------------------------------------
 */
'use strict';
var Component = require('../base/component.js');
var template = require('./pager.html');
var _ = require('../base/util.js');

/**
 * 使用
 * <pager total={Math.ceil(total / limit)} current={current} ></pager>
 * 在使用的组件中监听current的变化，
 * <pager total=11 middle=3 side=1 current=6 />
 */


/**
 * @class Pager
 * @extend Component
 * @param {object}                  options.data                     =  绑定属性
 * @param {number=1}                options.data.current            <=> 当前页
 * @param {total=11}                options.data.total               => 总页数
 * @param {string='center'}         options.data.position            => 分页的位置，可选参数：`center`、`left`、`right`
 * @param {middle=5}                options.data.middle              => 当页数较多时，中间显示的页数
 * @param {side=2}                  options.data.side                => 当页数较多时，两端显示的页数
 * @param {boolean=false}           options.data.readonly            => 是否只读
 * @param {boolean=false}           options.data.disabled            => 是否禁用
 * @param {boolean=true}            options.data.visible             => 是否显示
 * @param {string=''}               options.data.class               => 补充class
 */

var Pager = Component.extend({
    name: 'pager',
    template: template,
    /**
     * @protected
     */
    config: function() {
        _.extend(this.data, {
            current: 1,
            total: 35,
            position: 'right',
            middle: 5,
            side: 2,
            _start: 1,
            _end: 5
        });
        this.supr();

        this.$watch(['current', 'total'], function(current, total) {
            this.data.current = current = +current;
            this.data.total = total = +total;
            var show = this.data.middle>>1;
            var side = this.data.side;

            this.data._start = current - show;
            this.data._end = current + show;
            if(this.data._start < side + 1)
                this.data._start = side + 1;
            if(this.data._end > total - side)
                this.data._end = total - side;
            if(current - this.data._start < show)
                this.data._end += this.data._start - current + show;
            if(this.data._end - current < show)
                this.data._start += this.data._end - current - show;
        });

        this.$watch(['middle', 'side'], function(middle, side) {
            this.data.middle = +middle;
            this.data.side = +side;
        });
    },
    /**
     * @method select(page) 选择某一页
     * @public
     * @param  {object} page 选择页
     * @return {void}
     */
    select: function(page) {
        if(this.data.readonly || this.data.disabled)
            return;

        if(page < 1) return;
        if(page > this.data.total) return;
        if(page == this.data.current) return;

        this.data.current = page;

        /**
         * @event select 选择某一页时触发
         * @property {object} sender 事件发送对象
         * @property {object} current 当前选择页
         */
        this.$parent.$emit('selectPage', {
            sender: this,
            current: this.data.current
        });
    }
});

module.exports = Pager;
},{"../base/component.js":2,"../base/util.js":7,"./pager.html":14}],16:[function(require,module,exports){
module.exports="<div class=\"m-schbar\" ref=\"searchBar\">    <div class=\"m-sch\">        <input type=\"text\" placeholder=\"搜索姓名\" r-model={appName} id=\"j-searchName\" on-keydown={this.__searchByAppName($event)} class=\"u-ipt\" /><button class=\"u-btn-search\" on-click={this.__searchByAppName()}>搜索</button>    </div>    <div class=\"m-sch\">        <label>简历来源：</label>        <div class=\"searchVals\">            <ul class=\"schOptions\" attr=\"resumeFrom\" on-click=\"{this.__clickSearch($event,\'resumeFrom\', 0)}\">                <li data-id=\"\" r-class=\"{{selected: !resumeFrom}}\">不限</li>                {#list resourceList as aList}                <li data-id=\"{aList.id}\" r-class=\"{{selected: resumeFrom == aList.id}}\">{aList.name}</li>                {/list}            </ul>        </div>    </div>    <div class=\"m-sch positionType\">        <label>职位类别：</label>        <div class=\"searchVals\">            <ul class=\"schOptions\" attr=\"postType\" on-click={this.__clickSearch($event, \"postType\",0)}>            <li data-id=\"\" class=\"{postType? \'\':\'selected\'}\">不限</li>            {#list postTypes as aList}            <li data-id={aList.id} class=\"{postType == aList.id ? \'selected\':\'\'}\">{aList.name}</li>            {/list}            </ul>        </div>    </div></div>"
},{}],17:[function(require,module,exports){
/**
 * Created by hzgaoquankang on 2017/5/6.
 */

// 使用方式
// 在父组件中使用  <search >
//this.Search.$on('search', this.__searchByBar.bind(this));
//
//    __searchByBar = function(obj){
//        this.__table.data.currentPage = 1;
//        this.__search(obj);
//   };
//    __search = function(obj){
//        var self = this,
//            _searchItems = self.Search.data.searchItems,
//            _searchBarData = self.Search.data;
//            _searchItems.currentPage = self.__table.data.currentPage;
//       AJAX(params,function(data){},function(){})
//       }
//
//
//
//
//  "GET /ptype/getList.do": function(req, res, next) {
/*        res.send({
 "code": "200",
 "data": [{
 id: "3",
 name: "前端"
 }, {
 id: "4",
 name: "开发"
 }],
 "msg": null
 });
 },

 "GET /common/options/resumefrom.do": function(req, res, next) {
 res.send({
 "code": "200",
 "data": [{
 "code": "resumefrom",
 "id": "30",
 "name": "猎聘网",
 "active": null,
 "parentId": "3"
 }, {
 "code": "resumefrom",
 "id": "31",
 "name": "前程无忧",
 "active": null,
 "parentId": "3"
 }],
 "msg": "3"
 });
 },*/

//test
/*exports.__loadPosTypes = function(params,callback,errback){

 ajax.request({
 url:'/ptype/getList.do',
 method:'GET',
 data:params,
 success:callback,
 error:errback

 })
 }

 //test
 exports.__loadResumeFrom = function(params,callback,errback){

 ajax.request({
 url:'/common/options/resumefrom.do',
 method:'GET',
 data:params,
 success:callback,
 error:errback

 })
 }

 */



'use strict';
var Component = require('../base/component.js');
var template = require('./search.html');
var _ = require('../base/util.js');
var Service = require('../service.js');

var Search = Component.extend({
    template: template,
    name:'search',
    config: function(data){
        _.extend(data,{
            searchQuery:{
                "postStatus": "",
                "appName":"",
                "postType":"",
                "currentPage":1,
                "resumeFrom":""
            },
            appName:"",
            resumeFrom:"",
            postType1:"",
            subPostType:"",
            subsubPostType:"",
            resourceList:[],
            searchItems:{
                interested:this.data.interested
            }
        });
    },
    init: function(){
        this.__loadResumeFrom();
        this.__loadPosTypes(-1, 0);
    },

    __searchByAppName: function(event){

        if((event && event.type == "keydown" && event.which == 13) || !event){
            var _data = this.data,
                _searchItems = _data.searchItems;
            _searchItems.appName = _data.appName.trim();
            this.__search(null);
        }
    },

    __clickSearch: function($event, _attr, _index){
        var _data = this.data,
            _searchItems = _data.searchItems,
            _target = $event.target,
            _id = _target.getAttribute("data-id"),
            _dataAttr = _target.parentNode.getAttribute("attr");

        _data[_dataAttr] = _id;

        _searchItems[_attr] = _data[_attr];
        this.__search(null);
    },
    /**
     * 搜索
     * obj:传递为了区分职位类别是否需要更换
     */
    __search: function(obj){
        this.$emit('search',obj);
    },

    // 获取简历来源列表
    __loadResumeFrom: function (id) {
        var self = this,
            resourceList = self.data.resourceList || [],
            hasSub = true;

        // Service.__loadResumeFrom({
        //     id: -1
        // },function(data,json){
        //     self.data.resourceList = json.data;
        // },function(){});
    },

    // 获取职位列表
    __loadPosTypes: function () {
        var self = this,
            sdata = self.data;

        // Service.__loadPosTypes({
        //     id: 0
        // },function(data,json){
        //     sdata.postType = '';
        //     sdata.postTypes = json.data;
        //     self.$update();
        // },function(){});

    }
});

module.exports = Search;
},{"../base/component.js":2,"../base/util.js":7,"../service.js":42,"./search.html":16}],18:[function(require,module,exports){
module.exports="<div class=\"m-admin\">    <div class=\"adm-header f-pr\">        <div class=\"header-left\">            <span class=\"header-title\">猎头公司</span>            <span class=\"header-num\">正在启用<a>23</a>家</span>        </div>        <div class=\"header-right\" >            <div class=\"right-search\">                <input placeholder=\"输入猎头公司名称\" class=\"search-inp\">                <span class=\"search-btn\">搜索</span>                <span class=\"search-icon\"></span>            </div>            <span class=\"right-addHunter\">                <span class=\"addHunter-icon\"></span>                新增猎头            </span>        </div>    </div>    <div class=\"adm-thead\">        <span class=\"span214\">猎头公司</span>        <span class=\"span124 span124-active\">全部状态<span class=\"arrowDown\"></span>            <span class=\"status-frame\">                <label><input type=\"checkbox\">全部状态 <a>26</a></label><br>                <label><input type=\"checkbox\">启用中 <a>26</a></label><br>                <label><input type=\"checkbox\">已停用 <a>26</a></label>            </span>        </span>        <span class=\"span510\">登录帐号</span>        <span class=\"span220\">操作</span>    </div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-content\">        <span class=\"span214\">翰德(Hudson)</span>        <span class=\"span124 green\">启用中</span>        <span class=\"span510\"><a>aaa@163.com</a> <a>aaa@163.com</a><i class=\"arrowDown\"></i></span>        <span class=\"span220\"><a class=\"span-left red\">停用</a>  ｜  <a class=\"span-right click-red\" on-click={this.goHunterDetail()}>管理</a> </span>    </div>    <div class=\"line\"></div>    <div class=\"adm-bottom\">        <pager></pager>    </div></div>"
},{}],19:[function(require,module,exports){
/**
 * Created by hzchengshuli on 2016/10/28.
 */
var Component = require('../../base/component');
var template = require('./index.html');
var Modal = require('../../common/modal.js');
var Mask = require('../../common/mask.js');

var Cookie = require('../../../../../node_modules/js-cookie/src/js.cookie.js');
var _ = require('../../base/util.js');
var Pager = require('../../common/pager.js');

var Admin = Component.extend({
    template:template,
    config() {

    },

    init() {

    },

    /**
     * 增加猎头
     */
    addHunter() {

    },

    /**
     * 启用猎头
     */
    useHunter() {

    },

    /**
     * 停止使用猎头
     */
    stopHunter(){
    },

    goHunterDetail() {
        this.$state.go('app.hunterDetail');
    }
})

Admin.component('Pager',Pager);

module.exports = Admin;

},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../base/util.js":7,"../../common/mask.js":9,"../../common/modal.js":11,"../../common/pager.js":15,"./index.html":18}],20:[function(require,module,exports){
module.exports="<div class=\"g-hd\" ref=\"app\">	<div class=\"m-hd\">		<div class=\"header-logo f-ib \">			<a href=\"#/home\"><img src=\"./entry/img/hunter.png\" alt=\"\" height=\"40px\"></a>		</div>        {#if user}		<div class=\"header-cells f-ib \">			<ul class=\"m-nav-top f-cb\">				{#list navs as x}				<li class=\"f-ib\">					<a href=\"{x.url}\" r-class={{\'z-crt\':this.isSelected(x.match)}}  on-click={this.onSelected(x_index)}>{x.name}</a>				</li>				{/list}			</ul>		</div>		<div class=\"login-right f-ib f-fr\">		<div class=\"login-right-div\">			<i class=\"user-name\"></i>			<span class=\"username-span\">{user}</span>|			<span class=\"pointer-span\" on-click=\"{this.changePwd()}\">修改密码</span>|			<span class=\"pointer-span\" on-click=\"{this.logout()}\"><span>退出</span><i class=\"user-exit\"></i></span></div>		</div>		{/if}	</div></div><div class=\"g-mnc \" r-class={{\'g-mnc-1\':this.$state.current.name==\'app.home.index\'}} ref=view></div><div class=\"g-ft\">	<div class=\"footer_links\">		<div class=\"copyright\">			©1997-{newYear}网易公司版权所有		</div>	</div></div>"
},{}],21:[function(require,module,exports){
var Component = require('../../base/component');
var template = require('./app.html');
var _ = require('../../base/util.js'); 
var Cookie  = require('../../../../../node_modules/js-cookie/src/js.cookie.js');
var cacheServer = require('../../service.js');
var Emit =  require('../../base/emit.js');
var constant = require('../../base/constant.js');

var App = Component.extend({
	template:template,
	config:function(){

		let data=this.data;
        data.user =  Cookie.get('passport') || null;    //用户名
        data.userType=Cookie.get('userType') || null;  //用户类型
        data.newYear  = new Date().getFullYear();
		this.$update();
	},
	init:function () {

        //注册navShow
        Emit.observer.regist('navShow',()=>{this.navShow()})
		//注册navAdd
        Emit.observer.regist('navAdd', ()=> {this.navAdd()})
		if (this.data.userType){
            this.navAdd();
        }
		this.$update();
	},

    /**
	 * 用于显示导航栏
     */
	navAdd:function () {

		let data=this.data;
		data.userType=Cookie.get('userType');
		data.navs= (data.userType==constant.ADMIN?constant.ADMINNAVS:constant.USERNAVS);
        this.$update();
    },

	/**
	 * 登录成功后显示导航
	 * @param res
	 */
	navShow:function(){
		this.data.user = Cookie.get('passport');
		this.$update();
	},

    /**
	 * 用于显示被选中的状态
     * @param match         导航栏的match值
     * @returns {boolean}   返回当前路由的match值
     */
	isSelected:function(match){

		var isMatch = new RegExp(match);
		return isMatch.test(this.$state.current.name)
	},

    /**
	 *
     * @param index 目前被选中的索引
     */
	onSelected: function(index){

		this.data.currentIndex = index;

	},

	/**
	 * 忘记密码跳转
	 */
	changePwd:function(){

		this.$state.nav('/changepwd');
	},

    /**
	 * 登出操作
     */
	logout:function(){
		cacheServer.logout(function(data,result){
			Cookie.remove('passport');
            Cookie.remove('userType');
			this.$state.nav('/login');
			location.reload(true);
		}.bind(this),function () {
            this.$state.nav('/login');
        }.bind(this))
	}

});
module.exports = App;
},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../base/constant.js":3,"../../base/emit.js":4,"../../base/util.js":7,"../../service.js":42,"./app.html":20}],22:[function(require,module,exports){
module.exports="<div class=\"m-detail\">    <div class=\"detail f-cb\">        <div style=\"display: inline-block;\">            <div class=\"position-name\">                {detail.positionName}                <div class=\"triangle\"></div>            </div>        </div>        <div class=\"position-item\">            <span class=\"normal\">职位类别<br><a class=\"bgFont\">{detail.positionTypeName}</a></span><a class=\"line\"></a>            <span class=\"normal\">工作地点<br><a class=\"bgFont\">{detail.workPlaceName}</a></span><a class=\"line\"></a>            <span class=\"normal\">工作年限<br><a class=\"bgFont\">{detail.workYearsName}</a></span><a class=\"line\"></a>            <span class=\"normal\">最低学历<br><a class=\"bgFont\">{detail.topDegreeName}</a></span><a class=\"line\"></a>            <span class=\"normal\">招聘人数<br><a class=\"bgFont\">{detail.hireNum}</a></span><a class=\"line\"></a>            <span class=\"normal\">暂定级别&nbsp;                <i class=\"icon f-pr\" on-mouseover={this.showIcon(true)} on-mouseout={this.showIcon(fasle)}>                    <div class=\"icon-content\" r-hide={!show}>                        仅作推荐参考，与候选人最终offer定级无关                    </div>                </i><br>                <a class=\"bgFont\">{detail.level}</a>            </span><a class=\"line\"></a>            <span class=\"last\">HR意向<br><a class=\"bgFont\" >{detail.HRWill}</a></span>        </div>        <div class=\"position-detail\">            <div class=\"detail-dec\">                <span class=\"dec-header\">岗位描述</span>                <p r-html={detail.positionDsc}>                </p>            </div>            <div class=\"detail-req\">                <span class=\"req-header\">岗位要求</span>                <p r-html={detail.positionReq}>                </p>            </div>            <div class=\"deatil-footer \">                    <span class=\"button\" on-click={this.submit()}>                        我要推荐                    </span>                <div class=\"footer-mail .f-cb\">                    <span class=\"mail-title\">招聘负责人:</span>                    <span class=\"mail-person\">                        {#list detail.postionUserNameList as item}                            {item.name} | {item.email}<br>                        {/list}                    </span>                </div>            </div>        </div>    </div></div>"
},{}],23:[function(require,module,exports){
/**
 * Created by hzgaoquankang on 2017/5/1.
 */
var Component = require('../../base/component');
var template = require('./index.html');
var cacheService = require('../../service.js');

var Detail = Component.extend({
    template:template,



    config() {
        this.data.show=false;  //图标默认不显示
    },

    init() {

    },

    //获取id
    enter(option){
       let id=this.data.id=option.param.id;
       this.__getPositionDetail(id);
    },

    /**
     * 点击我要推荐按钮
     */
    submit() {
        let id=this.data.id;
        this.$state.go('app.upload',{param:{id:id}});
    },

    /**
     * hover时 展示
     */
    showIcon(bool){
        this.data.show=bool;
        this.$update();
    },

    /**
     * 获取详情页
     * @param id 职位编号
     * @private
     */
    __getPositionDetail(id){

        /**
         * 获取职位详细信息;
         * @param 职位编号
         */
        cacheService.getPositionDetail(id,result=>{
            this.data.detail=result;
            this.$update();
        })
    }

});

module.exports = Detail;
},{"../../base/component":2,"../../service.js":42,"./index.html":22}],24:[function(require,module,exports){
module.exports="<div class=\"hunter\">    这是推荐页面</div>"
},{}],25:[function(require,module,exports){
var Component = require('../../base/component');
var template = require('./index.html');
var Cookie = require('../../../../../node_modules/js-cookie/src/js.cookie.js');
var _ = require('../../base/util.js');
var cacheService = require('../../service.js');

var Headhunter = Component.extend({
    template:template,
    config:function () {

    },
    init:function () {

    }

})

module.exports=Headhunter;
},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../base/util.js":7,"../../service.js":42,"./index.html":24}],26:[function(require,module,exports){
module.exports="<div class=\"m-home\">    <div class=\"home\" >        <div class=\"home-search\" >            <div class=\"search-line\">                <span class=\"search-icon\"></span>                <input class=\"search-input\" r-model={searchValue} placeholder=\"请输入职位关键词\"/>            </div>            <span class=\"search-button\"  on-click={this.searchButton()}>搜索</span>        </div>        <div class=\"home-header\">            <div class=\"select-options\">                <span>工作地点：</span>                {#if workPlaceList}                    {#list workPlaceList as item}                        <span on-click={this.clickOption(\'workPlaceListFlag\',item_index)} class={flags.workPlaceListFlag[item_index]==true?\'live\':\'\'}>{workPlaceListFlag[item_index]==true?\'live\':\'\'}{item.name}</span>                    {/list}                {/if}            </div>            <div class=\"select-options\">                <span>工作年限：</span>                {#if workPlaceList}                    {#list workYearsList as item}                        <span on-click={this.clickOption(\'workYearsListFlag\',item_index)} class={flags.workYearsListFlag[item_index]==true?\'live\':\'\'}>{item.name}</span>                    {/list}                {/if}            </div>            <div class=\"select-options special\">                <span>职位类别：</span>                {#if workPlaceList}                    {#list positionTypeList as item}                        <span on-click={this.clickOption(\'positionTypeListFlag\',item_index)} class={flags.positionTypeListFlag[item_index]==true?\'live\':\'\'}>{item.name}</span>                    {/list}                {/if}            </div>        </div>        <div class=\"header-select\">            <span><i class=\"job\"></i> 招聘负责人                <select r-model={queryObj.postionUserId}>                        <option >请选择</option>                    {#list hrList as item}                        <option value={item.id}>{item.name}</option>                    {/list}                </select>            </span>            <span><i class=\"houses\"></i> 职位所在部门                <select r-model={queryObj.positionDepId}>                    <option >请选择</option>                    {#list departmentList as item}                        <option value={item.id}>{item.name}</option>                    {/list}                </select>            </span>            <span><i class=\"time\"></i> 职位状态                <select r-model={queryObj.positionName}>                    <option >请选择</option>                    <option value=0> 发布中</option>                    <option value=1> 禁用中</option>                </select>            </span>        </div>        <div class=\"home-content\" >            <div class=\"h-c-header\">                <span class=\"first-span\">职位名称</span>                <span>职位状态</span>                <span>职位类别</span>                <span>工作地点</span>                <span>工作年限</span>                <span>最低学历</span>                <span>招聘人数</span>                <span>更新日期</span>            </div>            {#if positionList}                {#list positionList as item}                    <div class=\"h-c-position f-pr {item.positionStatus==0?\'\':\'gray\'}\">                        <span class=\"first-span\">                            <a href={\"#/detail?id=\"+item.d} target=\"_blank\">{item.positionName}</a>                        </span>                        <span class= {item.positionStatus==0?\'live\':\'\'}>{item.positionStatus==0?\'发布中\':\'已暂停\'}</span>                        <span>{item.positionTypeName}</span>                        <span>{item.workPlaceName}</span>                        <span>{item.workYearsName}</span>                        <span>{item.topDegreeName}</span>                        <span>{item.hireNum}</span>                        <span>{item.updateDate}</span>                        {#if item.positionStatus==1}                            <a class=\"icon arrowDown\"></a>                        {#else}                            <a class=\"icon {arrowStatus[item_index]==true?\'arrowUp\':\'arrowDown\'}\" on-click={this.setArrow(item_index)}></a>                        {/if}                    </div>                    <div  r-hide={!arrowStatus[item_index]} class=\"h-c-deatil\">                        <div class=\"detail-dec\">                                <span class=\"dec-header\">岗 位 描 述</span>                                <p r-html={item.positionDsc}>                                </p>                        </div>                        <div class=\"detail-req\">                                <span class=\"req-header\">岗 位 要 求</span>                                <p r-html={item.positionReq}>                                </p>                        </div>                        <div class=\"deatil-footer\">                            <span class=\"button\" on-click={this.recommend(item.id)}>                                我要推荐                            </span>                            <div class=\"footer-mail .f-cb\">                                <span class=\"mail-title\">招聘负责人:</span>                                <span class=\"mail-person\">                                    {#list item.postionUserNameList as item}                                        {item.name} | {item.email}<br>                                    {/list}                                </span>                            </div>                        </div>                    </div>                {/list}            {/if}        </div>        <div class=\"home-page\">            {#if page.totalPage}            <pager total={page.totalPage} current={queryObj.currentPage} ></pager>            {/if}        </div>    </div></div>"
},{}],27:[function(require,module,exports){
/**
 * Created by hzchengshuli on 2016/10/28.
 */
var Component = require('../../base/component');
var template = require('./index.html');
var Cookie = require('../../../../../node_modules/js-cookie/src/js.cookie.js');
var _ = require('../../base/util.js');
var cacheService = require('../../service.js');
var Pager = require('../../common/pager.js');
var Search = require('../../common/search.js');


var Home = Component.extend({
    template:template,

    config() {
        this.data.queryObj={};             //初始查询条件
        this.data.arrowStatus=[];          //控制箭头显示上下
        this.data.flags={
            workPlaceListFlag:[true],      //默认选中不限
            workYearsListFlag:[true],      //默认选中无工作经验
            positionTypeListFlag:[true]    //默认选中职位类别
        };
        this.selectPage();                 //监听 子组件page切换的事件

    },

    init() {
        if(!Cookie.get('passport')){
            location.href='#/login';
            return;
        }
        this.__selectOptions();

        this.__queryPosition();
        this.$update();
    },

    /**
     * 路由进入时候钩子函数
     * @param option
     */
    enter(option) {
         this.update(option)
    },

    /**
     *可以监听到url变化
     * @param option
     */
    update(option) {
        const page=option.param.page;
        this.data.queryObj.currentPage=page || 1;
    },

    /**
     * 监听pager组件的页数变化
     */
    selectPage() {
        this.$on('selectPage',(obj)=>{
            let page=obj.current;
            return this.$state.go('app.home',{param:{page:page}});
        });
     },


    /**
     * 获取职位列表
     * @private
     */
    __queryPosition() {

        /**
         *监听：queryObj:输入查询条件对象
         */
        let data=this.data;
        this.$watch('queryObj',(newV,oldV) =>{

            /**
             * 获得职位列表
             * @param 查询条件对象
             */
            cacheService.positionList(newV, (result) =>{
                data.positionList=result.positionList;
                data.page=result.page;
                data.hrList=result.hrList;
                data.departmentList=result.departmentList;
                this.$update();
            })
        },true)
    },

    /**
     * 获取查询的选项 地点 工作经验 职位类别
     * @private
     */
    __selectOptions() {
        let data=this.data;
        cacheService.selectOptions(result=>{
            data.workPlaceList=result.workPlaceList;
            data.workYearsList=result.workYearsList;
            data.positionTypeList=result.positionTypeList;
            this.$update();
        });
    },

    /**
     * 点击箭头控制箭头的显示状态
     * @param index  第几个箭头
     */
    setArrow(index) {
        let arrowStatus=this.data.arrowStatus;
        arrowStatus[index]=!arrowStatus[index];
        this.$update();
    },

    /**
     * 点击我要推荐按钮
     */
    recommend(id) {
        this.$state.go('app.upload',{param:{id:id}});
    },

    /**============================================
     * 选项按钮  点击出现红色背景
     * @param option 类别
     * @param index  点击的哪一个选项
     * ============================================
     */
    clickOption(option,index) {

        let flags=this.data.flags,
            queryObj=this.data.queryObj,
            list=option.replace('Flag','');

        /**
         * o（n） 时间复杂度
         * 在首页点击 工作地点 工作年限 职位类别 中的选项切换时选项状态以及状态改变发出请求
         */
        for (let key in flags){
            if(option==key){
                for (let i=0;i<this.data[list].length;i++){
                    flags[option][i]=false;
                }
                flags[option][index]=true;
                queryObj[list]=index;
            }
            this.$update();
        }
    },

    /**
     * 点击搜索按钮
     */
    searchButton() {
        let data=this.data;
        data.queryObj.positionName=data.searchValue;
    }

})
Home.component('Pager',Pager);
Home.component('Search',Search);
module.exports = Home;

},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../base/util.js":7,"../../common/pager.js":15,"../../common/search.js":17,"../../service.js":42,"./index.html":26}],28:[function(require,module,exports){
module.exports="<div class=\"m-hunterDetail\">    <div class=\"hunter-main\">        <div class=\"main-header f-pr\">            <span class=\"back\" on-click={this.goBack()}>                <span class=\"backIcon\"></span>                返回            </span>            <span class=\"hunter-name\">                翰德(Hudson)            </span>            <span class=\"hunter-num\">                共有 <a class=\"red\">5</a> 个帐号正在启用            </span>            <span class=\"right-addHunter\">                <span class=\"addHunter-icon\"></span>                新增账号            </span>        </div>        <div class=\"thead\">            <span class=\"span219\">帐号姓名</span>            <span class=\"span369\">登录邮箱</span>            <span class=\"span124 span124-active\">全部状态                <span class=\"status-frame\">                    <label><input type=\"checkbox\">全部状态 <a>26</a></label><br>                    <label><input type=\"checkbox\">启用中 <a>26</a></label><br>                    <label><input type=\"checkbox\">已停用 <a>26</a></label>                </span>            </span>            <span class=\"span356\">帐号操作</span>        </div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-content\">            <span class=\"span219\">王小猎</span>            <span class=\"span369\">wanglie163163@163.com</span>            <span class=\"span124 green\">启用中</span>            <span class=\"span356 \">                <a class=\"click-red\">停用</a>            </span>        </div>        <div class=\"line\"></div>        <div class=\"hunter-bottom\">            <pager></pager>        </div>    </div></div>"
},{}],29:[function(require,module,exports){
/**
 * Created by hzgaoquankang on 2017/5/12.
 */

var Component = require('../../base/component');
var template = require('./index.html');
var cacheService = require('../../service.js');
var Pager = require('../../common/pager.js');

var hunterDetail = Component.extend({
    template:template,
    config() {

    },
    init() {

    },
    goBack() {
        this.$state.go('app.admin');
    }

})

hunterDetail.component('Pager',Pager);
module.exports=hunterDetail;
},{"../../base/component":2,"../../common/pager.js":15,"../../service.js":42,"./index.html":28}],30:[function(require,module,exports){
module.exports="<div class=\"m-login\" on-enter={this.submit()}>    <div class=\"login\">        <div class=\"login-header\">            <div class=\"reset-pwd\"><span class=\"login-header-span2\">修改密码</span></div>        </div>        <div class=\"form-login\">            <div class=\"form-row\">            <span class=\"icon\">                <i class=\"fa fa-pwd\"></i>            </span>                <input type=\"password\" placeholder=\"请输入旧密码\" name=\'passport\' r-model=\"{formData.password}\"/>            </div>            <div class=\"form-row\">                <span class=\"icon\">                    <i class=\"fa fa-pwd\"></i>                </span>                <input type=\"password\" placeholder=\"请输入新密码\" name=\"newPwd\" r-model=\"{formData.newPwd}\" on-focus=\"{this.pwdFocus()}\" on-blur=\"{this.pwdBlur()}\"/>            </div>            <div class=\"form-row\">            <span class=\"icon\">                <i class=\"fa fa-pwd\"></i>            </span>                <input type=\"password\" placeholder=\"请确认新密码\" name=\"newPwdAgain\" r-model=\"{formData.newPwdAgain}\"/>            </div>            <div class=\"login-tip\" >                <label class=\'login-err-tip\' r-hide=\"{errInfo == \'\'}\">{errInfo}</label>            </div>            <div class=\"form-row form-row-button\">                <input type=\"submit\" class=\'{btnFlag?\"button btn-active\":\"button btn-disable\"}\' value=\"修改密码\" on-click={this.submit()}/>            </div>            <div class=\"pwd-check-info pwd-check-info-change\" r-hide=\"{!pwdTotalStatus}\">                <div class=\"pwd-check-detail\">                    <p><span class=\'{pwdStatus.length?\"pwd-check-icon-right\":\"pwd-check-icon-wrong\"}\'></span>长度为6-16个字符</p>                    <p><span class=\'{pwdStatus.space?\"pwd-check-icon-right\":\"pwd-check-icon-wrong\"}\'></span>不能包含空格</p>                    <p><span class=\'{pwdStatus.number?\"pwd-check-icon-right\":\"pwd-check-icon-wrong\"}\'></span>不能是9位以下纯数字</p>                </div>                <i class=\"pwd-check-info-arrow-big\"></i>                <i class=\"pwd-check-info-arrow-small\"></i>            </div>        </div>    </div></div>"
},{}],31:[function(require,module,exports){
/*
* Create gaochuankang
* */
var Component = require('../../base/component');
var template = require('./changePwd.html');
var cacheService = require('../../service.js');
var Cookie = require('../../../../../node_modules/js-cookie/src/js.cookie.js')
var Mask = require('../../common/mask.js');
var Notify = require('../../common/notify.js');

var ChangePwd = Component.extend({
    template:template,

    init:function(){
        this.data.formData = {};
        this.data.errInfo = '';
        this.data.btnFlag = false;
        this.data.allFlag = {
            oldPwdFlag:false,
            newPwdFlag:false,
            newPwdAgainFlag:false
        };
        this.data.pwdStatus = {
            length:false,
            space:false,
            number:false
        }
        if(!Cookie.get('passport')){
            location.href='#/login';
            return;
        }
        this.__watchAll();
    },

    /**
     * 监听输入框的变化
     */
    __watchAll:function(){
        //当重新输入登录名时 取消错误信息
        var self = this;
        this.$watch('formData.password',function(newV,oldV){
            if(newV && newV != '' && newV.toString().trim()!=''){
                self.data.errInfo = '';
                self.data.allFlag.oldPwdFlag = true;
            }else{
                self.data.allFlag.oldPwdFlag = false;
            }
            self.__setBtn();
            self.$update();
        });

        this.$watch('formData.newPwd',function(newV,oldV){
            if(newV && newV != '' && newV.toString().trim()!=''){
                self.data.errInfo = '';
                self.data.allFlag.newPwdFlag = true;
                self.checkPwdStrength(newV);
            }else{
                self.data.allFlag.newPwdFlag = false;
            }
            self.__setBtn();
            self.$update();
        });

        this.$watch('formData.newPwdAgain',function(newV,oldV){

            if(newV && newV != '' && newV.toString().trim()!=''){
                self.data.errInfo = '';
                self.data.allFlag.newPwdAgainFlag = true;
            }else{
                self.data.allFlag.newPwdAgainFlag = false;
            }
            self.__setBtn();
            self.$update();
        })
    },
    /**
     * 密码强度判定
     * @private
     */
    checkPwdStrength:function(val){
        if(val.length<6 || val.length>16){
            this.data.pwdStatus.length = false;
        } else {
            this.data.pwdStatus.length = true;
        }

        if(val.indexOf(' ') >= 0){
            this.data.pwdStatus.space = false;
        } else {
            this.data.pwdStatus.space = true;
        }

        if(/^[0-9]{1,9}$/.test(val)){
            this.data.pwdStatus.number = false;

        }else {
            this.data.pwdStatus.number = true;
        }
    },
    /**
     * 获得焦点时触发的事件
     */
    pwdFocus:function(){
        this.data.pwdTotalStatus = true;
        this.$update();
    },
    pwdBlur:function(){
        for(var item in this.data.pwdStatus){
            if(this.data.pwdStatus[item] == false){

                return;
            }
        }
        this.data.pwdTotalStatus = false;
    },
    //控制按钮的显示与隐藏
    __setBtn:function(){

        for(var item in this.data.allFlag ){

            if(this.data.allFlag[item] == false){
                this.data.btnFlag = false;
                return;
            }
        }

        if(this.data.pwdTotalStatus == true){
            return;
        }

        this.data.btnFlag = true

    },


    /**
     * 提交表单
     */
    submit:function(){

        var  self = this;

        for(var item in self.data.allFlag){
            if(self.data.allFlag[item] == false){
                return;
            }
        }
        if(self.data.formData.newPwd !== self.data.formData.newPwdAgain){
            self.data.errInfo = '新密码输入不一致';
            return;
        }
        var uploadData = self.data.formData;

        delete uploadData.newPwdAgain;
        var mask = new Mask().$inject(document.body);
        cacheService.changePwd(uploadData,function(){
            Notify.success('修改密码成功，正在跳转~');
            clearTimeout(timer)
            var timer = setTimeout(function(){
                mask.close();
                self.$state.nav('/home');
            },1000);

        },function(err,errResult){
            mask.close();

            self.data.errInfo = errResult.msg;
            self.data.formData.password ='';
            self.data.formData.newPwd = '';
            self.data.formData.newPwdAgain = '';


            for(var item in self.data.allFlag ){
                self.data.allFlag[item] = false;
            }

            self.$update();
        });
    }
})

module.exports = ChangePwd;
},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../common/mask.js":9,"../../common/notify.js":13,"../../service.js":42,"./changePwd.html":30}],32:[function(require,module,exports){
module.exports="<div class=\"m-login\" on-enter=\"{this.submit($event)}\"><div class=\"login\">    <div class=\"login-header\">        <div><span class=\"login-header-span2\">网易猎头系统</span></div>    </div>    <div class=\"form-login\">        <div class=\"form-row \">            <span class=\"icon\">                <i class=\"fa fa-email\"></i>            </span>            <input type=\"text\" placeholder=\"请输入邮箱\" name=\'email\' r-model=\"{formData.email}\" r-autofocus/>        </div>        <div class=\"form-row \">            <span class=\"icon\">                <i class=\"fa fa-pwd\"></i>            </span>            <input type=\"password\" placeholder=\"请输入密码\" name=\"password\" r-model=\"{formData.password}\"/>        </div>        <div class=\"code-adjust\">        <div class=\"form-row form-row-code \">            <span class=\"icon\">                <i class=\"fa fa-token\"></i>            </span>            <input  class=\"shortInp\" type=\"text\" placeholder=\"请输入验证码\" name=\"code\" r-model=\"{formData.validateCode}\"/>        </div>            <img src=\"/sys/getVerifyCode.do\" class=\"login-code\" on-click=\"{this.updateValiationCode()}\" ref=valiationImg/>        </div>        <div class=\"login-tip\" >            <div class=\"f-cb\">            <label class=\'login-err-tip error\' r-hide=\"{errInfo == \'1\'}\">{errInfo}</label>            </div>            <div class=\"f-cb\">                <label class=\"login-remember-tip\"><input type=\"checkbox\" class=\"rem\" r-model=\"{remPassword}\">记住密码</label>                <label class=\"login-reset-tip\"><a on-click=\"{this.changeToReset()}\">忘记密码?</a></label>            </div>        </div>        <div class=\"form-row form-row-button\" >            <input type=\"submit\" class=\' {btnFlag?\"button btn-active\":\"button btn-disable\"}\' value=\"登   录\"   on-click={this.submit()}/>        </div>    </div></div></div>"
},{}],33:[function(require,module,exports){

var Component = require('../../base/component');
var template = require('./index.html');
var cacheService = require('../../service.js');
var Notify = require('../../common/notify');
var Mask = require('../../common/mask.js');
var Cookies = require('../../../../../node_modules/js-cookie/src/js.cookie.js')
var Emit =  require('../../base/emit.js');

var Login = Component.extend({
    template:template,
    init:function(){
        this.data.remPassword=true;  //记住密码框
        this.data.formData = {};
        this.data.errInfo = '';
        this.data.btnFlag = false;
        this.data.allFlag = {
            emailFlag:false,
            // idFlag:false,
            pwdFlag:false,
            codeFlag:false
        };
        this.__watchAll();
        this.$update();
    },

    /**
     * 监听输入框的变化
     */
    __watchAll:function(){
        //当重新输入登录名时 取消错误信息
        this.$watch('formData.email|escape',function(newV,oldV){
            if(newV != '' && newV.trim() !=''){
                this.data.errInfo = '';
                this.data.allFlag.emailFlag = true;

            } else {
                this.data.allFlag.emailFlag = false;
            }
            this.__setBtn();
            this.$update();

        }.bind(this));
        this.$watch('formData.password|escape',function(newV,oldV){
            if(newV != ''&& newV.trim() !=''){
                this.data.errInfo = '';
                this.data.allFlag.pwdFlag = true;

            }else{
                this.data.allFlag.pwdFlag = false;
            }
            this.__setBtn();
            this.$update();
        }.bind(this));
        this.$watch('formData.validateCode|escape',function(newV,oldV){
            if(newV != ''&& newV.trim() !=''){
                this.data.errInfo = '';
                this.data.allFlag.codeFlag = true;
            }else{
                this.data.allFlag.codeFlag = false;
            }
            this.__setBtn();
            this.$update();
        }.bind(this))

    },


    /**
     * 更新验证码
     */
    updateValiationCode:function(){
        var timestamp = new Date().getTime();
        this.$refs.valiationImg.src = ' /sys/getVerifyCode.do?timestamp=' + timestamp;
        this.$update();
    },

    //控制按钮的显示与隐藏
    __setBtn:function(){

        for(var item in this.data.allFlag ){

            if(this.data.allFlag[item] == false){
                this.data.btnFlag = false;

                return;
            }
        }

        this.data.btnFlag = true
    },

    /**
     * 忘记密码
     */
    changeToReset:function(){
        this.$state.nav('/resetpwd');

    },

    /**
     * 提交表单
     */
    submit:function() {
        var self = this;
        for(var item in self.data.allFlag){
            if(self.data.allFlag[item] == false){
                return;
            }
        }

        var mask = new Mask().$inject(document.body);
        cacheService.login(this.data.formData, function (data) {
            Notify.success('登录成功 正在跳转~~');
            clearTimeout(timer)
            var timer = setTimeout(function(){
                mask.close();
                data.userType==1?self.$state.nav('/admin'):self.$state.nav('/home');
            }, 1000);
            Cookies.set('passport', data.companyName);
            Cookies.set('userType',data.userType);
            if(self.data.remPassword){
                Cookies.set('passport',data.companyName, {expires: 5});
                Cookies.set('userType',data.userType,{expires: 5});
            }
            Emit.observer.fire('navAdd');
            Emit.observer.fire('navShow',data.companyName);
        }, function (errData, errResult) {
            mask.close();
            if (errResult&&errResult.code == 302) {
                self.data.errInfo = '尝试次数过多，请稍后再试'
            }
            self.data.errInfo = errResult.msg;
            if(self.data.errInfo == '验证码错误！'){
                self.data.formData.validateCode = ''
                self.data.allFlag.codeFlag = false;
            } else {
                self.data.formData.email = '';
                self.data.formData.password = '';
                self.data.formData.validateCode = '';
                for (var item in self.data.allFlag) {
                    self.data.allFlag[item] = false;
                }
            }
            self.updateValiationCode();
            self.$update();
        });
    }

});


module.exports = Login;
},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../base/emit.js":4,"../../common/mask.js":9,"../../common/notify":13,"../../service.js":42,"./index.html":32}],34:[function(require,module,exports){
module.exports="<div class=\"m-login\">    {#if currentStatus == 1}    <div class=\"login\" on-enter={this.submit1()}>        <div class=\"login-header\">            <div class=\"reset-pwd\"><span class=\"login-header-span2\">重置密码</span></div>        </div>        <div class=\"form-login\">            <div class=\"form-row\">                <span class=\"icon\">                    <i class=\"fa fa-name\"></i>                </span>                <input type=\"text\" placeholder=\"请输入邮箱\" name=\'email\' r-model=\"{formData.email}\"/>            </div>            <div class=\"login-tip\" >                <label class=\'login-err-tip\' r-hide=\"{errInfo == \'\'}\">{errInfo}</label>            </div>            <div class=\"form-row form-row-button\">                <input type=\"submit\" class=\'{firstBtnFlag?\"button btn-active\":\"button btn-disable\"}\' value=\"发送重置密码邮件\" on-click={this.submit1()}/>            </div>        </div>    </div>    {#elseif currentStatus == 2}    <div class=\"login reset-info\">        <p class=\"reset-info-title\">发送成功！</p>        <p>已发送邮件至 {email}, 请登录邮箱重置密码。该邮件的有效期为24小时。</p>        <p>该邮箱是您应聘时提供的邮箱，若邮箱有误，请联系HR修改。</p>        <p>没有收到重置邮件？点此 <a on-click=\"{this.submit1()}\">重新发送</a></p>    </div>    {#elseif currentStatus == 3}    <div class=\"login\" on-enter={this.submit2()}>        <div class=\"login-header\">            <div class=\"reset-pwd\"><span class=\"login-header-span2\">重置密码</span></div>        </div>        <div class=\"form-login\">            <div class=\"form-row\">                <span class=\"icon\">                    <i class=\"fa fa-pwd\"></i>                </span>                <input type=\"password\" placeholder=\"请输入新密码\" name=\'newPwd\' r-model=\"{formData.newPwd}\" on-focus=\"{this.pwdFocus()}\" on-blur=\"{this.pwdBlur()}\"/>            </div>            <div class=\"form-row\">                <span class=\"icon\">                    <i class=\"fa fa-pwd\"></i>                </span>                <input type=\"password\" placeholder=\"请确认新密码\" name=\"newPwdAgain\" r-model=\"{formData.newPwdAgain}\"/>            </div>            <div class=\"login-tip\" >                <label class=\'login-err-tip\' r-hide=\"{errInfo == \'\'}\">{errInfo}</label>            </div>            <div class=\"form-row form-row-button\">                <input type=\"submit\" class=\'{secondBtnFlag?\"button btn-active\":\"button btn-disable\"}\' value=\"重置密码\" on-click={this.submit2()}/>            </div>            <div class=\"pwd-check-info pwd-check-info-reset\" r-hide=\"{!pwdTotalStatus}\">                <div class=\"pwd-check-detail\">                    <p><span class=\'{pwdStatus.length?\"pwd-check-icon-right\":\"pwd-check-icon-wrong\"}\'></span>长度为6-16个字符</p>                    <p><span class=\'{pwdStatus.space?\"pwd-check-icon-right\":\"pwd-check-icon-wrong\"}\'></span>不能包含空格</p>                    <p><span class=\'{pwdStatus.number?\"pwd-check-icon-right\":\"pwd-check-icon-wrong\"}\'></span>不能是9位以下纯数字</p>                </div>                <i class=\"pwd-check-info-arrow-big\"></i>                <i class=\"pwd-check-info-arrow-small\"></i>            </div>        </div>    </div>    {#elseif currentStatus == 4}    <div class=\"login reset-info\">        <p class=\"reset-info-title\">链接打开失败！</p>        <p>链接不正确,是否已经过期了?重新申请吧</p>    </div>    {#elseif currentStatus == 5}    <div class=\"login reset-info\">        <p class=\"reset-info-title\">链接打开失败！</p>        <p>链接已经过期,请重新申请找回密码</p>    </div>    {#elseif currentStatus == 6}    <div class=\"login reset-info\">        <p class=\"reset-info-title\">链接打开失败！</p>        <p>链接错误,无法找到匹配用户,请重新申请找回密码</p>    </div>    {#elseif currentStatus == 7}    <div class=\"login reset-info\">        <p class=\"reset-info-title\">链接打开失败！</p>        <p>链接不完整,请重新生成</p>    </div>    {/if}</div>"
},{}],35:[function(require,module,exports){

var Component = require('../../base/component');
var template = require('./resetPwd.html');
var cacheService = require('../../service.js');
var _ = require('../../base/util.js');
var Mask = require('../../common/mask.js');
var Notify = require('../../common/notify.js');

var ResetPwd = Component.extend({
    template:template,

    init:function(){
        this.data.formData = {};
        this.data.errInfo = '';


        this.data.firstAllFlag = {
            emailFlag:false
        };

        this.data.secondAllFlag = {
            newPwdFlag:false,
            newPwdAgainFlag:false,
        };
        this.data.pwdStatus = {
            length:false,
            space:false,
            number:false
        }
        this.__getCurrentStatus();

        this.__watchAll();
    },

    /**
     * 获取当前页面状态
     * @private
     */
    __getCurrentStatus:function(){

        var self = this;
        var params = _.getParams(window.location.href);
        if(!_.isEmptyObject(params)){
            this.data.currentStatus = params.status;
            if(this.data.currentStatus == 3){
                self.data.secondBtnFlag = false;
                self.$update();
            }
            this.$update();
        } else {
            this.data.currentStatus = 1;
            this.data.firstBtnFlag = false;
            this.$update();
        }
    },

    /**
     * 监听输入框的变化
     */
    __watchAll:function(){
        //当重新输入登录名时 取消错误信息
        var self = this;
        this.$watch('formData.email',function(newV,oldV){
            if(newV != '' && newV.trim()!=''){
                self.data.errInfo = '';
                self.data.firstAllFlag.emailFlag = true;

            }else{
                self.data.firstAllFlag.emailFlag = false;
            }
            self.__setBtn('firstAllFlag','firstBtnFlag');
            self.$update();
        });

        this.$watch('formData.newPwd',function(newV,oldV){
            if(newV != '' && newV.trim()!='') {
                self.data.errInfo = '';
                self.data.secondAllFlag.newPwdFlag = true;
                self.checkPwdStrength(newV);
            }else{
                self.data.secondAllFlag.newPwdFlag = false;

            }
            self.__setBtn('secondAllFlag','secondBtnFlag');
            self.$update();
        });

        this.$watch('formData.newPwdAgain',function(newV,oldV){
            if(newV===undefined){
                return;
            }
            if(newV != '' && newV.trim()!=''){
                self.data.errInfo = '';
                self.data.secondAllFlag.newPwdAgainFlag = true;

            }else{
                self.data.secondAllFlag.newPwdAgainFlag = false;
            }
            self.__setBtn('secondAllFlag','secondBtnFlag');
            self.$update();
        })
    },

    /**
     * 密码强度判定
     * @private
     */
    checkPwdStrength:function(val){
        if(val.length<6 || val.length>16){
            this.data.pwdStatus.length = false;
        } else {
            this.data.pwdStatus.length = true;
        }

        if(val.indexOf(' ') >= 0){
            this.data.pwdStatus.space = false;
        } else {
            this.data.pwdStatus.space = true;
        }

        if(/^[0-9]{1,9}$/.test(val)){
            this.data.pwdStatus.number = false;

        }else {
            this.data.pwdStatus.number = true;
        }
    },
    /**
     * 获得焦点时触发的事件
     */
    pwdFocus:function(){

        this.data.pwdTotalStatus = true;
        this.$update();
    },
    pwdBlur:function(){
        for(var item in this.data.pwdStatus){
            if(this.data.pwdStatus[item] == false){
                return;
            }
        }
        this.data.pwdTotalStatus = false;
    },

    //控制按钮的显示与隐藏
    __setBtn:function(flag,btn){


        for(var item in this.data[flag] ){

            if(this.data[flag][item] == false){
                this.data[btn] = false;
                return;
            }
        }
        if(flag == 'secondAllFlag'){
            if(this.data.pwdTotalStatus == true){
                return;
            }
        }

        this.data[btn] = true
    },

    /**
     * 发送重置密码邮件时提交表单
     */
    submit1:function(){
        var  self = this;
        for(var item in self.data.firstAllFlag ){
            if(self.data.firstAllFlag[item] == false){
                return;
            }
        }
        var mask = new Mask().$inject(document.body);
        cacheService.sendResetPwdEmail(this.data.formData,function(data,result){
            mask.close();
            self.data.email = data;
            self.data.currentStatus = 2;
            self.$update();

        },function(err,errResult){

            mask.close();
            self.data.errInfo = errResult.msg;
            self.data.formData.email ='';
            self.data.firstAllFlag['emailFlag'] = false;

            self.__setBtn('firstAllFlag','firstBtnFlag');

            self.$update();
        });
    },


    /**
     * 重置密码发送请求
     */
    submit2:function(){
        var  self = this;
        for(var item in self.data.secondAllFlag ){
            if(self.data.secondAllFlag[item] == false){
                return;
            }
        }
        for(var item in self.data.pwdStatus){
            if(self.data.pwdStatus[item] == false){
                return;
            }
        }
        if(self.data.formData.newPwd !== self.data.formData.newPwdAgain){
            self.data.errInfo = '新密码输入不一致';
            return;
        }
        delete self.data.formData.newPwdAgain;
        var mask = new Mask().$inject(document.body);

        cacheService.resetPwd(this.data.formData,function(){

            Notify.success('重置密码成功，正在跳转~');
            clearTimeout(timer)
            var timer = setTimeout(function(){
                mask.close();
                self.$state.nav('/login');
            },1000);


        },function(err,errResult){

            mask.close();

            self.data.errInfo = errResult.msg;
            self.data.formData.newPwd = '';
            self.data.formData.newPwdAgain = '';


            for(var item in self.data.secondAllFlag ){
                self.data.secondAllFlag[item] = false;
            }
            self.__setBtn('secondAllFlag','secondBtnFlag');
            self.$update();
        });
    }
});

module.exports = ResetPwd;
},{"../../base/component":2,"../../base/util.js":7,"../../common/mask.js":9,"../../common/notify.js":13,"../../service.js":42,"./resetPwd.html":34}],36:[function(require,module,exports){
module.exports="<div class=\"m-home\">    <div class=\"home\" >        <div class=\"home-content \" style=\"margin-top: 30px;\">            <div class=\"h-c-header\">                <span class=\"first-span rem-first-span\">推荐职位</span>                <span class=\"rem-span\">候选人姓名</span>                <span class=\"rem-span\">推荐时间</span>                <span class=\"rem-span\">招聘负责人</span>                <span class=\"rem-span\">最新状态</span>            </div>            {#list recommendList as item}            <div class=\"h-c-position f-pr\">                        <span class=\"first-span rem-f-span\">                            <a href={\"#/detail?id=\"+item.id} target=\"_blank\">{item.positionName}</a>                        </span>                <span class=\"rem-span\">                        {item.appName}                </span>                <span class=\"rem-span\">{item.updateTimeStr}</span>                <span class=\"rem-span\" style=\"position: relative;\">                    <a on-mouseover={this.showIcon(item_index,true)} on-mouseout={this.showIcon(item_index,fasle)}>                            {item.postionUserName}                    </a>                </span>                <span class=\"rem-span\">{item.statusName}</span>                <div class=\"reminder-email\" r-hide={!arrowStatus[item_index]}>{item.email}</div>            </div>            {/list}        </div>        <div class=\"home-page\">            {#if pages.totalPage}            <pager total={pages.totalPage} current={page} ></pager>            {/if}        </div>    </div></div>"
},{}],37:[function(require,module,exports){
var Component = require('../../base/component');
var template = require('./index.html');
var Cookie = require('../../../../../node_modules/js-cookie/src/js.cookie.js');
var _ = require('../../base/util.js');
var cacheService = require('../../service.js');
var Pager = require('../../common/pager.js');

var Recommend = Component.extend({
    template:template,

    config() {
        this.data.show=false;
        this.data.arrowStatus=[];          //控制div显示
        this.data.page=1;                  //默认显示第一页

    },

    init() {
        this.selectPage();
    },


    /**
     * 路由进入时候钩子函数
     * @param option
     */
    enter(option) {
        this.update(option)
    },
    /**
     *可以监听到url变化
     * @param option
     */
    update(option) {
        let data=this.data;
         data.page=option.param.page || 1;
         this.myRecommend(data.page);
    },

    /**
     * 监听pager组件的页数变化
     */
    selectPage() {
        this.$on('selectPage',(obj)=>{
            let page=obj.current;
            return this.$state.go('app.recommend',{param:{page:page}});
        });
    },


    /**
     * hover时 展示提示字体
     */
    showIcon(index,bool) {
        let arrowStatus=this.data.arrowStatus;
        arrowStatus[index]=bool;
        this.$update();
    },

    /**
     * 得到我的推荐
     */
    myRecommend(currentPage){
        let data=this.data;

        /**
         * 获得我推荐的简历
         */
        cacheService.myRecommend({currentPage},(result)=> {
            data.pages=result.page;
            data.recommendList=result.list;
            this.$update();
        })
    }
});

Recommend.component('Pager',Pager);

module.exports=Recommend;
},{"../../../../../node_modules/js-cookie/src/js.cookie.js":45,"../../base/component":2,"../../base/util.js":7,"../../common/pager.js":15,"../../service.js":42,"./index.html":36}],38:[function(require,module,exports){
module.exports="<div class=\"upload\">    <div  class=\"upload-h\">        {detail.positionName}        <div class=\"h-detail\">            <span>职位类别：<span class=\"child\">{detail.positionTypeName}</span></span>            <span>工作地点：<span class=\"child\">{detail.workPlaceName}</span></span>            <span>工作年限：<span class=\"child\">{detail.workYearsName}</span></span>        </div>    </div>    <div class=\"upload-c\" >        <div class=\"c-left\">            <div on-click={this.switchMoudel({uploadFile:\'true\'})} class={uploadFile===\'true\'?\'left-tab-live\':\'left-tab\'}>                上传新简历                <div class=\"live\"></div>            </div>            <div on-click={this.switchMoudel({selectFile:\'true\'})} class={selectFile===\'true\'?\'left-tab-live\':\'left-tab\'}>                选择已有简历                <div class=\"live\"></div>            </div>        </div>        <div class=\"c-right\"  r-hide={!(uploadFile==\'true\')}>            <div class=\"right-frist\">                <label>                    <span class=\"red\">*</span>                    <span class=\"name \">姓<span class=\"blank\"></span>名:</span>                    <input type=\"text\"  r-model={form1Data.appName}>                </label>                <label style=\"margin-top:30px; height: 17px; \">                    <span class=\"red\">*</span>                    <span class=\"name\" >性<span class=\"blank\"></span>别:</span>                    <input type=\"radio\" r-model={form1Data.gender} class=\"radio\" value=\"0\" name=\"gender\">男<span class=\"blank\"></span>                    <input type=\"radio\" r-model={form1Data.gender} class=\"radio\" value=\"1\" name=\"gender\">女                </label>                <label style=\"margin-top:30px; \">                    <span class=\"red\">*</span>                    <span class=\"name \">手<span class=\"blank2\"></span>机<span class=\"blank2\"></span>号<span class=\"blank2\"></span>码:</span>                    <input type=\"text\" r-model={form1Data.mobile} on-blur={this.control(form1Data.mobile,\'mobile\')}>                    {#if errData[\'mobile\']==1}                        <span class=\"red\">填写错误！</span>                    {/if}                </label>                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">电 <span class=\"blank2\"></span>子<span class=\"blank2\"></span>邮<span class=\"blank2\"></span>箱:</span>                    <input type=\"text\" r-model={form1Data.email} on-blur={this.control(form1Data.email,\'email\')}>                    {#if errData[\'email\']==1}                    <span class=\"red\">填写错误！</span>                    {/if}                </label>            </div>            <div class=\"right-second\">                <label style=\"margin-top:27px;\">                    <span class=\"red\">*</span>                    <span class=\"name\" style=\"letter-spacing: 2.5px;\">参加工作年月:</span>                    <select class=\"select1\" r-model={work.Year}>                        <option value=\"\">请选择</option>                        {#list yearsArray as item}                            <option value={item}>{item}年</option>                        {/list}                    </select>                    <select class=\"select2\" r-model={work.Month}>                        <option value=\"\">请选择</option>                        {#list monthsArray as item}                            <option value={item}>{item}月</option>                        {/list}                    </select>                </label>                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">最<span class=\"blank2\"></span>高<span class=\"blank2\"></span>学<span class=\"blank2\"></span>历:</span>                    <select class=\"select1\" r-model={form1Data.topDegree}>                        <option value=\"\">请选择学历</option>                        {#list degree as item}                            <option value={item.id}>{item.name}</option>                        {/list}                    </select>                </label>                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\" >目<span class=\"blank2\"></span>前<span class=\"blank2\"></span>工<span class=\"blank2\"></span>司:</span>                    <input type=\"text\" r-model={form1Data.nowCompany}>                    <a class=\"icon\">                        <span>                            若已离职，可填写最近一份工作情况                        </span>                    </a>                </label>                <label style=\"margin-top:40px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">目<span class=\"blank2\"></span>前<span class=\"blank2\"></span>职<span class=\"blank2\"></span>位:</span>                    <input type=\"text\" r-model={form1Data.nowPosition}>                </label>            </div>            <div class=\"right-third f-cb f-pr\" >                <label style=\"margin-top:40px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">简<span class=\"blank2\"></span>历<span class=\"blank2\"></span>附<span class=\"blank2\"></span>件:</span>                    <form  class=\'info-form\' ref=\"form\"  action=\"/file/upload\" enctype=\"multipart/form-data\" method=\"post\">                                {#if filename}                                    <div class=\"f-pr\" style=\"text-indent: 10px\">                                        {filename}                                    </div>                                {#else}                                    <div class=\"f-pr\" style=\"margin-left:10px;\">                                        <input type=\"file\" name=\'file\' on-change={this.__uploadFile($event)} />                                        <div class=\"upload-file\">                                                <div class=\"button-up\">                                                    选择                                                </div>                                        </div>                                    </div>                        {/if}                    </form>                </label>                <span class=\"reminder\">                    文件需小于20M，可上传doc、docx、pdf、jpg、gif、png、jpeg格式                </span>                    {#if form1button==\'true\'}                        <span class=\"submit\"  on-click={this.submitIntab1()}>                            我要推荐                        </span>                    {#else}                        <span class=\"submit graybutton\"  on-click={this.submitIntab1()}>                            我要推荐                        </span>                    {/if}            </div>        </div>        <div class=\"c-right\"   r-hide={!(selectFile==\'true\')}>            <div class=\"right-frist\">                <label class=\"f-pr\">                    <span class=\"red\">*</span>                    <span class=\"name \">被<span class=\"blank2\"></span>推<span class=\"blank2\"></span>荐<span class=\"blank2\"></span>人:</span>                    <span class=\"nameNow\">{currentResume.appName}</span>                    <span class=\"button small\" on-click={this.selectHaveFile()} >                        选择简历                    </span>                    <span class=\"reminder\">                         注：同一个人一次只能被推荐到一个职位，若应聘失败，在该候选人的猎头保护期内可重新推荐                    </span>                </label>                <label style=\"margin-top:60px; height: 17px; \">                    <span class=\"red\">*</span>                    <span class=\"name \">性<span class=\"blank\"></span>别:</span>                    <span >{#if currentResume.gender==0}男{#elseif currentResume.gender==1}女{/if}</span>                </label>                <label style=\"margin-top:30px; \">                    <span class=\"red\">*</span>                    <span class=\"name \">手<span class=\"blank2\"></span>机<span class=\"blank2\"></span>号<span class=\"blank2\"></span>码:</span>                    <span >{currentResume.mobile}</span>                </label>                <label style=\"margin-top:10px; \">                    <span class=\"red\">*</span>                    <span class=\"name \">电<span class=\"blank2\"></span>子<span class=\"blank2\"></span>邮<span class=\"blank2\"></span>箱:</span>                    <span >{currentResume.email}</span>                </label>            </div>            <div class=\"right-second\">                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\" style=\"letter-spacing: 2.6px;\">参加工作年月:</span>                    <span >{currentResume.workYearStr}</span>                </label>                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">最<span class=\"blank2\"></span>高<span class=\"blank2\"></span>学<span class=\"blank2\"></span>历:</span>                    <span >{currentResume.degreeStr}</span>                </label>                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">目<span class=\"blank2\"></span>前<span class=\"blank2\"></span>工<span class=\"blank2\"></span>司:</span>                    <span >{currentResume.nowCompany}</span>                </label>                <label style=\"margin-top:20px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">目<span class=\"blank2\"></span>前<span class=\"blank2\"></span>职<span class=\"blank2\"></span>位:</span>                    <span >{currentResume.nowPosition}</span>                </label>            </div>            <div class=\"right-third f-cb f-pr\">                <label style=\"margin-top:40px;\">                    <span class=\"red\">*</span>                    <span class=\"name\">简<span class=\"blank2\"></span>历<span class=\"blank2\"></span>附<span class=\"blank2\"></span>件:</span>                    <span style=\"margin-left: 10px;\">{currentResume.appendixName}</span>                </label>                {#if currentResume.appName}                    <span class=\"submit\" on-click={this.submitIntab2()}>                        我要推荐                    </span>                {#else}                    <span class=\"submit graybutton\">                        我要推荐                    </span>                {/if}            </div>        </div>    </div></div>"
},{}],39:[function(require,module,exports){
/**
 * Created by hzgaoquankang on 2017/5/3.
 */

var Component = require('../../base/component');
var template = require('./index.html');
var _ = require('../../base/util.js');
var cacheService = require('../../service.js');
var Notify = require('../../common/notify');
var Mask = require('../../common/mask.js');
var Modal = require('../../common/modal.js');
var mk = require('marked');
var selectModel=require('./selectModel.html');
var Pager = require('../../common/pager.js');

var Recommend = Component.extend({
    template:template,

    config() {

        this.data.uploadFile='true';     //便于解构赋值  用字符串true
        this.data.form1Data={};          //上传新简历表单初始值为空
        this.data.form1button='false';   //上传简历中我要推荐按钮
        this.data.work={};              //参加工作时间 下拉选项
        this.data.errData={};          //初始错误信息为空
        this.data.currentPage=1;       //初始第一页
        this.data.currentResume={};    //当前简历
        this.data.degree={};          //当前学位
    },

    init() {
        this.getYearsAndMonth();
        this.checkTab1();
        this.degree();
    },

    enter(option) {
        let id =option.param.id;
        this.__getPositionDetail(id);
        this.data.form1Data.id=id;   //获取职位id
    },

    /**
     * 切换选项卡
     * @param uploadFile   上传新简历选项卡控制
     * @param selectFile   选择以有简历选项卡控制
     */
    switchMoudel({uploadFile='fasle',selectFile='fasle'}){
        let data=this.data;
        [data.uploadFile,data.selectFile] = [uploadFile,selectFile] ;
        this.$update();
    },


    /**
     * 得到职位信息
     * @param id
     * @private
     */
    __getPositionDetail(id){


        /**
         * 获取职位详细信息;
         * @param 职位编号
         */
        cacheService.getPositionDetail(id,result=>{
            this.data.detail=result;
            this.$update();
        })
    },


    /**
     * 上传新简历点击推荐推荐
     */
    submitIntab1() {
        let form1button=this.data.form1button,
            form1Data=this.data.form1Data;
        form1button=='true'?this.recommendUpload(form1Data):[];
    },

    /**
     * 点击我要推荐 上传简历
     * @param form1Data
     */
    recommendUpload(form1Data) {

        /**
         * 出现弹窗
         */
        new Modal({
            data: {
                title: '提示',
                contentTemplate: mk('<p class="card-p">确认候选人简历信息准确<br>推荐成功猎头保护期为 6 个月</p>'),
                okButton: '确认',
                cancelButton: '取消',
                width:400
            }

        }).$on('ok', function () {

            /**
             * 点击ok 提交上传简历请求。
             */
            cacheService.recommendUpload(form1Data,(data)=>{
                new Modal({
                    data: {
                        title: '通知',
                        contentTemplate: mk('<p class="card-p">推荐成功！</p>'),
                        okButton: '确认',
                        width:400
                    }

                }).$on('ok', function () {

                })


            },(errdata,errResult)=>{

                let msg=errResult.msg;
                // msg   在errResult里面
                new Modal({
                    data: {
                        title: '推荐失败',
                        contentTemplate: mk('<p class="card-p">'+msg+'</p>'),
                        okButton: '确认',
                        width:400
                    }

                }).$on('ok', function () {

                })
            })
        })


    },

    /**
     * 选择已有简历推荐
     */
    submitIntab2() {
        let currentResume=this.data.currentResume;
        this.recommendUpload(currentResume);
    },


    /**
     * 判断号码和邮箱      （号码只对长度做了判断）
     * @param option     需要判断的值
     * @param name       需要判断的属性名
     */
    control(option,name) {
       let  errData=this.data.errData;
       if(name=='mobile'){
           option.length==11?errData[name]=0:errData[name]=1;
       }else {
           let reg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/;
           reg.test(option)==true?errData[name]=0:errData[name]=1;
       }
            this.$update();
    },

    degree() {
        cacheService.getDegree((result)=> {
            this.data.degree=result;
            this.$update();
        })
    },
    /**
     * 选择已有简历
     */
    selectHaveFile() {
        let _self = this;

        this.getResume(null,1,function () {

            let resume=_self.data.resume,
                page=_self.data.page;
            new Modal({
                data: {
                    title: '选择已有简历',
                    contentTemplate: mk(selectModel),    // selectModel 模板
                    okButton: false,
                    width:860,
                    resume,
                    page
                },

                /**
                 * 猎头得到简历
                 */
                getResume(appName,currentPage){
                    _self.getResume(appName,currentPage,()=>{
                        this.data.resume=_self.data.resume;
                        this.data.page=_self.data.page;
                        this.$update();
                    });
                },

                /**
                 * 让父组件获得page
                 * @param obj
                 */
                pageNow(obj){
                    let page=obj.current,
                        data=this.data;
                    _self.data.currentPage=page;
                    this.getResume(data.appName,page)
                },

                /**
                 * 当前简历
                 * @param obj
                 */
                resume(obj){
                    _self.data.currentResume=obj;
                    _self.$update();
                    this.destroy();
                }

            })
        });

    },


    /**
     * 获得猎头已有的简历
     * @param appName     搜索框输入的内容
     * @param currentPage 当前页
     * @param callback
     */
     getResume(appName,currentPage,callback){

        let selectObj={
            appName:appName || null,
            currentPage:currentPage || 1,
            rows:6
        };
        cacheService.selectHaveFile(selectObj,(data) =>{
            this.data.resume=data.list;
            this.data.page=data.page;
            this.$update();
            callback&&callback();
        })
    },


    /**
     *  得到工作的年份月份
     */
    getYearsAndMonth() {
        let date=new Date(),
            data=this.data;
        let yearNow=date.getFullYear(),
            arr=[0,1,2,3,4,5,6,7,8,9];
            data.yearsArray=Array.from([...arr], (x) => yearNow - x);
            data.monthsArray=Array.from([...arr,10,11],(x) => x+1);
            this.$update();
    },

    /**
     * 检验表单 tab1 是否填写完整
     */
    checkTab1() {
        let form1Data=this.data.form1Data,
            errData=this.data.errData;
        let Flag=['id','appName','appendixId','email','gender','mobile','nowCompany','nowPosition','topDegree','workYearsStr'];

        /**
         * 监听表单
         */
        this.$watch('form1Data',(newV)=>{
            for (let key in Flag){
                if (newV[Flag[key]]==undefined || newV[Flag[key]]===''|| errData[Flag[key]]==1)
                    return this.data.form1button='false';
            }
            this.data.form1button='true';
            this.$update();
        },true)


        /**
         * 监听工作年和月份的变化
         */
        this.$watch('work',(newV)=>{
            if(newV.Year !=undefined && newV.Month !=undefined)
            form1Data.workYearsStr=newV.Year+'-0'+newV.Month+'-01';
        },true)
    },

    __uploadFile(e) {
        let file = e.target,
            fileSize = this.__getFileSize(file);


        if (!/\.(png|jpg|jpeg|pdf)$/i.test(file.value)) {
            Notify.warning('文件格式非法');
            return;
        }

        if (fileSize > 20 * 1024) {
            Notify.warning('附件必须小于20Mb');

            return;
        }

        this.$update();
        this.__fileUpHandle();
    },


    /**
     * 获取文件大小
     * @param input 上传文件的input元素
     * @returns {number}
     * @private
     */
    __getFileSize(input) {

        var  fileSize = 0;
        if (!input.files) {
            return;
        }
        if (input.files[0]) {
            fileSize = input.files[0].size;
        }
        return fileSize / 1024;
    },

    /**
     * 主要处理上传的回调
     * @param id
     * @private
     */
    __fileUpHandle(){

        let refs = this.$refs,
            data=this.data;
        let mask = new Mask().$inject(document.body);
        this.__upload(refs['form'],(json)=>{
            mask.close();
            data.form1Data.appendixId=json.data.id;
            data.filename=json.data.name;
            refs['form'].elements.file.value='';
            this.$update();
        })
    },

    /**
     * 上传
     * @param form
     * @param callback
     * @private
     */
    __upload(form, callback) {

        let ifr = document.createElement('iframe'),
            rnd = (Math.random() + '').substr(-8),
            name = 'upload-ifr' + rnd;
            ifr.style.display = 'none';

        ifr.setAttribute('name', name);
        document.body.appendChild(ifr);
        form.setAttribute('target', name);

        ifr.onload = function () {
            var ifrBody = ifr.contentDocument.body,
                html = ifrBody.innerHTML,
                json;

            html = html.replace(/^<.+?>/, '').replace(/<.+?>$/, '');

            json = eval('(' + html + ')');
            callback && callback(json);
            ifr.remove();
        };

        // 延迟零毫秒，再次提交
        setTimeout(()=> {
            form.submit();
        }, 0);
    }
});

Recommend.component('Pager',Pager);
module.exports=Recommend;
},{"../../base/component":2,"../../base/util.js":7,"../../common/mask.js":9,"../../common/modal.js":11,"../../common/notify":13,"../../common/pager.js":15,"../../service.js":42,"./index.html":38,"./selectModel.html":40,"marked":46}],40:[function(require,module,exports){
module.exports="<div class=\"s-m-header\">    <input class=\"h-inp\"  placeholder=\"请输入姓名\" r-model={appName}/>    <span class=\"h-search\" on-click={this.getResume(appName,1)}>搜索</span></div><div class=\"s-m-content\">    <div class=\"f-cb\">        <div class=\"con-head\">            <span class=\"span85 mar\">姓名</span>            <span class=\"span85\">性别</span>            <span class=\"span130\">手机号码</span>            <span class=\"span200\">电子邮箱</span>            <span class=\"span270\">目前公司</span>        </div>        {#list resume as item}            <div class=\"con-li \" on-click={this.resume(item)}>                <span class=\"span85 mar\">{item.appName}</span>                <span class=\"span85\">{#if item.gender==0}男{#else}女{/if}</span>                <span class=\"span130\">{item.mobile}</span>                <span class=\"span200\">{item.email}</span>                <span class=\"span270\">{item.nowCompany}</span>            </div>        {/list}    </div>    <div class=\"blank\"></div>    <pager total={page.totalPage} current={currentPage}></pager></div>"
},{}],41:[function(require,module,exports){
var restate = require('regular-state');
var Component = require('./base/component.js');
var Cookie  = require('js-cookie/src/js.cookie.js');

/* App */
var App = require('./module/app/app.js');

var Login = require('./module/login/index.js');
var ResetPwd = require('./module/login/resetPwd.js');
var ChangePwd = require('./module/login/changePwd.js');

//首页
var Home = require('./module/home/index.js');

//详情页
var Detail= require('./module/detail/index.js');

//管理员页面
var Admin = require('./module/admin/index');

//管理员添加猎头帐号
var hunterDetail = require('./module/hunterDetail/index');

//猎头推荐页
var Recommend=require('./module/recommend');

//关于猎头
var HeadHunter=require('./module/headhunter');

//上传简历
var Upload=require('./module/upload');


/* App */
var router = restate({view: document.getElementById('view'), Component: Component, rebuild: true})
    .on('begin',function(evt){

    })
    .state('app', App , '')
    .on("notfound",function() {
        /*
        * 登陆后的找不到的路径定向到home，
        * 未登录的找不到的路径定向到login
        * */
        if (Cookie.get('passport')){
            router.nav('/home');
        }else {
            router.nav('/login');
        }
    })

/* 登录页面*/
router
    .state('app.login',Login,'login')
    .state('app.resetPwd',ResetPwd,'resetpwd')
    .state('app.changePwd',ChangePwd,'changepwd')

//首页  mount:function ()
router.state('app.home',Home,'home');

//详情页
router.state('app.detail',Detail,'detail');

//我的推荐
router.state('app.recommend',Recommend,'recommend');

//上传简历页
router.state('app.upload',Upload,'upload');

//关于猎头
router.state('app.headhunter',HeadHunter,'headhunter');

//管理员首页
router.state('app.admin',Admin,'admin');

//管理员添加猎头账号页
router.state('app.hunterDetail',hunterDetail,'hunterDetail');


module.exports = router;

},{"./base/component.js":2,"./module/admin/index":19,"./module/app/app.js":21,"./module/detail/index.js":23,"./module/headhunter":25,"./module/home/index.js":27,"./module/hunterDetail/index":29,"./module/login/changePwd.js":31,"./module/login/index.js":33,"./module/login/resetPwd.js":35,"./module/recommend":37,"./module/upload":39,"js-cookie/src/js.cookie.js":45,"regular-state":49}],42:[function(require,module,exports){
var ajax = require('./base/request.js');

exports.getToken = function(callback,errback){

    ajax.request({
        url:'/sys/getToken',
        method:'GET',
        success:callback,
        error:errback,
    })
}

//登录
exports.login = function(params,callback,errback){

    ajax.request({
        url: '/sys/getLogin',
        method: 'POST',
        data: params,
        success: callback,
        error:errback
        //contentType:"application/x-www-form-urlencoded",
    });
}
/**
 * 登出
 * @param callback
 * @param errback
 */
exports.logout = function(callback,errback){

    ajax.request({
        url:'/sys/logout',
        method:'GET',
        success:callback,
        error:errback,
    })
}
/**
 * 获取验证码
 * @param 成功回调函数
 * @param 错误回调函数
 */
exports.getVerificationCode = function(callback,errback){

    ajax.request({
        url:'/sys/getValiationCode',
        method:'GET',
        success:callback,
        error:errback,
    })
}

/**
 * 发送重置密码邮件
 */
exports.sendResetPwdEmail = function(params,callback,errback){

    ajax.request({
        url: '/forgotPwd/mail',
        method: 'POST',
        data: params,
        success: callback,
        error:errback,

    });
}

/**
 * 重置密码
 * @param params
 * @param callback
 * @param errback
 */
exports.resetPwd = function(params,callback,errback){

    ajax.request({
        url:'/sys/forgotPwd/reset/resetPwd',
        method:'POST',
        success:callback,
        error:errback,
        data:params
    })
}

/**
 * 修改密码
 * @param params
 * @param callback
 * @param errback
 */
exports.changePwd = function(params,callback,errback){

    ajax.request({
        url: '/sys/resetPwd',
        method: 'POST',
        data: params,
        success: callback,
        error:errback,

    });
}

//-------------------------首页请求------------

exports.selectOptions=function (callback,errback) {

    ajax.request({
        url: '/index/option',
        method: 'GET',
        success: callback,
        error:errback,
    });

}


/**
 * 查询职位列表
 * @param params   查询需要的参数；
 * @param callback
 * @param errback
 */
exports.positionList=function (params,callback,errback) {

    ajax.request({
        url: '/index/positionList',
        method: 'POST',
        data: params,
        success: callback,
        error:errback,
    });
}



//------------------详情页请求--------------

/**
 * 查询职位详情
 * @param params id
 * @param callback
 * @param errback
 */
exports.getPositionDetail=function (params,callback,errback) {
    ajax.request({
        url: '/position/detail?id='+params,
        method: 'GET',
        success: callback,
        error:errback,
    });
}

//----------------我要推荐页-------------------

/**
 * 点击我要推荐
 * @param params
 * @param callback
 * @param errback
 */
exports.recommendUpload=function (params,callback,errback) {

    ajax.request({
        url: '/recommend/upload',
        method: 'POST',
        data: params,
        success: callback,
        error:errback,
    });
}

exports.getDegree=function (callback,errback) {

    ajax.request({
        url: '/options/byCode',
        method: 'GET',
        success: callback,
        error:errback,
    });
}
/**
 * 选择已有简历
 * @param params
 * @param callback
 * @param errback
 */
exports.selectHaveFile=function (params,callback,errback) {

    ajax.request({
        url: '/resume/pick',
        method: 'POST',
        data: params,
        success: callback,
        error:errback,
    });

}

/**
 * 我的推荐
 * @param params
 * @param callback
 * @param errback
 */
exports.myRecommend=function (params,callback,errback) {

    ajax.request({
        url: '/resume/detail.do',
        method: 'POST',
        data: params,
        success: callback,
        error:errback,
    });
}

},{"./base/request.js":6}],43:[function(require,module,exports){

},{}],44:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* global Symbol */
    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                return false;
            }
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method;
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    return apply.call(
                        target,
                        that,
                        array_concat.call(args, array_slice.call(arguments))
                    );

                }

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            } else {
                return array_splice.apply(this, arguments);
            }
        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
            [1, 2].sort({});
            return true;
        } catch (e) {}
        return false;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString');
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var blacklistedKeys = {
        $window: true,
        $console: true,
        $parent: true,
        $self: true,
        $frame: true,
        $frames: true,
        $frameElement: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $external: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null &&
            typeof value === 'object' &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            !isArray(value) &&
            isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            } else {
                return originalKeys(object);
            }
        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', ' +
                (date < 10 ? '0' + date : date) + ' ' +
                monthName[month] + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
            var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT' +
                (timezoneOffset > 0 ? '-' : '+') +
                (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
                (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += Math.floor(month / 12);
            month = (month % 12 + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
                strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-') +
                'T' + arraySlice(result, 2).join(':') + '.' +
                strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON &&
                new Date(NaN).toJSON() === null &&
                new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
                Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        /* global Date: true */
        /* eslint-disable no-undef */
        var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        /* eslint-disable no-implicit-globals */
        Date = (function (NativeDate) {
        /* eslint-enable no-implicit-globals */
        /* eslint-enable no-undef */
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = Math.floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y ? // isString(Y)
                        // We explicitly pass it through parse:
                        new NativeDate(DateShim.parse(Y)) :
                        // We have to manually make calls depending on argument
                        // length here
                        length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
                        length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
                        length >= 5 ? new NativeDate(Y, M, D, h, m) :
                        length >= 4 ? new NativeDate(Y, M, D, h) :
                        length >= 3 ? new NativeDate(Y, M, D) :
                        length >= 2 ? new NativeDate(Y, M) :
                        length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) :
                                      new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^' +
                '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
                                          // 6-digit extended year
                '(?:-(\\d{2})' + // optional month capture
                '(?:-(\\d{2})' + // optional day capture
                '(?:' + // capture hours:minutes:seconds.milliseconds
                    'T(\\d{2})' + // hours capture
                    ':(\\d{2})' + // minutes capture
                    '(?:' + // optional :seconds.milliseconds
                        ':(\\d{2})' + // seconds capture
                        '(?:(\\.\\d{1,}))?' + // milliseconds capture
                    ')?' +
                '(' + // capture UTC offset component
                    'Z|' + // UTC capture
                    '(?:' + // offset specifier +/-hours:minutes
                        '([-+])' + // sign capture
                        '(\\d{2})' + // hours offset capture
                        ':(\\d{2})' + // minutes offset capture
                    ')' +
                ')?)?)?)?' +
            '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month] +
                    Math.floor((year - 1969 + t) / 4) -
                    Math.floor((year - 1901 + t) / 100) +
                    Math.floor((year - 1601 + t) / 400) +
                    365 * (year - 1970)
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = Math.floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, {
                constructor: DateShim
            }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = Math.floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
                        minute < 60 && second < 60 && millisecond < 1000 &&
                        month > -1 && month < 12 && hourOffset < 24 &&
                        minuteOffset < 60 && // detect invalid offsets
                        day > -1 &&
                        day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            (dayFromMonth(year, month) + day) * 24 +
                            hour +
                            hourOffset * signOffset
                        ) * 60;
                        result = (
                            (result + minute + minuteOffset * signOffset) * 60 +
                            second
                        ) * 1000 + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
        /* global Date: false */
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
      (0.00008).toFixed(3) !== '0.000' ||
      (0.9).toFixed(0) !== '1' ||
      (1.255).toFixed(2) !== '1.25' ||
      (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = Math.floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = Math.floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : Math.floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // Math.pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = NumberPrototype.toPrecision;
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2 ||
        '.'.split(/(.?)(.?)/).length !== 4 ||
        'tesst'.split(/(s)*/)[1] === 't' ||
        'test'.split(/(?:)/, -1).length !== 4 ||
        ''.split(/.?/).length ||
        '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = Math.pow(2, 32) - 1;

            StringPrototype.split = function (separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                            (separator.multiline ? 'm' : '') +
                            (separator.unicode ? 'u' : '') + // in ES6
                            (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            } else {
                var wrappedReplaceValue = function (match) {
                    var length = arguments.length;
                    var originalLastIndex = searchValue.lastIndex;
                    searchValue.lastIndex = 0;
                    var args = searchValue.exec(match) || [];
                    searchValue.lastIndex = originalLastIndex;
                    pushCall(args, arguments[length - 2], arguments[length - 1]);
                    return replaceValue.apply(this, args);
                };
                return str_replace.call(this, searchValue, wrappedReplaceValue);
            }
        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
        '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    // ES-5 15.1.2.2
    /* eslint-disable radix */
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
    /* eslint-enable radix */
        /* global parseInt: true */
        parseInt = (function (origParseInt) {
            var hexRegex = /^[\-+]?0[xX]/;
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        /* global parseFloat: true */
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));

},{}],45:[function(require,module,exports){
/*!
 * JavaScript Cookie v2.1.4
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader = false;
	if (typeof define === 'function' && define.amd) {
		define(factory);
		registeredInModuleLoader = true;
	}
	if (typeof exports === 'object') {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function init (converter) {
		function api (key, value, attributes) {
			var result;
			if (typeof document === 'undefined') {
				return;
			}

			// Write

			if (arguments.length > 1) {
				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					var expires = new Date();
					expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
					attributes.expires = expires;
				}

				// We're using "expires" because "max-age" is not supported by IE
				attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

				try {
					result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				if (!converter.write) {
					value = encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
				} else {
					value = converter.write(value, key);
				}

				key = encodeURIComponent(String(key));
				key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
				key = key.replace(/[\(\)]/g, escape);

				var stringifiedAttributes = '';

				for (var attributeName in attributes) {
					if (!attributes[attributeName]) {
						continue;
					}
					stringifiedAttributes += '; ' + attributeName;
					if (attributes[attributeName] === true) {
						continue;
					}
					stringifiedAttributes += '=' + attributes[attributeName];
				}
				return (document.cookie = key + '=' + value + stringifiedAttributes);
			}

			// Read

			if (!key) {
				result = {};
			}

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling "get()"
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var rdecode = /(%[0-9A-Z]{2})+/g;
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = parts[0].replace(rdecode, decodeURIComponent);
					cookie = converter.read ?
						converter.read(cookie, name) : converter(cookie, name) ||
						cookie.replace(rdecode, decodeURIComponent);

					if (this.json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					if (key === name) {
						result = cookie;
						break;
					}

					if (!key) {
						result[name] = cookie;
					}
				} catch (e) {}
			}

			return result;
		}

		api.set = api;
		api.get = function (key) {
			return api.call(api, key);
		};
		api.getJSON = function () {
			return api.apply({
				json: true
			}, [].slice.call(arguments));
		};
		api.defaults = {};

		api.remove = function (key, attributes) {
			api(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));

},{}],46:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
	// explicitly match decimal, hex, and named HTML entities 
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKig/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLFxuICBsaXN0OiAvXiggKikoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6IC9eICooPzpjb21tZW50ICooPzpcXG58XFxzKiQpfGNsb3NlZCAqKD86XFxuezIsfXxcXHMqJCl8Y2xvc2luZyAqKD86XFxuezIsfXxcXHMqJCkpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBwYXJhZ3JhcGg6IC9eKCg/OlteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKSspXFxuKi8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IHJlcGxhY2UoYmxvY2suaXRlbSwgJ2dtJylcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCk7XG5cbmJsb2NrLmxpc3QgPSByZXBsYWNlKGJsb2NrLmxpc3QpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86Wy0qX10gKil7Myx9KD86XFxcXG4rfCQpKScpXG4gICgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IHJlcGxhY2UoYmxvY2suYmxvY2txdW90ZSlcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG5ibG9jay5fdGFnID0gJyg/ISg/OidcbiAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGInO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVtcXHNcXFNdKj8tLT4vKVxuICAoJ2Nsb3NlZCcsIC88KHRhZylbXFxzXFxTXSs/PFxcL1xcMT4vKVxuICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICgvdGFnL2csIGJsb2NrLl90YWcpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KVsgXFwuXSooXFxTKyk/ICpcXG4oW1xcc1xcU10qPylcXHMqXFwxICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiAvXi8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSArKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvXG59KTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJyg/IScsICcoPyEnXG4gICAgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnXG4gICAgKyBibG9jay5saXN0LnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMycpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBHRk0gKyBUYWJsZXMgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLnRhYmxlcyA9IG1lcmdlKHt9LCBibG9jay5nZm0sIHtcbiAgbnB0YWJsZTogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbn0pO1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cblxuZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2Vucy5saW5rcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2sudGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3AsIGJxKSB7XG4gIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpXG4gICAgLCBuZXh0XG4gICAgLCBsb29zZVxuICAgICwgY2FwXG4gICAgLCBidWxsXG4gICAgLCBiXG4gICAgLCBpdGVtXG4gICAgLCBzcGFjZVxuICAgICwgaVxuICAgICwgbDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBjYXAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICA6IGNhcFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM10gfHwgJydcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdocidcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYmxvY2txdW90ZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICAvLyBQYXNzIGB0b3BgIHRvIGtlZXAgdGhlIGN1cnJlbnRcbiAgICAgIC8vIFwidG9wbGV2ZWxcIiBzdGF0ZS4gVGhpcyBpcyBleGFjdGx5XG4gICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICB0aGlzLnRva2VuKGNhcCwgdG9wLCB0cnVlKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaXN0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSArLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSwgYnEpO1xuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBodG1sXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHRtbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgPyAncGFyYWdyYXBoJ1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgJiYgKGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScpLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKCghYnEgJiYgdG9wKSAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzW2NhcFsxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoLyg/OiAqXFx8ICopP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbXFxcXGAqe31cXFtcXF0oKSMrXFwtLiFfPl0pLyxcbiAgYXV0b2xpbms6IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXlxcYl8oKD86W15fXXxfXykrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxuICBjb2RlOiAvXihgKylcXHMqKFtcXHNcXFNdKj9bXmBdKVxccypcXDEoPyFgKS8sXG4gIGJyOiAvXiB7Mix9XFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wLFxuICB0ZXh0OiAvXltcXHNcXFNdKz8oPz1bXFxcXDwhXFxbXypgXXwgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5faW5zaWRlID0gLyg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dfFxcXSg/PVteXFxbXSpcXF0pKSovO1xuaW5saW5lLl9ocmVmID0gL1xccyo8PyhbXFxzXFxTXSo/KT4/KD86XFxzK1snXCJdKFtcXHNcXFNdKj8pWydcIl0pP1xccyovO1xuXG5pbmxpbmUubGluayA9IHJlcGxhY2UoaW5saW5lLmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgnaHJlZicsIGlubGluZS5faHJlZilcbiAgKCk7XG5cbmlubGluZS5yZWZsaW5rID0gcmVwbGFjZShpbmxpbmUucmVmbGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IG1lcmdlKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopL1xufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogcmVwbGFjZShpbmxpbmUuZXNjYXBlKSgnXSknLCAnfnxdKScpKCksXG4gIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sXG4gIGRlbDogL15+fig/PVxcUykoW1xcc1xcU10qP1xcUyl+fi8sXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLnRleHQpXG4gICAgKCddfCcsICd+XXwnKVxuICAgICgnfCcsICd8aHR0cHM/Oi8vfCcpXG4gICAgKClcbn0pO1xuXG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IG1lcmdlKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiByZXBsYWNlKGlubGluZS5icikoJ3syLH0nLCAnKicpKCksXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLmdmbS50ZXh0KSgnezIsfScsICcqJykoKVxufSk7XG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuXG5mdW5jdGlvbiBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICB0aGlzLnJ1bGVzID0gaW5saW5lLm5vcm1hbDtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBpZiAoIXRoaXMubGlua3MpIHtcbiAgICB0aHJvdyBuZXdcbiAgICAgIEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbGlua1xuICAgICwgdGV4dFxuICAgICwgaHJlZlxuICAgICwgY2FwO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBlc2NhcGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGNhcFsxXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYXV0b2xpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBjYXBbMV0uY2hhckF0KDYpID09PSAnOidcbiAgICAgICAgICA/IHRoaXMubWFuZ2xlKGNhcFsxXS5zdWJzdHJpbmcoNykpXG4gICAgICAgICAgOiB0aGlzLm1hbmdsZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGhpcy5tYW5nbGUoJ21haWx0bzonKSArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHVybCAoZ2ZtKVxuICAgIGlmICghdGhpcy5pbkxpbmsgJiYgKGNhcCA9IHRoaXMucnVsZXMudXJsLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBocmVmID0gdGV4dDtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWwgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5kZWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZGVsKHRoaXMub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGV4dChlc2NhcGUodGhpcy5zbWFydHlwYW50cyhjYXBbMF0pKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb21waWxlIExpbmtcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0TGluayA9IGZ1bmN0aW9uKGNhcCwgbGluaykge1xuICB2YXIgaHJlZiA9IGVzY2FwZShsaW5rLmhyZWYpXG4gICAgLCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuXG4gIHJldHVybiBjYXBbMF0uY2hhckF0KDApICE9PSAnISdcbiAgICA/IHRoaXMucmVuZGVyZXIubGluayhocmVmLCB0aXRsZSwgdGhpcy5vdXRwdXQoY2FwWzFdKSlcbiAgICA6IHRoaXMucmVuZGVyZXIuaW1hZ2UoaHJlZiwgdGl0bGUsIGVzY2FwZShjYXBbMV0pKTtcbn07XG5cbi8qKlxuICogU21hcnR5cGFudHMgVHJhbnNmb3JtYXRpb25zXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLnNtYXJ0eXBhbnRzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zbWFydHlwYW50cykgcmV0dXJuIHRleHQ7XG4gIHJldHVybiB0ZXh0XG4gICAgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tLS9nLCAnXFx1MjAxNCcpXG4gICAgLy8gZW4tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csICdcXHUyMDEzJylcbiAgICAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCAnXFx1MjAxOScpXG4gICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csICckMVxcdTIwMWMnKVxuICAgIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csICdcXHUyMDI2Jyk7XG59O1xuXG4vKipcbiAqIE1hbmdsZSBMaW5rc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5tYW5nbGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLm1hbmdsZSkgcmV0dXJuIHRleHQ7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbCA9IHRleHQubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgY2g7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJ1xcbjwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICsgJ1wiPidcbiAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICArICdcXG48L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHRleHQsIGxldmVsLCByYXcpIHtcbiAgcmV0dXJuICc8aCdcbiAgICArIGxldmVsXG4gICAgKyAnIGlkPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeFxuICAgICsgcmF3LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgKyAnXCI+J1xuICAgICsgdGV4dFxuICAgICsgJzwvaCdcbiAgICArIGxldmVsXG4gICAgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQpIHtcbiAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gIHJldHVybiAnPCcgKyB0eXBlICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICArICc8dGhlYWQ+XFxuJ1xuICAgICsgaGVhZGVyXG4gICAgKyAnPC90aGVhZD5cXG4nXG4gICAgKyAnPHRib2R5PlxcbidcbiAgICArIGJvZHlcbiAgICArICc8L3Rib2R5PlxcbidcbiAgICArICc8L3RhYmxlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICB2YXIgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICA/ICc8JyArIHR5cGUgKyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgZmxhZ3MuYWxpZ24gKyAnXCI+J1xuICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cbi8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcblJlbmRlcmVyLnByb3RvdHlwZS5zdHJvbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ol0vZywgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0O1xufTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgcmVuZGVyZXIpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zLCB0aGlzLnJlbmRlcmVyKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHRoaXMudG9rZW4udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb2RlKHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy50b2tlbi5sYW5nLFxuICAgICAgICB0aGlzLnRva2VuLmVzY2FwZWQpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJ1xuICAgICAgICAsIGJvZHkgPSAnJ1xuICAgICAgICAsIGlcbiAgICAgICAgLCByb3dcbiAgICAgICAgLCBjZWxsXG4gICAgICAgICwgZmxhZ3NcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9O1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJ1xuICAgICAgICAsIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyB0aGlzLnBhcnNlVGV4dCgpXG4gICAgICAgICAgOiB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHZhciBodG1sID0gIXRoaXMudG9rZW4ucHJlICYmICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgPyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICA6IHRoaXMudG9rZW4udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbCk7XG4gICAgfVxuICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZVRleHQoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcblx0Ly8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzIFxuICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mKCMoPzpcXGQrKXwoPzojeFswLTlBLUZhLWZdKyl8KD86XFx3KykpOz8vZywgZnVuY3Rpb24oXywgbikge1xuICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG4gICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmKG5hbWUsIHZhbCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLyhefFteXFxbXSlcXF4vZywgJyQxJyk7XG4gICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC5leGVjID0gbm9vcDtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gIHZhciBpID0gMVxuICAgICwgdGFyZ2V0XG4gICAgLCBrZXk7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayB8fCB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodFxuICAgICAgLCB0b2tlbnNcbiAgICAgICwgcGVuZGluZ1xuICAgICAgLCBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkLic7XG4gICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJlZDo8L3A+PHByZT4nXG4gICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICArICc8L3ByZT4nO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG5cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG1lcmdlKG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5cbm1hcmtlZC5kZWZhdWx0cyA9IHtcbiAgZ2ZtOiB0cnVlLFxuICB0YWJsZXM6IHRydWUsXG4gIGJyZWFrczogZmFsc2UsXG4gIHBlZGFudGljOiBmYWxzZSxcbiAgc2FuaXRpemU6IGZhbHNlLFxuICBzYW5pdGl6ZXI6IG51bGwsXG4gIG1hbmdsZTogdHJ1ZSxcbiAgc21hcnRMaXN0czogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG4gIGhpZ2hsaWdodDogbnVsbCxcbiAgbGFuZ1ByZWZpeDogJ2xhbmctJyxcbiAgc21hcnR5cGFudHM6IGZhbHNlLFxuICBoZWFkZXJQcmVmaXg6ICcnLFxuICByZW5kZXJlcjogbmV3IFJlbmRlcmVyLFxuICB4aHRtbDogZmFsc2Vcbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5cbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xuXG5tYXJrZWQuTGV4ZXIgPSBMZXhlcjtcbm1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcblxubWFya2VkLklubGluZUxleGVyID0gSW5saW5lTGV4ZXI7XG5tYXJrZWQuaW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlci5vdXRwdXQ7XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG1hcmtlZDtcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLm1hcmtlZCA9IG1hcmtlZDtcbn1cblxufSkuY2FsbChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcbn0oKSk7XG4iXX0=
},{}],47:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iXX0=
},{"_process":48}],48:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],49:[function(require,module,exports){

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['stateman'], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require('stateman'));
    } else {
        // Browser globals (root is window)
        root.restate = factory( root.StateMan);
    }
}(this, function (StateMan) {

  var _ = StateMan.util;


  // get all state match the pattern
  function getMatchStates(stateman, pattern){
    var current = stateman;
    var allStates = [];

    var currentStates = current._states;

    for(var i in currentStates){
      var state = currentStates[i];
      if(pattern.test(state.stateName)) allStates.push( state );
      if(state._states) allStates = allStates.concat(getMatchStates( state, pattern))
    }
    return allStates
  }

  var restate = function(option){
    option = option || {};
    var stateman = option.stateman || new StateMan(option);
    var preState = stateman.state;
    var BaseComponent = option.Component;
    var globalView = option.view || document.body;

    var filters = {
      encode: function(value, param){
        return stateman.history.prefix + (stateman.encode(value, param || {}) || "");
      }
    }

    stateman.state = function(name, Component, config){
      if(typeof config === "string"){
        config = {url: config};
      }

      config = config || {};

      // Use global option.rebuild if config.rebuild is not defined.
      if(config.rebuild === undefined) config.rebuild = option.rebuild;

      if(!Component) return preState.call(stateman, name);

      if(BaseComponent){
        // 1. regular template or parsed ast
        if(typeof Component === "string" || Array.isArray( Component )){
          Component = BaseComponent.extend({
            template: Component
          })
        }
        // 2. it an Object, but need regularify
        if(typeof Component === "object" && Component.regularify ){
          Component = BaseComponent.extend( Component );
        }
      }

      // 3. duck check is a Regular Component
      if( Component.extend && Component.__after__ ){

        if(!Component.filter("encode")){
          Component.filter(filters);
        }
        var state = {
          component: null,

          // @TODO:
          canUpdate: function(option){

            var canUpdate = this.component && this.component.canUpdate;

            if( canUpdate ) return this.component.canUpdate(option);
          },


          canLeave: function(option){


            var canLeave = this.component && this.component.canLeave;

            if( canLeave ) return this.component.canLeave(option);

          },

          canEnter: function( option ){
            var data = { $param: option.param },
              component = this.component,
              // if component is not exist or required to be rebuilded when entering.
              noComponent = !component,
              view;

            if(noComponent){

              component = this.component = new Component({
                data: data,

                $state: stateman,

                $stateName: name,

                /**
                 * notify other module
                 * @param  {String} stateName module's stateName
                 *         you can pass wildcard(*) for 
                 *       
                 * @param  {Whatever} param   event param
                 * @return {Component} this 
                 */
                $notify: function(stateName, type, param){

                  var pattern, eventObj, state;

                  if(!stateName) return;

                  if(~stateName.indexOf('*')){

                    pattern = new RegExp(
                      stateName
                        .replace('.', '\\.')
                        .replace(/\*\*|\*/, function(cap){
                          if(cap === '**') return '.*';
                          else return '[^.]*';
                        })
                    );

                    getMatchStates.forEach(function(state){
                      if(state.component) state.component.$emit(type, {
                        param: param,
                        from: name,
                        to: state.stateName
                      })
                    })

                  }else{
                    state = stateman.state(stateName);
                    if(!state || !state.component) return 
                    state.component.$emit(type, {
                      param: param,
                      from: name,
                      to: stateName
                    })
                  }
                  
                }
              });
            }
            var canEnter = this.component && this.component.canEnter;

            if( canEnter ) return this.component.canEnter(option);
          },

          enter: function( option ){



            var data = { $param: option.param };
            var component = this.component;
            var parent = this.parent, view;

            if(!component) return;

            _.extend(component.data, data, true);

            if(parent.component){
              view = parent.component.$refs.view;
              if(!view) throw this.parent.name + " should have a element with [ref=view]";
            }else{
              view = globalView;
            }
            
            component.$inject(view);
            var result = component.enter && component.enter(option);

            component.$update(function(){
              component.$mute(false);
            })

            return result;
          },
          leave: function( option){
            var component = this.component;
            if(!component) return;

            component.leave && component.leave(option);
            if( config.rebuild){
              this.component = null;
              return component.destroy();
            } 
            component.$inject(false);
            component.$mute(true);
          },
          update: function(option){
            var component = this.component;
            if(!component) return;
            component.update && component.update(option);
            component.$update({
              $param: option.param
            })
          }
        }

        _.extend(state, config || {});

        preState.call(stateman, name, state);

      }else{
        preState.call(stateman, name, Component);
      }
      return this;
    }
    return stateman;
  }

  restate.StateMan = StateMan;

  return restate;

}));

},{"stateman":82}],50:[function(require,module,exports){

module.exports = {
  'BEGIN': '{',
  'END': '}',
  'PRECOMPILE': false
}
},{}],51:[function(require,module,exports){
module.exports = {
  'COMPONENT_TYPE': 1,
  'ELEMENT_TYPE': 2,
  'ERROR': {
    'UNMATCHED_AST': 101
  },
  "MSG": {
    101: "Unmatched ast and mountNode, report issue at https://github.com/regularjs/regular/issues"
  },
  'NAMESPACE': {
    html: "http://www.w3.org/1999/xhtml",
    svg: "http://www.w3.org/2000/svg"
  },
  'OPTIONS': {
    'STABLE_INIT': { stable: !0, init: !0 },
    'FORCE_INIT': { force: !0, init: !0 },
    'STABLE': {stable: !0},
    'INIT': { init: !0 },
    'SYNC': { sync: !0 },
    'FORCE': { force: !0 }
  }
}

},{}],52:[function(require,module,exports){
var // packages
  _ = require("../util"),
 animate = require("../helper/animate"),
 dom = require("../dom"),
 Regular = require("../render/client");


var // variables
  rClassName = /^[-\w]+(\s[-\w]+)*$/,
  rCommaSep = /[\r\n\f ]*,[\r\n\f ]*(?=\w+\:)/, //  dont split comma in  Expression
  rStyles = /^\{.*\}$/, //  for Simpilfy
  rSpace = /\s+/, //  for Simpilfy
  WHEN_COMMAND = "when",
  EVENT_COMMAND = "on",
  THEN_COMMAND = "then";

/**
 * Animation Plugin
 * @param {Component} Component 
 */


function createSeed(type){

  var steps = [], current = 0, callback = _.noop;
  var key;

  var out = {
    type: type,
    start: function(cb){
      key = _.uid();
      if(typeof cb === "function") callback = cb;
      if(current> 0 ){
        current = 0 ;
      }else{
        out.step();
      }
      return out.compelete;
    },
    compelete: function(){
      key = null;
      callback && callback();
      callback = _.noop;
      current = 0;
    },
    step: function(){
      if(steps[current]) steps[current ]( out.done.bind(out, key) );
    },
    done: function(pkey){
      if(pkey !== key) return; // means the loop is down
      if( current < steps.length - 1 ) {
        current++;
        out.step();
      }else{
        out.compelete();
      }
    },
    push: function(step){
      steps.push(step)
    }
  }

  return out;
}

Regular._addProtoInheritCache("animation")


// builtin animation
Regular.animation({
  "wait": function( step ){
    var timeout = parseInt( step.param ) || 0
    return function(done){
      // _.log("delay " + timeout)
      setTimeout( done, timeout );
    }
  },
  "class": function(step){
    var tmp = step.param.split(","),
      className = tmp[0] || "",
      mode = parseInt(tmp[1]) || 1;

    return function(done){
      // _.log(className)
      animate.startClassAnimate( step.element, className , done, mode );
    }
  },
  "call": function(step){
    var fn = this.$expression(step.param).get, self = this;
    return function(done){
      // _.log(step.param, 'call')
      fn(self);
      self.$update();
      done()
    }
  },
  "emit": function(step){
    var param = step.param;
    var tmp = param.split(","),
      evt = tmp[0] || "",
      args = tmp[1]? this.$expression(tmp[1]).get: null;

    if(!evt) throw Error("you shoud specified a eventname in emit command");

    var self = this;
    return function(done){
      self.$emit(evt, args? args(self) : undefined);
      done();
    }
  },
  // style: left {10}px,
  style: function(step){
    var styles = {}, 
      param = step.param,
      pairs = param.split(","), valid;
    pairs.forEach(function(pair){
      pair = pair.trim();
      if(pair){
        var tmp = pair.split( rSpace ),
          name = tmp.shift(),
          value = tmp.join(" ");

        if( !name || !value ) throw Error("invalid style in command: style");
        styles[name] = value;
        valid = true;
      }
    })

    return function(done){
      if(valid){
        animate.startStyleAnimate(step.element, styles, done);
      }else{
        done();
      }
    }
  }
})



// hancdle the r-animation directive
// el : the element to process
// value: the directive value
function processAnimate( element, value ){
  var Component = this.constructor;

  if(_.isExpr(value)){
    value = value.get(this);
  }

  value = value.trim();

  var composites = value.split(";"), 
    composite, context = this, seeds = [], seed, destroies = [], destroy,
    command, param , current = 0, tmp, animator, self = this;

  function reset( type ){
    seed && seeds.push( seed )
    seed = createSeed( type );
  }

  function whenCallback(start, value){
    if( !!value ) start()
  }

  function animationDestroy(element){
    return function(){
      element.onenter = null;
      element.onleave = null;
    } 
  }

  for( var i = 0, len = composites.length; i < len; i++ ){

    composite = composites[i];
    tmp = composite.split(":");
    command = tmp[0] && tmp[0].trim();
    param = tmp[1] && tmp[1].trim();

    if( !command ) continue;

    if( command === WHEN_COMMAND ){
      reset("when");
      this.$watch(param, whenCallback.bind( this, seed.start ) );
      continue;
    }

    if( command === EVENT_COMMAND){
      reset(param);
      if( param === "leave" ){
        element.onleave = seed.start;
        destroies.push( animationDestroy(element) );
      }else if( param === "enter" ){
        element.onenter = seed.start;
        destroies.push( animationDestroy(element) );
      }else{
        if( ("on" + param) in element){ // if dom have the event , we use dom event
          destroies.push(this._handleEvent( element, param, seed.start ));
        }else{ // otherwise, we use component event
          this.$on(param, seed.start);
          destroies.push(this.$off.bind(this, param, seed.start));
        }
      }
      continue;
    }

    var animator =  Component.animation(command) 
    if( animator && seed ){
      seed.push(
        animator.call(this,{
          element: element,
          done: seed.done,
          param: param 
        })
      )
    }else{
      throw Error( animator? "you should start with `on` or `event` in animation" : ("undefined animator 【" + command +"】" ));
    }
  }

  if(destroies.length){
    return function(){
      destroies.forEach(function(destroy){
        destroy();
      })
    }
  }
}


Regular.directive( "r-animation", processAnimate)
Regular.directive( "r-anim", processAnimate)


},{"../dom":56,"../helper/animate":59,"../render/client":75,"../util":77}],53:[function(require,module,exports){
// Regular
var _ = require("../util");
var dom = require("../dom");
var animate = require("../helper/animate");
var Regular = require("../render/client");
var consts = require("../const");
var namespaces = consts.NAMESPACE;
var OPTIONS = consts.OPTIONS
var STABLE = OPTIONS.STABLE;
var DEEP_STABLE = {deep: true, stable: true};




require("./event.js");
require("./form.js");


module.exports = {
// **warn**: class inteplation will override this directive 
  'r-class': function(elem, value){

    if(typeof value=== 'string'){
      value = _.fixObjStr(value)
    }
    var isNotHtml = elem.namespaceURI && elem.namespaceURI !== namespaces.html ;
    this.$watch(value, function(nvalue){
      var className = isNotHtml? elem.getAttribute('class'): elem.className;
      className = ' '+ (className||'').replace(/\s+/g, ' ') +' ';
      for(var i in nvalue) if(nvalue.hasOwnProperty(i)){
        className = className.replace(' ' + i + ' ',' ');
        if(nvalue[i] === true){
          className += i+' ';
        }
      }
      className = className.trim();
      if(isNotHtml){
        dom.attr(elem, 'class', className)
      }else{
        elem.className = className
      }
    }, DEEP_STABLE);
  },
  // **warn**: style inteplation will override this directive 
  'r-style': function(elem, value){
    if(typeof value=== 'string'){
      value = _.fixObjStr(value)
    }
    this.$watch(value, function(nvalue){
      for(var i in nvalue) if(nvalue.hasOwnProperty(i)){
        dom.css(elem, i, nvalue[i]);
      }
    },DEEP_STABLE);
  },
  // when expression is evaluate to true, the elem will add display:none
  // Example: <div r-hide={{items.length > 0}}></div>
  'r-hide': function(elem, value){
    var preBool = null, compelete;
    if( _.isExpr(value) || typeof value === "string"){
      this.$watch(value, function(nvalue){
        var bool = !!nvalue;
        if(bool === preBool) return; 
        preBool = bool;
        if(bool){
          if(elem.onleave){
            compelete = elem.onleave(function(){
              elem.style.display = "none"
              compelete = null;
            })
          }else{
            elem.style.display = "none"
          }
          
        }else{
          if(compelete) compelete();
          elem.style.display = "";
          if(elem.onenter){
            elem.onenter();
          }
        }
      }, STABLE);
    }else if(!!value){
      elem.style.display = "none";
    }
  },
  'r-html': {
    ssr: function(value, tag){
      tag.body = value;
      return "";
    },
    link: function(elem, value){
      this.$watch(value, function(nvalue){
        nvalue = nvalue || "";
        dom.html(elem, nvalue)
      }, {force: true, stable: true});
    }
  },
  'ref': {
    accept: consts.COMPONENT_TYPE + consts.ELEMENT_TYPE,
    link: function( elem, value ){
      var refs = this.$refs || (this.$refs = {});
      var cval;
      if(_.isExpr(value)){
        this.$watch(value, function(nval, oval){
          cval = nval;
          if(refs[oval] === elem) refs[oval] = null;
          if(cval) refs[cval] = elem;
        }, STABLE)
      }else{
        refs[cval = value] = elem;
      }
      return function(){
        refs[cval] = null;
      }
    }
  }
}

Regular.directive(module.exports);











},{"../const":51,"../dom":56,"../helper/animate":59,"../render/client":75,"../util":77,"./event.js":54,"./form.js":55}],54:[function(require,module,exports){
/**
 * event directive  bundle
 *
 */
var _ = require("../util");
var dom = require("../dom");
var Regular = require("../render/client");

Regular._addProtoInheritCache("event");

Regular.directive( /^on-\w+$/, function( elem, value, name , attrs) {
  if ( !name || !value ) return;
  var type = name.split("-")[1];
  return this._handleEvent( elem, type, value, attrs );
});
// TODO.
/**
- $('dx').delegate()
*/
Regular.directive( /^(delegate|de)-\w+$/, function( elem, value, name ) {
  var root = this.$root;
  var _delegates = root._delegates || ( root._delegates = {} );
  if ( !name || !value ) return;
  var type = name.split("-")[1];
  var fire = _.handleEvent.call(this, value, type);

  function delegateEvent(ev){
    matchParent(ev, _delegates[type], root.parentNode);
  }

  if( !_delegates[type] ){
    _delegates[type] = [];

    if(root.parentNode){
      dom.on(root.parentNode, type, delegateEvent);
    }else{
      root.$on( "$inject", function( node, position, preParent ){
        var newParent = this.parentNode;
        if( preParent ){
          dom.off(preParent, type, delegateEvent);
        }
        if(newParent) dom.on(this.parentNode, type, delegateEvent);
      })
    }
    root.$on("$destroy", function(){
      if(root.parentNode) dom.off(root.parentNode, type, delegateEvent)
      _delegates[type] = null;
    })
  }
  var delegate = {
    element: elem,
    fire: fire
  }
  _delegates[type].push( delegate );

  return function(){
    var delegates = _delegates[type];
    if(!delegates || !delegates.length) return;
    for( var i = 0, len = delegates.length; i < len; i++ ){
      if( delegates[i] === delegate ) delegates.splice(i, 1);
    }
  }

});


function matchParent(ev , delegates, stop){
  if(!stop) return;
  var target = ev.target, pair;
  while(target && target !== stop){
    for( var i = 0, len = delegates.length; i < len; i++ ){
      pair = delegates[i];
      if(pair && pair.element === target){
        pair.fire(ev)
      }
    }
    target = target.parentNode;
  }
}
},{"../dom":56,"../render/client":75,"../util":77}],55:[function(require,module,exports){
// Regular
var _ = require("../util");
var dom = require("../dom");
var OPTIONS = require('../const').OPTIONS
var STABLE = OPTIONS.STABLE;
var hasInput;
var Regular = require("../render/client");

var modelHandlers = {
  "text": initText,
  "select": initSelect,
  "checkbox": initCheckBox,
  "radio": initRadio
}


// @TODO


// autoUpdate directive for select element
// to fix r-model issue , when handle dynamic options


/**
 * <select r-model={name}> 
 *   <r-option value={value} ></r-option>
 * </select>
 */


// two-way binding with r-model
// works on input, textarea, checkbox, radio, select


Regular.directive("r-model", {
  param: ['throttle', 'lazy'],
  link: function( elem, value, name, extra ){
    var tag = elem.tagName.toLowerCase();
    var sign = tag;
    if(sign === "input") sign = elem.type || "text";
    else if(sign === "textarea") sign = "text";
    if(typeof value === "string") value = this.$expression(value);

    if( modelHandlers[sign] ) return modelHandlers[sign].call(this, elem, value, extra);
    else if(tag === "input"){
      return modelHandlers.text.call(this, elem, value, extra);
    }
  }
  //@TODO
  // ssr: function(name, value){
  //   return value? "value=" + value: ""
  // }
});





// binding <select>

function initSelect( elem, parsed, extra){
  var self = this;
  var wc = this.$watch(parsed, function(newValue){
    var children = elem.getElementsByTagName('option');
    for(var i =0, len = children.length ; i < len; i++){
      if(children[i].value == newValue){
        elem.selectedIndex = i;
        break;
      }
    }
  }, STABLE);

  function handler(){
    parsed.set(self, this.value);
    wc.last = this.value;
    self.$update();
  }

  dom.on( elem, "change", handler );
  
  if(parsed.get(self) === undefined && elem.value){
    parsed.set(self, elem.value);
  }

  return function destroy(){
    dom.off(elem, "change", handler);
  }
}

// input,textarea binding
function initText(elem, parsed, extra){
  var param = extra.param;
  var throttle, lazy = param.lazy

  if('throttle' in param){
    // <input throttle r-model>
    if(param[throttle] === true){
      throttle = 400;
    }else{
      throttle = parseInt(param.throttle , 10)
    }
  }

  var self = this;
  var wc = this.$watch(parsed, function(newValue){
    if(elem.value !== newValue) elem.value = newValue == null? "": "" + newValue;
  }, STABLE);

  // @TODO to fixed event
  var handler = function (ev){
    var that = this;
    if(ev.type==='cut' || ev.type==='paste'){
      _.nextTick(function(){
        var value = that.value
        parsed.set(self, value);
        wc.last = value;
        self.$update();
      })
    }else{
        var value = that.value
        parsed.set(self, value);
        wc.last = value;
        self.$update();
    }
  };

  if(throttle && !lazy){
    var preHandle = handler, tid;
    handler = _.throttle(handler, throttle);
  }

  if(hasInput === undefined){
    hasInput = dom.msie !== 9 && "oninput" in document.createElement('input')
  }

  if(lazy){
    dom.on(elem, 'change', handler)
  }else{
    if( hasInput){
      elem.addEventListener("input", handler );
    }else{
      dom.on(elem, "paste keyup cut change", handler)
    }
  }
  if(parsed.get(self) === undefined && elem.value){
     parsed.set(self, elem.value);
  }
  return function (){
    if(lazy) return dom.off(elem, "change", handler);
    if( hasInput ){
      elem.removeEventListener("input", handler );
    }else{
      dom.off(elem, "paste keyup cut change", handler)
    }
  }
}


// input:checkbox  binding

function initCheckBox(elem, parsed){
  var self = this;
  var watcher = this.$watch(parsed, function(newValue){
    dom.attr(elem, 'checked', !!newValue);
  }, STABLE);

  var handler = function handler(){
    var value = this.checked;
    parsed.set(self, value);
    watcher.last = value;
    self.$update();
  }
  if(parsed.set) dom.on(elem, "change", handler)

  if(parsed.get(self) === undefined){
    parsed.set(self, !!elem.checked);
  }

  return function destroy(){
    if(parsed.set) dom.off(elem, "change", handler)
  }
}


// input:radio binding

function initRadio(elem, parsed){
  var self = this;
  var wc = this.$watch(parsed, function( newValue ){
    if(newValue == elem.value) elem.checked = true;
    else elem.checked = false;
  }, STABLE);


  var handler = function handler(){
    var value = this.value;
    parsed.set(self, value);
    self.$update();
  }
  if(parsed.set) dom.on(elem, "change", handler)
  // beacuse only after compile(init), the dom structrue is exsit. 
  if(parsed.get(self) === undefined){
    if(elem.checked) {
      parsed.set(self, elem.value);
    }
  }

  return function destroy(){
    if(parsed.set) dom.off(elem, "change", handler)
  }
}




},{"../const":51,"../dom":56,"../render/client":75,"../util":77}],56:[function(require,module,exports){
/*jshint -W082 */ 

// thanks for angular && mootools for some concise&cross-platform  implemention
// =====================================

// The MIT License
// Copyright (c) 2010-2014 Google, Inc. http://angularjs.org

// ---
// license: MIT-style license. http://mootools.net


if(typeof window !== 'undefined'){
  
var dom = module.exports;
var env = require("./env");
var _ = require("./util");
var consts = require('./const');
var tNode = document.createElement('div')
var addEvent, removeEvent;
var noop = function(){}

var namespaces = consts.NAMESPACE;

dom.body = document.body;
dom.doc = document;
dom.tNode = tNode;


// camelCase
var camelCase = function (str){
  return ("" + str).replace(/-\D/g, function(match){
    return match.charAt(1).toUpperCase();
  });
}



if(tNode.addEventListener){
  addEvent = function(node, type, fn) {
    node.addEventListener(type, fn, false);
  }
  removeEvent = function(node, type, fn) {
    node.removeEventListener(type, fn, false) 
  }
}else{
  addEvent = function(node, type, fn) {
    node.attachEvent('on' + type, fn);
  }
  removeEvent = function(node, type, fn) {
    node.detachEvent('on' + type, fn); 
  }
}


dom.msie = parseInt((/msie (\d+)/.exec(navigator.userAgent.toLowerCase()) || [])[1]);
if (isNaN(dom.msie)) {
  dom.msie = parseInt((/trident\/.*; rv:(\d+)/.exec(navigator.userAgent.toLowerCase()) || [])[1]);
}

dom.find = function(sl){
  if(document.querySelector) {
    try{
      return document.querySelector(sl);
    }catch(e){

    }
  }
  if(sl.indexOf('#')!==-1) return document.getElementById( sl.slice(1) );
}


dom.inject = function(node, refer, position){

  position = position || 'bottom';
  if(!node) return ;
  if(Array.isArray(node)){
    var tmp = node;
    node = dom.fragment();
    for(var i = 0,len = tmp.length; i < len ;i++){
      node.appendChild(tmp[i])
    }
  }

  var firstChild, next;
  switch(position){
    case 'bottom':
      refer.appendChild( node );
      break;
    case 'top':
      if( firstChild = refer.firstChild ){
        refer.insertBefore( node, refer.firstChild );
      }else{
        refer.appendChild( node );
      }
      break;
    case 'after':
      if( next = refer.nextSibling ){
        next.parentNode.insertBefore( node, next );
      }else{
        refer.parentNode.appendChild( node );
      }
      break;
    case 'before':
      refer.parentNode.insertBefore( node, refer );
  }
}


dom.id = function(id){
  return document.getElementById(id);
}

// createElement 
dom.create = function(type, ns){
  if(ns === 'svg'){
    if(!env.svg) throw Error('the env need svg support')
    ns = namespaces.svg;
  }
  return !ns? document.createElement(type): document.createElementNS(ns, type);
}

// documentFragment
dom.fragment = function(){
  return document.createDocumentFragment();
}




var specialAttr = {
  'class': function(node, value){
     ('className' in node && (!node.namespaceURI || node.namespaceURI === namespaces.html  )) ? 
      node.className = (value || '') : node.setAttribute('class', value);
  },
  'for': function(node, value){
    ('htmlFor' in node) ? node.htmlFor = value : node.setAttribute('for', value);
  },
  'style': function(node, value){
    (node.style) ? node.style.cssText = value : node.setAttribute('style', value);
  },
  'value': function(node, value){
    node.value = (value != null) ? value : '';
  }
}


// attribute Setter & Getter
dom.attr = function(node, name, value){
  if (_.isBooleanAttr(name)) {
    if (typeof value !== 'undefined') {
      if (!!value) {
        node[name] = true;
        node.setAttribute(name, name);
        // lt ie7 . the javascript checked setting is in valid
        //http://bytes.com/topic/javascript/insights/799167-browser-quirk-dynamically-appended-checked-checkbox-does-not-appear-checked-ie
        if(dom.msie && dom.msie <=7 && name === 'checked' ) node.defaultChecked = true
      } else {
        node[name] = false;
        node.removeAttribute(name);
      }
    } else {
      return (node[name] ||
               (node.attributes.getNamedItem(name)|| noop).specified) ? name : undefined;
    }
  } else if (typeof (value) !== 'undefined') {
    // if in specialAttr;
    if(specialAttr[name]) specialAttr[name](node, value);
    else if(value === null) node.removeAttribute(name)
    else node.setAttribute(name, value);
  } else if (node.getAttribute) {
    // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
    // some elements (e.g. Document) don't have get attribute, so return undefined
    var ret = node.getAttribute(name, 2);
    // normalize non-existing attributes to undefined (as jQuery)
    return ret === null ? undefined : ret;
  }
}


dom.on = function(node, type, handler){
  var types = type.split(' ');
  handler.real = function(ev){
    var $event = new Event(ev);
    $event.origin = node;
    handler.call(node, $event);
  }
  types.forEach(function(type){
    type = fixEventName(node, type);
    addEvent(node, type, handler.real);
  });
  return dom;
}
dom.off = function(node, type, handler){
  var types = type.split(' ');
  handler = handler.real || handler;
  types.forEach(function(type){
    type = fixEventName(node, type);
    removeEvent(node, type, handler);
  })
}


dom.text = (function (){
  var map = {};
  if (dom.msie && dom.msie < 9) {
    map[1] = 'innerText';    
    map[3] = 'nodeValue';    
  } else {
    map[1] = map[3] = 'textContent';
  }
  
  return function (node, value) {
    var textProp = map[node.nodeType];
    if (value == null) {
      return textProp ? node[textProp] : '';
    }
    node[textProp] = value;
  }
})();


dom.html = function( node, html ){
  if(typeof html === "undefined"){
    return node.innerHTML;
  }else{
    node.innerHTML = html;
  }
}

dom.replace = function(node, replaced){
  if(replaced.parentNode) replaced.parentNode.replaceChild(node, replaced);
}

dom.remove = function(node){
  if(node.parentNode) node.parentNode.removeChild(node);
}

// css Settle & Getter from angular
// =================================
// it isnt computed style 
dom.css = function(node, name, value){
  if( typeof (name) === "object" && name ){
    for(var i in name){
      if( name.hasOwnProperty(i) ){
        dom.css( node, i, name[i] );
      }
    }
    return;
  }
  if ( typeof value !== "undefined" ) {

    name = camelCase(name);
    if(name) node.style[name] = value;

  } else {

    var val;
    if (dom.msie <= 8) {
      // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
      val = node.currentStyle && node.currentStyle[name];
      if (val === '') val = 'auto';
    }
    val = val || node.style[name];
    if (dom.msie <= 8) {
      val = val === '' ? undefined : val;
    }
    return  val;
  }
}

dom.addClass = function(node, className){
  var current = node.className || "";
  if ((" " + current + " ").indexOf(" " + className + " ") === -1) {
    node.className = current? ( current + " " + className ) : className;
  }
}

dom.delClass = function(node, className){
  var current = node.className || "";
  node.className = (" " + current + " ").replace(" " + className + " ", " ").trim();
}

dom.hasClass = function(node, className){
  var current = node.className || "";
  return (" " + current + " ").indexOf(" " + className + " ") !== -1;
}



// simple Event wrap

//http://stackoverflow.com/questions/11068196/ie8-ie7-onchange-event-is-emited-only-after-repeated-selection
function fixEventName(elem, name){
  return (name === 'change'  &&  dom.msie < 9 && 
      (elem && elem.tagName && elem.tagName.toLowerCase()==='input' && 
        (elem.type === 'checkbox' || elem.type === 'radio')
      )
    )? 'click': name;
}

var rMouseEvent = /^(?:click|dblclick|contextmenu|DOMMouseScroll|mouse(?:\w+))$/
var doc = document;
doc = (!doc.compatMode || doc.compatMode === 'CSS1Compat') ? doc.documentElement : doc.body;
function Event(ev){
  ev = ev || window.event;
  if(ev._fixed) return ev;
  this.event = ev;
  this.target = ev.target || ev.srcElement;

  var type = this.type = ev.type;
  var button = this.button = ev.button;

  // if is mouse event patch pageX
  if(rMouseEvent.test(type)){ //fix pageX
    this.pageX = (ev.pageX != null) ? ev.pageX : ev.clientX + doc.scrollLeft;
    this.pageY = (ev.pageX != null) ? ev.pageY : ev.clientY + doc.scrollTop;
    if (type === 'mouseover' || type === 'mouseout'){// fix relatedTarget
      var related = ev.relatedTarget || ev[(type === 'mouseover' ? 'from' : 'to') + 'Element'];
      while (related && related.nodeType === 3) related = related.parentNode;
      this.relatedTarget = related;
    }
  }
  // if is mousescroll
  if (type === 'DOMMouseScroll' || type === 'mousewheel'){
    // ff ev.detail: 3    other ev.wheelDelta: -120
    this.wheelDelta = (ev.wheelDelta) ? ev.wheelDelta / 120 : -(ev.detail || 0) / 3;
  }
  
  // fix which
  this.which = ev.which || ev.keyCode;
  if( !this.which && button !== undefined){
    // http://api.jquery.com/event.which/ use which
    this.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
  }
  this._fixed = true;
}

_.extend(Event.prototype, {
  stop: function(){
    this.preventDefault().stopPropagation();
  },
  preventDefault: function(){
    if (this.event.preventDefault) this.event.preventDefault();
    else this.event.returnValue = false;
    return this;
  },
  stopPropagation: function(){
    if (this.event.stopPropagation) this.event.stopPropagation();
    else this.event.cancelBubble = true;
    return this;
  },
  stopImmediatePropagation: function(){
    if(this.event.stopImmediatePropagation) this.event.stopImmediatePropagation();
  }
})


dom.nextFrame = (function(){
    var request = window.requestAnimationFrame ||
                  window.webkitRequestAnimationFrame ||
                  window.mozRequestAnimationFrame|| 
                  function(callback){
                    return setTimeout(callback, 16)
                  }

    var cancel = window.cancelAnimationFrame ||
                 window.webkitCancelAnimationFrame ||
                 window.mozCancelAnimationFrame ||
                 window.webkitCancelRequestAnimationFrame ||
                 function(tid){
                    clearTimeout(tid)
                 }
  
  return function(callback){
    var id = request(callback);
    return function(){ cancel(id); }
  }
})();

// 3ks for angular's raf  service
var k
dom.nextReflow = dom.msie? function(callback){
  return dom.nextFrame(function(){
    k = document.body.offsetWidth;
    callback();
  })
}: dom.nextFrame;

}




},{"./const":51,"./env":57,"./util":77}],57:[function(require,module,exports){
(function (process){
// some fixture test;
// ---------------
var _ = require('./util');
exports.svg = (function(){
  return typeof document !== "undefined" && document.implementation.hasFeature( "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1" );
})();


exports.browser = typeof document !== "undefined" && document.nodeType;
// whether have component in initializing
exports.exprCache = _.cache(1000);
exports.node = typeof process !== "undefined" && ( '' + process ) === '[object process]';
exports.isRunning = false;

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2Vudi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc29tZSBmaXh0dXJlIHRlc3Q7XG4vLyAtLS0tLS0tLS0tLS0tLS1cbnZhciBfID0gcmVxdWlyZSgnLi91dGlsJyk7XG5leHBvcnRzLnN2ZyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoIFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZVwiLCBcIjEuMVwiICk7XG59KSgpO1xuXG5cbmV4cG9ydHMuYnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ub2RlVHlwZTtcbi8vIHdoZXRoZXIgaGF2ZSBjb21wb25lbnQgaW4gaW5pdGlhbGl6aW5nXG5leHBvcnRzLmV4cHJDYWNoZSA9IF8uY2FjaGUoMTAwMCk7XG5leHBvcnRzLm5vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoICcnICsgcHJvY2VzcyApID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5leHBvcnRzLmlzUnVubmluZyA9IGZhbHNlO1xuIl19
},{"./util":77,"_process":48}],58:[function(require,module,exports){
var _ = require('./util');
var combine = require('./helper/combine')

function Group(list){
  this.children = list || [];
}


var o = _.extend(Group.prototype, {
  destroy: function(first){
    combine.destroy(this.children, first);
    if(this.ondestroy) this.ondestroy();
    this.children = null;
  },
  get: function(i){
    return this.children[i]
  },
  push: function(item){
    this.children.push( item );
  }
})
o.inject = o.$inject = combine.inject



module.exports = Group;



},{"./helper/combine":60,"./util":77}],59:[function(require,module,exports){
var _ = require("../util");
var dom  = require("../dom");
var animate = {};
var env = require("../env");


if(typeof window !== 'undefined'){
var 
  transitionEnd = 'transitionend', 
  animationEnd = 'animationend', 
  transitionProperty = 'transition', 
  animationProperty = 'animation';

if(!('ontransitionend' in window)){
  if('onwebkittransitionend' in window) {
    
    // Chrome/Saf (+ Mobile Saf)/Android
    transitionEnd += ' webkitTransitionEnd';
    transitionProperty = 'webkitTransition'
  } else if('onotransitionend' in dom.tNode || navigator.appName === 'Opera') {

    // Opera
    transitionEnd += ' oTransitionEnd';
    transitionProperty = 'oTransition';
  }
}
if(!('onanimationend' in window)){
  if ('onwebkitanimationend' in window){
    // Chrome/Saf (+ Mobile Saf)/Android
    animationEnd += ' webkitAnimationEnd';
    animationProperty = 'webkitAnimation';

  }else if ('onoanimationend' in dom.tNode){
    // Opera
    animationEnd += ' oAnimationEnd';
    animationProperty = 'oAnimation';
  }
}
}

/**
 * inject node with animation
 * @param  {[type]} node      [description]
 * @param  {[type]} refer     [description]
 * @param  {[type]} direction [description]
 * @return {[type]}           [description]
 */
animate.inject = function( node, refer ,direction, callback ){
  callback = callback || _.noop;
  if( Array.isArray(node) ){
    var fragment = dom.fragment();
    var count=0;

    for(var i = 0,len = node.length;i < len; i++ ){
      fragment.appendChild(node[i]); 
    }
    dom.inject(fragment, refer, direction);

    // if all nodes is done, we call the callback
    var enterCallback = function (){
      count++;
      if( count === len ) callback();
    }
    if(len === count) callback();
    for( i = 0; i < len; i++ ){
      if(node[i].onenter){
        node[i].onenter(enterCallback);
      }else{
        enterCallback();
      }
    }
  }else{
    if(!node) return;
    dom.inject( node, refer, direction );
    if(node.onenter){
      node.onenter(callback)
    }else{
      callback();
    }
  }
}

/**
 * remove node with animation
 * @param  {[type]}   node     [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 */

animate.remove = function(node, callback){
  if(!node) return;
  var count = 0;
  function loop(){
    count++;
    if(count === len) callback && callback()
  }
  if( Array.isArray(node) ){
    for(var i = 0, len = node.length; i < len ; i++){
      animate.remove(node[i], loop)
    }
    return;
  }
  if(typeof node.onleave ==='function'){
    node.onleave(function(){
      removeDone(node, callback)
    })
  }else{
    removeDone(node, callback)
  }
}

function removeDone(node, callback){
    dom.remove(node);
    callback && callback();
}



animate.startClassAnimate = function ( node, className,  callback, mode ){
  var activeClassName, timeout, tid, onceAnim;
  if( (!animationEnd && !transitionEnd) || env.isRunning ){
    return callback();
  }

  if(mode !== 4){
    onceAnim = _.once(function onAnimateEnd(){
      if(tid) clearTimeout(tid);

      if(mode === 2) {
        dom.delClass(node, activeClassName);
      }
      if(mode !== 3){ // mode hold the class
        dom.delClass(node, className);
      }
      dom.off(node, animationEnd, onceAnim)
      dom.off(node, transitionEnd, onceAnim)

      callback();

    });
  }else{
    onceAnim = _.once(function onAnimateEnd(){
      if(tid) clearTimeout(tid);
      callback();
    });
  }
  if(mode === 2){ // auto removed
    dom.addClass( node, className );

    activeClassName = _.map(className.split(/\s+/), function(name){
       return name + '-active';
    }).join(" ");

    dom.nextReflow(function(){
      dom.addClass( node, activeClassName );
      timeout = getMaxTimeout( node );
      tid = setTimeout( onceAnim, timeout );
    });

  }else if(mode===4){
    dom.nextReflow(function(){
      dom.delClass( node, className );
      timeout = getMaxTimeout( node );
      tid = setTimeout( onceAnim, timeout );
    });

  }else{
    dom.nextReflow(function(){
      dom.addClass( node, className );
      timeout = getMaxTimeout( node );
      tid = setTimeout( onceAnim, timeout );
    });
  }



  dom.on( node, animationEnd, onceAnim )
  dom.on( node, transitionEnd, onceAnim )
  return onceAnim;
}


animate.startStyleAnimate = function(node, styles, callback){
  var timeout, onceAnim, tid;

  dom.nextReflow(function(){
    dom.css( node, styles );
    timeout = getMaxTimeout( node );
    tid = setTimeout( onceAnim, timeout );
  });


  onceAnim = _.once(function onAnimateEnd(){
    if(tid) clearTimeout(tid);

    dom.off(node, animationEnd, onceAnim)
    dom.off(node, transitionEnd, onceAnim)

    callback();

  });

  dom.on( node, animationEnd, onceAnim )
  dom.on( node, transitionEnd, onceAnim )

  return onceAnim;
}


/**
 * get maxtimeout
 * @param  {Node} node 
 * @return {[type]}   [description]
 */
function getMaxTimeout(node){
  var timeout = 0,
    tDuration = 0,
    tDelay = 0,
    aDuration = 0,
    aDelay = 0,
    ratio = 5 / 3,
    styles ;

  if(window.getComputedStyle){

    styles = window.getComputedStyle(node),
    tDuration = getMaxTime( styles[transitionProperty + 'Duration']) || tDuration;
    tDelay = getMaxTime( styles[transitionProperty + 'Delay']) || tDelay;
    aDuration = getMaxTime( styles[animationProperty + 'Duration']) || aDuration;
    aDelay = getMaxTime( styles[animationProperty + 'Delay']) || aDelay;
    timeout = Math.max( tDuration+tDelay, aDuration + aDelay );

  }
  return timeout * 1000 * ratio;
}

function getMaxTime(str){

  var maxTimeout = 0, time;

  if(!str) return 0;

  str.split(",").forEach(function(str){

    time = parseFloat(str);
    if( time > maxTimeout ) maxTimeout = time;

  });

  return maxTimeout;
}

module.exports = animate;
},{"../dom":56,"../env":57,"../util":77}],60:[function(require,module,exports){
// some nested  operation in ast 
// --------------------------------

var dom = require("../dom");
var animate = require("./animate");

var combine = module.exports = {

  // get the initial dom in object
  node: function(item){
    var children,node, nodes;
    if(!item) return;
    if(typeof item.node === "function") return item.node();
    if(typeof item.nodeType === "number") return item;
    if(item.group) return combine.node(item.group)

    item = item.children || item;
    if( Array.isArray(item )){
      var len = item.length;
      if(len === 1){
        return combine.node(item[0]);
      }
      nodes = [];
      for(var i = 0, len = item.length; i < len; i++ ){
        node = combine.node(item[i]);
        if(Array.isArray(node)){
          nodes.push.apply(nodes, node)
        }else if(node) {
          nodes.push(node)
        }
      }
      return nodes;
    }
    
  },
  // @TODO remove _gragContainer
  inject: function(node, pos ){
    var group = this;
    var fragment = combine.node(group.group || group);
    if(node === false) {
      animate.remove(fragment)
      return group;
    }else{
      if(!fragment) return group;
      if(typeof node === 'string') node = dom.find(node);
      if(!node) throw Error('injected node is not found');
      // use animate to animate firstchildren
      animate.inject(fragment, node, pos);
    }
    // if it is a component
    if(group.$emit) {
      var preParent = group.parentNode;
      var newParent = (pos ==='after' || pos === 'before')? node.parentNode : node;
      group.parentNode = newParent;
      group.$emit("$inject", node, pos, preParent);
    }
    return group;
  },

  // get the last dom in object(for insertion operation)
  last: function(item){
    var children = item.children;

    if(typeof item.last === "function") return item.last();
    if(typeof item.nodeType === "number") return item;

    if(children && children.length) return combine.last(children[children.length - 1]);
    if(item.group) return combine.last(item.group);

  },

  destroy: function(item, first){
    if(!item) return;
    if( typeof item.nodeType === "number"  ) return first && dom.remove(item)
    if( typeof item.destroy === "function" ) return item.destroy(first);

    if( Array.isArray(item)){
      for(var i = 0, len = item.length; i < len; i++ ){
        combine.destroy(item[i], first);
      }
    }
  }

}


// @TODO: need move to dom.js
dom.element = function( component, all ){
  if(!component) return !all? null: [];
  var nodes = combine.node( component );
  if( nodes.nodeType === 1 ) return all? [nodes]: nodes;
  var elements = [];
  for(var i = 0; i<nodes.length ;i++){
    var node = nodes[i];
    if( node && node.nodeType === 1){
      if(!all) return node;
      elements.push(node);
    } 
  }
  return !all? elements[0]: elements;
}




},{"../dom":56,"./animate":59}],61:[function(require,module,exports){
function NodeCursor(node){
  this.node = node;
}


var no = NodeCursor.prototype;

no.next = function(){
  this.node = this.node.nextSibling;
  return this;
}

module.exports = function(n){ return new NodeCursor(n)}

},{}],62:[function(require,module,exports){
var _ = require('../util');

function simpleDiff(now, old){
  var nlen = now.length;
  var olen = old.length;
  if(nlen !== olen){
    return true;
  }
  for(var i = 0; i < nlen ; i++){
    if(now[i] !== old[i]) return  true;
  }
  return false

}

function equals(a,b){
  return a === b;
}

// array1 - old array
// array2 - new array
function ld(array1, array2, equalFn){
  var n = array1.length;
  var m = array2.length;
  var equalFn = equalFn || equals;
  var matrix = [];
  for(var i = 0; i <= n; i++){
    matrix.push([i]);
  }
  for(var j=1;j<=m;j++){
    matrix[0][j]=j;
  }
  for(var i = 1; i <= n; i++){
    for(var j = 1; j <= m; j++){
      if(equalFn(array1[i-1], array2[j-1])){
        matrix[i][j] = matrix[i-1][j-1];
      }else{
        matrix[i][j] = Math.min(
          matrix[i-1][j]+1, //delete
          matrix[i][j-1]+1//add
          )
      }
    }
  }
  return matrix;
}
// arr2 - new array
// arr1 - old array
function diffArray(arr2, arr1, diff, diffFn) {
  if(!diff) return simpleDiff(arr2, arr1);
  var matrix = ld(arr1, arr2, diffFn)
  var n = arr1.length;
  var i = n;
  var m = arr2.length;
  var j = m;
  var edits = [];
  var current = matrix[i][j];
  while(i>0 || j>0){
  // the last line
    if (i === 0) {
      edits.unshift(3);
      j--;
      continue;
    }
    // the last col
    if (j === 0) {
      edits.unshift(2);
      i--;
      continue;
    }
    var northWest = matrix[i - 1][j - 1];
    var west = matrix[i - 1][j];
    var north = matrix[i][j - 1];

    var min = Math.min(north, west, northWest);

    if (min === west) {
      edits.unshift(2); //delete
      i--;
      current = west;
    } else if (min === northWest ) {
      if (northWest === current) {
        edits.unshift(0); //no change
      } else {
        edits.unshift(1); //update
        current = northWest;
      }
      i--;
      j--;
    } else {
      edits.unshift(3); //add
      j--;
      current = north;
    }
  }
  var LEAVE = 0;
  var ADD = 3;
  var DELELE = 2;
  var UPDATE = 1;
  var n = 0;m=0;
  var steps = [];
  var step = { index: null, add:0, removed:[] };

  for(var i=0;i<edits.length;i++){
    if(edits[i] > 0 ){ // NOT LEAVE
      if(step.index === null){
        step.index = m;
      }
    } else { //LEAVE
      if(step.index != null){
        steps.push(step)
        step = {index: null, add:0, removed:[]};
      }
    }
    switch(edits[i]){
      case LEAVE:
        n++;
        m++;
        break;
      case ADD:
        step.add++;
        m++;
        break;
      case DELELE:
        step.removed.push(arr1[n])
        n++;
        break;
      case UPDATE:
        step.add++;
        step.removed.push(arr1[n])
        n++;
        m++;
        break;
    }
  }
  if(step.index != null){
    steps.push(step)
  }
  return steps
}



// diffObject
// ----
// test if obj1 deepEqual obj2
function diffObject( now, last, diff ){


  if(!diff){

    for( var j in now ){
      if( last[j] !== now[j] ) return true
    }

    for( var n in last ){
      if(last[n] !== now[n]) return true;
    }

  }else{

    var nKeys = _.keys(now);
    var lKeys = _.keys(last);

    /**
     * [description]
     * @param  {[type]} a    [description]
     * @param  {[type]} b){                   return now[b] [description]
     * @return {[type]}      [description]
     */
    return diffArray(nKeys, lKeys, diff, function(a, b){
      return now[b] === last[a];
    });

  }

  return false;


}

module.exports = {
  diffArray: diffArray,
  diffObject: diffObject
}
},{"../util":77}],63:[function(require,module,exports){
// http://stackoverflow.com/questions/1354064/how-to-convert-characters-to-html-entities-using-plain-javascript
var entities = {
  'quot':34, 
  'amp':38, 
  'apos':39, 
  'lt':60, 
  'gt':62, 
  'nbsp':160, 
  'iexcl':161, 
  'cent':162, 
  'pound':163, 
  'curren':164, 
  'yen':165, 
  'brvbar':166, 
  'sect':167, 
  'uml':168, 
  'copy':169, 
  'ordf':170, 
  'laquo':171, 
  'not':172, 
  'shy':173, 
  'reg':174, 
  'macr':175, 
  'deg':176, 
  'plusmn':177, 
  'sup2':178, 
  'sup3':179, 
  'acute':180, 
  'micro':181, 
  'para':182, 
  'middot':183, 
  'cedil':184, 
  'sup1':185, 
  'ordm':186, 
  'raquo':187, 
  'frac14':188, 
  'frac12':189, 
  'frac34':190, 
  'iquest':191, 
  'Agrave':192, 
  'Aacute':193, 
  'Acirc':194, 
  'Atilde':195, 
  'Auml':196, 
  'Aring':197, 
  'AElig':198, 
  'Ccedil':199, 
  'Egrave':200, 
  'Eacute':201, 
  'Ecirc':202, 
  'Euml':203, 
  'Igrave':204, 
  'Iacute':205, 
  'Icirc':206, 
  'Iuml':207, 
  'ETH':208, 
  'Ntilde':209, 
  'Ograve':210, 
  'Oacute':211, 
  'Ocirc':212, 
  'Otilde':213, 
  'Ouml':214, 
  'times':215, 
  'Oslash':216, 
  'Ugrave':217, 
  'Uacute':218, 
  'Ucirc':219, 
  'Uuml':220, 
  'Yacute':221, 
  'THORN':222, 
  'szlig':223, 
  'agrave':224, 
  'aacute':225, 
  'acirc':226, 
  'atilde':227, 
  'auml':228, 
  'aring':229, 
  'aelig':230, 
  'ccedil':231, 
  'egrave':232, 
  'eacute':233, 
  'ecirc':234, 
  'euml':235, 
  'igrave':236, 
  'iacute':237, 
  'icirc':238, 
  'iuml':239, 
  'eth':240, 
  'ntilde':241, 
  'ograve':242, 
  'oacute':243, 
  'ocirc':244, 
  'otilde':245, 
  'ouml':246, 
  'divide':247, 
  'oslash':248, 
  'ugrave':249, 
  'uacute':250, 
  'ucirc':251, 
  'uuml':252, 
  'yacute':253, 
  'thorn':254, 
  'yuml':255, 
  'fnof':402, 
  'Alpha':913, 
  'Beta':914, 
  'Gamma':915, 
  'Delta':916, 
  'Epsilon':917, 
  'Zeta':918, 
  'Eta':919, 
  'Theta':920, 
  'Iota':921, 
  'Kappa':922, 
  'Lambda':923, 
  'Mu':924, 
  'Nu':925, 
  'Xi':926, 
  'Omicron':927, 
  'Pi':928, 
  'Rho':929, 
  'Sigma':931, 
  'Tau':932, 
  'Upsilon':933, 
  'Phi':934, 
  'Chi':935, 
  'Psi':936, 
  'Omega':937, 
  'alpha':945, 
  'beta':946, 
  'gamma':947, 
  'delta':948, 
  'epsilon':949, 
  'zeta':950, 
  'eta':951, 
  'theta':952, 
  'iota':953, 
  'kappa':954, 
  'lambda':955, 
  'mu':956, 
  'nu':957, 
  'xi':958, 
  'omicron':959, 
  'pi':960, 
  'rho':961, 
  'sigmaf':962, 
  'sigma':963, 
  'tau':964, 
  'upsilon':965, 
  'phi':966, 
  'chi':967, 
  'psi':968, 
  'omega':969, 
  'thetasym':977, 
  'upsih':978, 
  'piv':982, 
  'bull':8226, 
  'hellip':8230, 
  'prime':8242, 
  'Prime':8243, 
  'oline':8254, 
  'frasl':8260, 
  'weierp':8472, 
  'image':8465, 
  'real':8476, 
  'trade':8482, 
  'alefsym':8501, 
  'larr':8592, 
  'uarr':8593, 
  'rarr':8594, 
  'darr':8595, 
  'harr':8596, 
  'crarr':8629, 
  'lArr':8656, 
  'uArr':8657, 
  'rArr':8658, 
  'dArr':8659, 
  'hArr':8660, 
  'forall':8704, 
  'part':8706, 
  'exist':8707, 
  'empty':8709, 
  'nabla':8711, 
  'isin':8712, 
  'notin':8713, 
  'ni':8715, 
  'prod':8719, 
  'sum':8721, 
  'minus':8722, 
  'lowast':8727, 
  'radic':8730, 
  'prop':8733, 
  'infin':8734, 
  'ang':8736, 
  'and':8743, 
  'or':8744, 
  'cap':8745, 
  'cup':8746, 
  'int':8747, 
  'there4':8756, 
  'sim':8764, 
  'cong':8773, 
  'asymp':8776, 
  'ne':8800, 
  'equiv':8801, 
  'le':8804, 
  'ge':8805, 
  'sub':8834, 
  'sup':8835, 
  'nsub':8836, 
  'sube':8838, 
  'supe':8839, 
  'oplus':8853, 
  'otimes':8855, 
  'perp':8869, 
  'sdot':8901, 
  'lceil':8968, 
  'rceil':8969, 
  'lfloor':8970, 
  'rfloor':8971, 
  'lang':9001, 
  'rang':9002, 
  'loz':9674, 
  'spades':9824, 
  'clubs':9827, 
  'hearts':9829, 
  'diams':9830, 
  'OElig':338, 
  'oelig':339, 
  'Scaron':352, 
  'scaron':353, 
  'Yuml':376, 
  'circ':710, 
  'tilde':732, 
  'ensp':8194, 
  'emsp':8195, 
  'thinsp':8201, 
  'zwnj':8204, 
  'zwj':8205, 
  'lrm':8206, 
  'rlm':8207, 
  'ndash':8211, 
  'mdash':8212, 
  'lsquo':8216, 
  'rsquo':8217, 
  'sbquo':8218, 
  'ldquo':8220, 
  'rdquo':8221, 
  'bdquo':8222, 
  'dagger':8224, 
  'Dagger':8225, 
  'permil':8240, 
  'lsaquo':8249, 
  'rsaquo':8250, 
  'euro':8364
}



module.exports  = entities;
},{}],64:[function(require,module,exports){
// simplest event emitter 60 lines
// ===============================
var _ = require("../util.js");
var API = {
  $on: function(event, fn, desc) {
    if(typeof event === "object" && event){
      for (var i in event) {
        this.$on(i, event[i], fn);
      }
    }else{
      desc = desc || {};
      // @patch: for list
      var context = this;
      var handles = context._handles || (context._handles = {}),
        calls = handles[event] || (handles[event] = []);
      var realFn;
      if(desc.once){
        realFn = function(){
          fn.apply( this, arguments )
          this.$off(event, fn);
        }
        fn.real = realFn;
      }
      calls.push(realFn || fn);
    }
    return this;
  },
  $off: function(event, fn) {
    var context = this;
    if(!context._handles) return;
    if(!event) this._handles = {};
    var handles = context._handles,
      calls;

    if (calls = handles[event]) {
      if (!fn) {
        handles[event] = [];
        return context;
      }
      fn = fn.real || fn;
      for (var i = 0, len = calls.length; i < len; i++) {
        if (fn === calls[i]) {
          calls.splice(i, 1);
          return context;
        }
      }
    }
    return context;
  },
  // bubble event
  $emit: function(event){
    // @patch: for list
    var context = this;
    var handles = context._handles, calls, args, type;
    if(!event) return;
    var args = _.slice(arguments, 1);
    var type = event;

    if(!handles) return context;
    if(calls = handles[type.slice(1)]){
      for (var j = 0, len = calls.length; j < len; j++) {
        calls[j].apply(context, args)
      }
    }
    if (!(calls = handles[type])) return context;
    for (var i = 0, len = calls.length; i < len; i++) {
      calls[i].apply(context, args)
    }
    // if(calls.length) context.$update();
    return context;
  },
  // capture  event
  $once: function(event, fn){
    var args = _.slice(arguments);
    args.push({once: true})
    return this.$on.apply(this, args);
  }
}
// container class
function Event() {}
_.extend(Event.prototype, API)

Event.mixTo = function(obj){
  obj = typeof obj === "function" ? obj.prototype : obj;
  _.extend(obj, API)
}
module.exports = Event;
},{"../util.js":77}],65:[function(require,module,exports){
// (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
// Backbone may be freely distributed under the MIT license.
// For all details and documentation:
// http://backbonejs.org

// klass: a classical JS OOP façade
// https://github.com/ded/klass
// License MIT (c) Dustin Diaz 2014
  
// inspired by backbone's extend and klass
var _ = require("../util"),
  fnTest = /xy/.test(function(){"xy";}) ? /\bsupr\b/:/.*/,
  isFn = function(o){return typeof o === "function"};

var hooks = {
  events: function( propertyValue, proto ){
    var eventListeners = proto._eventListeners || [];
    var normedEvents = _.normListener(propertyValue);

    if(normedEvents.length) {
      proto._eventListeners = eventListeners.concat( normedEvents );
    }
    delete proto.events ;
  }
}


function wrap( k, fn, supro ) {
  return function () {
    var tmp = this.supr;
    this.supr = supro[k];
    var ret = fn.apply(this, arguments);
    this.supr = tmp;
    return ret;
  }
}

function process( what, o, supro ) {
  for ( var k in o ) {
    if (o.hasOwnProperty(k)) {
      if(hooks[k]) {
        hooks[k](o[k], what, supro)
      }
      what[k] = isFn( o[k] ) && isFn( supro[k] ) && 
        fnTest.test( o[k] ) ? wrap(k, o[k], supro) : o[k];
    }
  }
}

// if the property is ["events", "data", "computed"] , we should merge them
var merged = ["data", "computed"], mlen = merged.length;
module.exports = function extend(o){
  o = o || {};
  var supr = this, proto,
    supro = supr && supr.prototype || {};

  if(typeof o === 'function'){
    proto = o.prototype;
    o.implement = implement;
    o.extend = extend;
    return o;
  } 
  
  function fn() {
    supr.apply(this, arguments);
  }

  proto = _.createProto(fn, supro);

  function implement(o){
    // we need merge the merged property
    var len = mlen;
    for(;len--;){
      var prop = merged[len];
      if(proto[prop] && o.hasOwnProperty(prop) && proto.hasOwnProperty(prop)){
        _.extend(proto[prop], o[prop], true) 
        delete o[prop];
      }
    }


    process(proto, o, supro); 
    return this;
  }



  fn.implement = implement
  fn.implement(o)
  if(supr.__after__) supr.__after__.call(fn, supr, o);
  fn.extend = extend;
  return fn;
}


},{"../util":77}],66:[function(require,module,exports){

var f = module.exports = {};

// json:  two way 
//  - get: JSON.stringify
//  - set: JSON.parse
//  - example: `{ title|json }`
f.json = {
  get: function( value ){
    return typeof JSON !== 'undefined'? JSON.stringify(value): value;
  },
  set: function( value ){
    return typeof JSON !== 'undefined'? JSON.parse(value) : value;
  }
}

// last: one-way
//  - get: return the last item in list
//  - example: `{ list|last }`
f.last = function(arr){
  return arr && arr[arr.length - 1];
}

// average: one-way
//  - get: copute the average of the list
//  - example: `{ list| average: "score" }`
f.average = function(array, key){
  array = array || [];
  return array.length? f.total(array, key)/ array.length : 0;
}


// total: one-way
//  - get: copute the total of the list
//  - example: `{ list| total: "score" }`
f.total = function(array, key){
  var total = 0;
  if(!array) return;
  array.forEach(function( item ){
    total += key? item[key] : item;
  })
  return total;
}

// var basicSortFn = function(a, b){return b - a}

// f.sort = function(array, key, reverse){
//   var type = typeof key, sortFn; 
//   switch(type){
//     case 'function': sortFn = key; break;
//     case 'string': sortFn = function(a, b){};break;
//     default:
//       sortFn = basicSortFn;
//   }
//   // need other refernce.
//   return array.slice().sort(function(a,b){
//     return reverse? -sortFn(a, b): sortFn(a, b);
//   })
//   return array
// }



},{}],67:[function(require,module,exports){
var exprCache = require('../env').exprCache;
var _ = require("../util");
var Parser = require("../parser/Parser");
module.exports = {
  expression: function(expr, simple){
    // @TODO cache
    if( typeof expr === 'string' && ( expr = expr.trim() ) ){
      expr = exprCache.get( expr ) || exprCache.set( expr, new Parser( expr, { mode: 2, expression: true } ).expression() )
    }
    if(expr) return expr;
  },
  parse: function(template){
    return new Parser(template).parse();
  }
}


},{"../env":57,"../parser/Parser":73,"../util":77}],68:[function(require,module,exports){
// shim for es5
var slice = [].slice;
var tstr = ({}).toString;

function extend(o1, o2 ){
  for(var i in o2) if( o1[i] === undefined){
    o1[i] = o2[i]
  }
  return o2;
}


module.exports = function(){
  // String proto ;
  extend(String.prototype, {
    trim: function(){
      return this.replace(/^\s+|\s+$/g, '');
    }
  });


  // Array proto;
  extend(Array.prototype, {
    indexOf: function(obj, from){
      from = from || 0;
      for (var i = from, len = this.length; i < len; i++) {
        if (this[i] === obj) return i;
      }
      return -1;
    },
    // polyfill from MDN 
    // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
    forEach: function(callback, ctx){
      var k = 0;

      // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
      var O = Object(this);

      var len = O.length >>> 0; 

      if ( typeof callback !== "function" ) {
        throw new TypeError( callback + " is not a function" );
      }

      // 7. Repeat, while k < len
      while( k < len ) {

        var kValue;

        if ( k in O ) {

          kValue = O[ k ];

          callback.call( ctx, kValue, k, O );
        }
        k++;
      }
    },
    // @deprecated
    //  will be removed at 0.5.0
    filter: function(fun, context){

      var t = Object(this);
      var len = t.length >>> 0;
      if (typeof fun !== "function")
        throw new TypeError();

      var res = [];
      for (var i = 0; i < len; i++)
      {
        if (i in t)
        {
          var val = t[i];
          if (fun.call(context, val, i, t))
            res.push(val);
        }
      }

      return res;
    }
  });

  // Function proto;
  extend(Function.prototype, {
    bind: function(context){
      var fn = this;
      var preArgs = slice.call(arguments, 1);
      return function(){
        var args = preArgs.concat(slice.call(arguments));
        return fn.apply(context, args);
      }
    },
    //@FIXIT
    __bind__: function(context){
      if(this.__binding__){
        return this.__binding__
      }else{
        return (this.__binding__ = this.bind.apply(this, arguments))
      }
    }
  })
  
  // Array
  extend(Array, {
    isArray: function(arr){
      return tstr.call(arr) === "[object Array]";
    }
  })
}


},{}],69:[function(require,module,exports){
var _ = require('../util');
var parseExpression = require('./parse').expression;
var diff = require('./diff');
var diffArray = diff.diffArray;
var diffObject = diff.diffObject;

function Watcher(){}

var methods = {
  $watch: function(expr, fn, options){
    var get, once, test, rlen, extra = this.__ext__; //records length
    if(!this._watchers) this._watchers = [];
    if(!this._watchersForStable) this._watchersForStable = [];

    options = options || {};
    if(options === true){
       options = { deep: true }
    }
    var uid = _.uid('w_');
    if(Array.isArray(expr)){
      var tests = [];
      for(var i = 0,len = expr.length; i < len; i++){
          tests.push(this.$expression(expr[i]).get)
      }
      var prev = [];
      test = function(context){
        var equal = true;
        for(var i =0, len = tests.length; i < len; i++){
          var splice = tests[i](context, extra);
          if(!_.equals(splice, prev[i])){
             equal = false;
             prev[i] = _.clone(splice);
          }
        }
        return equal? false: prev;
      }
    }else{
      if(typeof expr === 'function'){
        get = expr.bind(this);      
      }else{
        expr = this.$expression(expr);
        get = expr.get;
        once = expr.once;
      }
    }

    var watcher = {
      id: uid, 
      get: get, 
      fn: fn, 
      once: once, 
      force: options.force,
      // don't use ld to resolve array diff
      diff: options.diff,
      test: test,
      deep: options.deep,
      last: options.sync? get(this): options.last
    }


    this[options.stable? '_watchersForStable': '_watchers'].push(watcher);
    
    rlen = this._records && this._records.length;
    if(rlen) this._records[rlen-1].push(watcher)
    // init state.
    if(options.init === true){
      var prephase = this.$phase;
      this.$phase = 'digest';
      this._checkSingleWatch( watcher);
      this.$phase = prephase;
    }
    return watcher;
  },
  $unwatch: function( watcher ){
    if(!this._watchers || !watcher) return;
    var watchers = this._watchers;
    var type = typeof watcher;

    if(type === 'object'){
      var len = watcher.length;
      if(!len){
        watcher.removed = true
      }else{
        while( (len--) >= 0 ){
          this.$unwatch(watcher[len])
        }
      }
    }else if(type === 'number'){
      var id = watcher;
      watcher =  _.findItem( watchers, function(item){
        return item.id === id;
      } );
      if(!watcher) watcher = _.findItem(this._watchersForStable, function( item ){
        return item.id === id
      })
      return this.$unwatch(watcher);
    }
    return this;
  },
  $expression: function(value){
    return this._touchExpr(parseExpression(value))
  },
  /**
   * the whole digest loop ,just like angular, it just a dirty-check loop;
   * @param  {String} path  now regular process a pure dirty-check loop, but in parse phase, 
   *                  Regular's parser extract the dependencies, in future maybe it will change to dirty-check combine with path-aware update;
   * @return {Void}   
   */

  $digest: function(){
    if(this.$phase === 'digest' || this._mute) return;
    this.$phase = 'digest';
    var dirty = false, n =0;
    while(dirty = this._digest()){

      if((++n) > 20){ // max loop
        throw Error('there may a circular dependencies reaches')
      }
    }
    // stable watch is dirty
    var stableDirty =  this._digest(true);

    if( (n > 0 || stableDirty) && this.$emit) {
      this.$emit("$update");
      if (this.devtools) {
        this.devtools.emit("flush", this)
      }
    }
    this.$phase = null;
  },
  // private digest logic
  _digest: function(stable){
    if(this._mute) return;
    var watchers = !stable? this._watchers: this._watchersForStable;
    var dirty = false, children, watcher, watcherDirty;
    var len = watchers && watchers.length;
    if(len){
      var mark = 0, needRemoved=0;
      for(var i =0; i < len; i++ ){
        watcher = watchers[i];
        var shouldRemove = !watcher ||  watcher.removed;
        if( shouldRemove ){
          needRemoved += 1;
        }else{
          watcherDirty = this._checkSingleWatch(watcher);
          if(watcherDirty) dirty = true;
        }
        // remove when encounter first unmoved item or touch the end
        if( !shouldRemove || i === len-1 ){
          if( needRemoved ){
            watchers.splice(mark, needRemoved );          
            len -= needRemoved;
            i -= needRemoved;
            needRemoved = 0;
          }
          mark = i+1;
        }
      }
    }
    // check children's dirty.
    children = this._children;
    if(children && children.length){
      for(var m = 0, mlen = children.length; m < mlen; m++){
        var child = children[m];
        if(child && child._digest(stable)) dirty = true;
      }
    }
    return dirty;
  },
  // check a single one watcher 
  _checkSingleWatch: function(watcher){
    var dirty = false;
    if(!watcher) return;

    var now, last, tlast, tnow,  eq, diff;

    if(!watcher.test){

      now = watcher.get(this);
      last = watcher.last;

      if(now !== last || watcher.force){
        tlast = _.typeOf(last);
        tnow = _.typeOf(now);
        eq = true; 

        // !Object
        if( !(tnow === 'object' && tlast==='object' && watcher.deep) ){
          // Array
          if( tnow === 'array' && ( tlast=='undefined' || tlast === 'array') ){
            diff = diffArray(now, watcher.last || [], watcher.diff)
            if( tlast !== 'array' || diff === true || diff.length ) dirty = true;
          }else{
            eq = _.equals( now, last );
            if( !eq || watcher.force ){
              watcher.force = null;
              dirty = true; 
            }
          }
        }else{
          diff =  diffObject( now, last, watcher.diff );
          if( diff === true || diff.length ) dirty = true;
        }
      }

    } else{
      // @TODO 是否把多重改掉
      var result = watcher.test(this);
      if(result){
        dirty = true;
        watcher.fn.apply(this, result)
      }
    }
    if(dirty && !watcher.test){
      if(tnow === 'object' && watcher.deep || tnow === 'array'){
        watcher.last = _.clone(now);
      }else{
        watcher.last = now;
      }
      watcher.fn.call(this, now, last, diff)
      if(watcher.once) this.$unwatch(watcher)
    }

    return dirty;
  },

  /**
   * **tips**: whatever param you passed in $update, after the function called, dirty-check(digest) phase will enter;
   * 
   * @param  {Function|String|Expression} path  
   * @param  {Whatever} value optional, when path is Function, the value is ignored
   * @return {this}     this 
   */
  $set: function(path, value){
    if(path != null){
      var type = typeof (path);
      if( type === 'string' || path.type === 'expression' ){
        path = this.$expression(path);
        path.set(this, value);
      }else if(type === 'function'){
        path.call(this, this.data);
      }else{
        for(var i in path) {
          this.$set(i, path[i])
        }
      }
    }
  },
  // 1. expr canbe string or a Expression
  // 2. detect: if true, if expr is a string will directly return;
  $get: function(expr, detect)  {
    if(detect && typeof expr === 'string') return expr;
    return this.$expression(expr).get(this);
  },
  $update: function(){
    var rootParent = this;
    do{
      if(rootParent.data.isolate || !rootParent.$parent) break;
      rootParent = rootParent.$parent;
    } while(rootParent)

    var prephase =rootParent.$phase;
    rootParent.$phase = 'digest'

    this.$set.apply(this, arguments);

    rootParent.$phase = prephase

    rootParent.$digest();
    return this;
  },
  // auto collect watchers for logic-control.
  _record: function(){
    if(!this._records) this._records = [];
    this._records.push([]);
  },
  _release: function(){
    return this._records.pop();
  }
}


_.extend(Watcher.prototype, methods)


Watcher.mixTo = function(obj){
  obj = typeof obj === "function" ? obj.prototype : obj;
  return _.extend(obj, methods)
}

module.exports = Watcher;

},{"../util":77,"./diff":62,"./parse":67}],70:[function(require,module,exports){
var env =  require("./env");
var config = require("./config"); 
var Regular = module.exports = require("./render/client");
var Parser = Regular.Parser;
var Lexer = Regular.Lexer;

// if(env.browser){
    require("./directive/base");
    require("./directive/animation");
    require("./module/timeout");
    Regular.dom = require("./dom");
// }
Regular.env = env;
Regular.util = require("./util");
Regular.parse = function(str, options){
  options = options || {};

  if(options.BEGIN || options.END){
    if(options.BEGIN) config.BEGIN = options.BEGIN;
    if(options.END) config.END = options.END;
    Lexer.setup();
  }
  var ast = new Parser(str).parse();
  return !options.stringify? ast : JSON.stringify(ast);
}
Regular.Cursor =require('./helper/cursor') 

Regular.isServer = env.node;
Regular.isRegular = function( Comp ){
  return  Comp.prototype instanceof Regular;
}



},{"./config":50,"./directive/animation":52,"./directive/base":53,"./dom":56,"./env":57,"./helper/cursor":61,"./module/timeout":71,"./render/client":75,"./util":77}],71:[function(require,module,exports){
var Regular = require("../render/client");

/**
 * Timeout Module
 * @param {Component} Component 
 */
function TimeoutModule(Component){

  Component.implement({
    /**
     * just like setTimeout, but will enter digest automately
     * @param  {Function} fn    
     * @param  {Number}   delay 
     * @return {Number}   timeoutid
     */
    $timeout: function(fn, delay){
      delay = delay || 0;
      return setTimeout(function(){
        fn.call(this);
        this.$update(); //enter digest
      }.bind(this), delay);
    },
    /**
     * just like setInterval, but will enter digest automately
     * @param  {Function} fn    
     * @param  {Number}   interval 
     * @return {Number}   intervalid
     */
    $interval: function(fn, interval){
      interval = interval || 1000/60;
      return setInterval(function(){
        fn.call(this);
        this.$update(); //enter digest
      }.bind(this), interval);
    }
  });
}


Regular.plugin('timeout', TimeoutModule);
Regular.plugin('$timeout', TimeoutModule);
},{"../render/client":75}],72:[function(require,module,exports){
var _ = require("../util");
var config = require("../config");

// some custom tag  will conflict with the Lexer progress
var conflictTag = {"}": "{", "]": "["}, map1, map2;
// some macro for lexer
var macro = {
  'NAME': /(?:[:_A-Za-z][-\.:_0-9A-Za-z]*)/,
  'IDENT': /[\$_A-Za-z][_0-9A-Za-z\$]*/,
  'SPACE': /[\r\n\t\f ]/
}


var test = /a|(b)/.exec("a");
var testSubCapure = test && test[1] === undefined? 
  function(str){ return str !== undefined }
  :function(str){return !!str};

function wrapHander(handler){
  return function(all){
    return {type: handler, value: all }
  }
}

function Lexer(input, opts){
  if(conflictTag[config.END]){
    this.markStart = conflictTag[config.END];
    this.markEnd = config.END;
  }

  this.input = (input||"").trim();
  this.opts = opts || {};
  this.map = this.opts.mode !== 2?  map1: map2;
  this.states = ["INIT"];
  if(opts && opts.expression){
     this.states.push("JST");
     this.expression = true;
  }
}

var lo = Lexer.prototype


lo.lex = function(str){
  str = (str || this.input).trim();
  var tokens = [], split, test,mlen, token, state;
  this.input = str, 
  this.marks = 0;
  // init the pos index
  this.index=0;
  var i = 0;
  while(str){
    i++
    state = this.state();
    split = this.map[state] 
    test = split.TRUNK.exec(str);
    if(!test){
      this.error('Unrecoginized Token');
    }
    mlen = test[0].length;
    str = str.slice(mlen)
    token = this._process.call(this, test, split, str)
    if(token) tokens.push(token)
    this.index += mlen;
    // if(state == 'TAG' || state == 'JST') str = this.skipspace(str);
  }

  tokens.push({type: 'EOF'});

  return tokens;
}

lo.error = function(msg){
  throw  Error("Parse Error: " + msg +  ':\n' + _.trackErrorPos(this.input, this.index));
}

lo._process = function(args, split,str){
  // console.log(args.join(","), this.state())
  var links = split.links, marched = false, token;

  for(var len = links.length, i=0;i<len ;i++){
    var link = links[i],
      handler = link[2],
      index = link[0];
    // if(args[6] === '>' && index === 6) console.log('haha')
    if(testSubCapure(args[index])) {
      marched = true;
      if(handler){
        token = handler.apply(this, args.slice(index, index + link[1]))
        if(token)  token.pos = this.index;
      }
      break;
    }
  }
  if(!marched){ // in ie lt8 . sub capture is "" but ont 
    switch(str.charAt(0)){
      case "<":
        this.enter("TAG");
        break;
      default:
        this.enter("JST");
        break;
    }
  }
  return token;
}
lo.enter = function(state){
  this.states.push(state)
  return this;
}

lo.state = function(){
  var states = this.states;
  return states[states.length-1];
}

lo.leave = function(state){
  var states = this.states;
  if(!state || states[states.length-1] === state) states.pop()
}


Lexer.setup = function(){
  macro.END = config.END;
  macro.BEGIN = config.BEGIN;
  
  // living template lexer
  map1 = genMap([
    // INIT
    rules.ENTER_JST,
    rules.ENTER_TAG,
    rules.TEXT,

    //TAG
    rules.TAG_NAME,
    rules.TAG_OPEN,
    rules.TAG_CLOSE,
    rules.TAG_PUNCHOR,
    rules.TAG_ENTER_JST,
    rules.TAG_UNQ_VALUE,
    rules.TAG_STRING,
    rules.TAG_SPACE,
    rules.TAG_COMMENT,

    // JST
    rules.JST_OPEN,
    rules.JST_CLOSE,
    rules.JST_COMMENT,
    rules.JST_EXPR_OPEN,
    rules.JST_IDENT,
    rules.JST_SPACE,
    rules.JST_LEAVE,
    rules.JST_NUMBER,
    rules.JST_PUNCHOR,
    rules.JST_STRING,
    rules.JST_COMMENT
    ])

  // ignored the tag-relative token
  map2 = genMap([
    // INIT no < restrict
    rules.ENTER_JST2,
    rules.TEXT,
    // JST
    rules.JST_COMMENT,
    rules.JST_OPEN,
    rules.JST_CLOSE,
    rules.JST_EXPR_OPEN,
    rules.JST_IDENT,
    rules.JST_SPACE,
    rules.JST_LEAVE,
    rules.JST_NUMBER,
    rules.JST_PUNCHOR,
    rules.JST_STRING,
    rules.JST_COMMENT
    ])
}


function genMap(rules){
  var rule, map = {}, sign;
  for(var i = 0, len = rules.length; i < len ; i++){
    rule = rules[i];
    sign = rule[2] || 'INIT';
    ( map[sign] || (map[sign] = {rules:[], links:[]}) ).rules.push(rule);
  }
  return setup(map);
}

function setup(map){
  var split, rules, trunks, handler, reg, retain, rule;
  function replaceFn(all, one){
    return typeof macro[one] === 'string'? 
      _.escapeRegExp(macro[one]) 
      : String(macro[one]).slice(1,-1);
  }

  for(var i in map){

    split = map[i];
    split.curIndex = 1;
    rules = split.rules;
    trunks = [];

    for(var j = 0,len = rules.length; j<len; j++){
      rule = rules[j]; 
      reg = rule[0];
      handler = rule[1];

      if(typeof handler === 'string'){
        handler = wrapHander(handler);
      }
      if(_.typeOf(reg) === 'regexp') reg = reg.toString().slice(1, -1);

      reg = reg.replace(/\{(\w+)\}/g, replaceFn)
      retain = _.findSubCapture(reg) + 1; 
      split.links.push([split.curIndex, retain, handler]); 
      split.curIndex += retain;
      trunks.push(reg);
    }
    split.TRUNK = new RegExp("^(?:(" + trunks.join(")|(") + "))")
  }
  return map;
}

var rules = {

  // 1. INIT
  // ---------------

  // mode1's JST ENTER RULE
  ENTER_JST: [/[^\x00<]*?(?={BEGIN})/, function(all){
    this.enter('JST');
    if(all) return {type: 'TEXT', value: all}
  }],

  // mode2's JST ENTER RULE
  ENTER_JST2: [/[^\x00]*?(?={BEGIN})/, function(all){
    this.enter('JST');
    if(all) return {type: 'TEXT', value: all}
  }],

  ENTER_TAG: [/[^\x00]*?(?=<[\w\/\!])/, function(all){ 
    this.enter('TAG');
    if(all) return {type: 'TEXT', value: all}
  }],

  TEXT: [/[^\x00]+/, 'TEXT' ],

  // 2. TAG
  // --------------------
  TAG_NAME: [/{NAME}/, 'NAME', 'TAG'],
  TAG_UNQ_VALUE: [/[^\{}&"'=><`\r\n\f\t ]+/, 'UNQ', 'TAG'],

  TAG_OPEN: [/<({NAME})\s*/, function(all, one){ //"
    return {type: 'TAG_OPEN', value: one}
  }, 'TAG'],
  TAG_CLOSE: [/<\/({NAME})[\r\n\f\t ]*>/, function(all, one){
    this.leave();
    return {type: 'TAG_CLOSE', value: one }
  }, 'TAG'],

    // mode2's JST ENTER RULE
  TAG_ENTER_JST: [/(?={BEGIN})/, function(){
    this.enter('JST');
  }, 'TAG'],


  TAG_PUNCHOR: [/[\>\/=&]/, function(all){
    if(all === '>') this.leave();
    return {type: all, value: all }
  }, 'TAG'],
  TAG_STRING:  [ /'([^']*)'|"([^"]*)\"/, /*'*/  function(all, one, two){ 
    var value = one || two || "";

    return {type: 'STRING', value: value}
  }, 'TAG'],

  TAG_SPACE: [/{SPACE}+/, null, 'TAG'],
  TAG_COMMENT: [/<\!--([^\x00]*?)--\>/, function(all){
    this.leave()
    // this.leave('TAG')
  } ,'TAG'],

  // 3. JST
  // -------------------

  JST_OPEN: ['{BEGIN}#{SPACE}*({IDENT})', function(all, name){
    return {
      type: 'OPEN',
      value: name
    }
  }, 'JST'],
  JST_LEAVE: [/{END}/, function(all){
    if(this.markEnd === all && this.expression) return {type: this.markEnd, value: this.markEnd};
    if(!this.markEnd || !this.marks ){
      this.firstEnterStart = false;
      this.leave('JST');
      return {type: 'END'}
    }else{
      this.marks--;
      return {type: this.markEnd, value: this.markEnd}
    }
  }, 'JST'],
  JST_CLOSE: [/{BEGIN}\s*\/({IDENT})\s*{END}/, function(all, one){
    this.leave('JST');
    return {
      type: 'CLOSE',
      value: one
    }
  }, 'JST'],
  JST_COMMENT: [/{BEGIN}\!([^\x00]*?)\!{END}/, function(){
    this.leave();
  }, 'JST'],
  JST_EXPR_OPEN: ['{BEGIN}',function(all, one){
    if(all === this.markStart){
      if(this.expression) return { type: this.markStart, value: this.markStart };
      if(this.firstEnterStart || this.marks){
        this.marks++
        this.firstEnterStart = false;
        return { type: this.markStart, value: this.markStart };
      }else{
        this.firstEnterStart = true;
      }
    }
    return {
      type: 'EXPR_OPEN',
      escape: false
    }

  }, 'JST'],
  JST_IDENT: ['{IDENT}', 'IDENT', 'JST'],
  JST_SPACE: [/[ \r\n\f]+/, null, 'JST'],
  JST_PUNCHOR: [/[=!]?==|[-=><+*\/%\!]?\=|\|\||&&|\@\(|\.\.|[<\>\[\]\(\)\-\|\{}\+\*\/%?:\.!,]/, function(all){
    return { type: all, value: all }
  },'JST'],

  JST_STRING:  [ /'([^']*)'|"([^"]*)"/, function(all, one, two){ //"'
    return {type: 'STRING', value: one || two || ""}
  }, 'JST'],
  JST_NUMBER: [/(?:[0-9]*\.[0-9]+|[0-9]+)(e\d+)?/, function(all){
    return {type: 'NUMBER', value: parseFloat(all, 10)};
  }, 'JST']
}


// setup when first config
Lexer.setup();



module.exports = Lexer;

},{"../config":50,"../util":77}],73:[function(require,module,exports){
var _ = require("../util");

var config = require("../config");
var node = require("./node");
var Lexer = require("./Lexer");
var varName = _.varName;
var ctxName = _.ctxName;
var extName = _.extName;
var isPath = _.makePredicate("STRING IDENT NUMBER");
var isKeyWord = _.makePredicate("true false undefined null this Array Date JSON Math NaN RegExp decodeURI decodeURIComponent encodeURI encodeURIComponent parseFloat parseInt Object");
var isInvalidTag = _.makePredicate("script style");
var isLastBind = /\.bind$/;



function Parser(input, opts){
  opts = opts || {};

  this.input = input;
  this.tokens = new Lexer(input, opts).lex();
  this.pos = 0;
  this.length = this.tokens.length;
}


var op = Parser.prototype;


op.parse = function(){
  this.pos = 0;
  var res= this.program();
  if(this.ll().type === 'TAG_CLOSE'){
    this.error("You may got a unclosed Tag")
  }
  return res;
}

op.ll =  function(k){
  k = k || 1;
  if(k < 0) k = k + 1;
  var pos = this.pos + k - 1;
  if(pos > this.length - 1){
      return this.tokens[this.length-1];
  }
  return this.tokens[pos];
}
  // lookahead
op.la = function(k){
  return (this.ll(k) || '').type;
}

op.match = function(type, value){
  var ll;
  if(!(ll = this.eat(type, value))){
    ll  = this.ll();
    this.error('expect [' + type + (value == null? '':':'+ value) + ']" -> got "[' + ll.type + (value==null? '':':'+ll.value) + ']', ll.pos)
  }else{
    return ll;
  }
}

op.error = function(msg, pos){
  msg =  "\n【 parse failed 】 " + msg +  ':\n\n' + _.trackErrorPos(this.input, typeof pos === 'number'? pos: this.ll().pos||0);
  throw new Error(msg);
}

op.next = function(k){
  k = k || 1;
  this.pos += k;
}
op.eat = function(type, value){
  var ll = this.ll();
  if(typeof type !== 'string'){
    for(var len = type.length ; len--;){
      if(ll.type === type[len]) {
        this.next();
        return ll;
      }
    }
  }else{
    if( ll.type === type && (typeof value === 'undefined' || ll.value === value) ){
       this.next();
       return ll;
    }
  }
  return false;
}

// program
//  :EOF
//  | (statement)* EOF
op.program = function(){
  var statements = [],  ll = this.ll();
  while(ll.type !== 'EOF' && ll.type !=='TAG_CLOSE'){

    statements.push(this.statement());
    ll = this.ll();
  }
  // if(ll.type === 'TAG_CLOSE') this.error("You may have unmatched Tag")
  return statements;
}

// statement
//  : xml
//  | jst
//  | text
var rRN = /\r\n/g;
op.statement = function(){
  var ll = this.ll();
  switch(ll.type){
    case 'NAME':
    case 'TEXT':
      var text = ll.value;
      this.next();
      while(ll = this.eat(['NAME', 'TEXT'])){
        text += ll.value;
      }
      return node.text(text.replace(rRN, '\n'));
    case 'TAG_OPEN':
      return this.xml();
    case 'OPEN': 
      return this.directive();
    case 'EXPR_OPEN':
      return this.interplation();
    default:
      this.error('Unexpected token: '+ this.la())
  }
}

// xml 
// stag statement* TAG_CLOSE?(if self-closed tag)
op.xml = function(){
  var name, attrs, children, selfClosed;
  name = this.match('TAG_OPEN').value;

  if( isInvalidTag(name)){
    this.error('Invalid Tag: ' + name);
  }
  attrs = this.attrs();
  selfClosed = this.eat('/')
  this.match('>');
  if( !selfClosed && !_.isVoidTag(name) ){
    children = this.program();
    if(!this.eat('TAG_CLOSE', name)) this.error('expect </'+name+'> got'+ 'no matched closeTag')
  }
  return node.element(name, attrs, children);
}

// xentity
//  -rule(wrap attribute)
//  -attribute
//
// __example__
//  name = 1 |  
//  ng-hide |
//  on-click={{}} | 
//  {{#if name}}on-click={{xx}}{{#else}}on-tap={{}}{{/if}}

op.xentity = function(ll){
  var name = ll.value, value, modifier;
  if(ll.type === 'NAME'){
    //@ only for test
    if(~name.indexOf('.')){
      var tmp = name.split('.');
      name = tmp[0];
      modifier = tmp[1]

    }
    if( this.eat("=") ) value = this.attvalue(modifier);
    return node.attribute( name, value, modifier );
  }else{
    if( name !== 'if') this.error("current version. ONLY RULE #if #else #elseif is valid in tag, the rule #" + name + ' is invalid');
    return this['if'](true);
  }

}

// stag     ::=    '<' Name (S attr)* S? '>'  
// attr    ::=     Name Eq attvalue
op.attrs = function(isAttribute){
  var eat
  if(!isAttribute){
    eat = ["NAME", "OPEN"]
  }else{
    eat = ["NAME"]
  }

  var attrs = [], ll;
  while (ll = this.eat(eat)){
    attrs.push(this.xentity( ll ))
  }
  return attrs;
}

// attvalue
//  : STRING  
//  | NAME
op.attvalue = function(mdf){
  var ll = this.ll();
  switch(ll.type){
    case "NAME":
    case "UNQ":
    case "STRING":
      this.next();
      var value = ll.value;
      return value;
    case "EXPR_OPEN":
      return this.interplation();
    default:
      this.error('Unexpected token: '+ this.la())
  }
}


// {{#}}
op.directive = function(){
  var name = this.ll().value;
  this.next();
  if(typeof this[name] === 'function'){
    return this[name]()
  }else{
    this.error('Undefined directive['+ name +']');
  }
}





// {{}}
op.interplation = function(){
  this.match('EXPR_OPEN');
  var res = this.expression(true);
  this.match('END');
  return res;
}

// {{~}}
op.inc = op.include = function(){
  var content = this.expression();
  this.match('END');
  return node.template(content);
}

// {{#if}}
op["if"] = function(tag){
  var test = this.expression();
  var consequent = [], alternate=[];

  var container = consequent;
  var statement = !tag? "statement" : "attrs";

  this.match('END');

  var ll, close;
  while( ! (close = this.eat('CLOSE')) ){
    ll = this.ll();
    if( ll.type === 'OPEN' ){
      switch( ll.value ){
        case 'else':
          container = alternate;
          this.next();
          this.match( 'END' );
          break;
        case 'elseif':
          this.next();
          alternate.push( this["if"](tag) );
          return node['if']( test, consequent, alternate );
        default:
          container.push( this[statement](true) );
      }
    }else{
      container.push(this[statement](true));
    }
  }
  // if statement not matched
  if(close.value !== "if") this.error('Unmatched if directive')
  return node["if"](test, consequent, alternate);
}


// @mark   mustache syntax have natrure dis, canot with expression
// {{#list}}
op.list = function(){
  // sequence can be a list or hash
  var sequence = this.expression(), variable, ll, track;
  var consequent = [], alternate=[];
  var container = consequent;

  this.match('IDENT', 'as');

  variable = this.match('IDENT').value;

  if(this.eat('IDENT', 'by')){
    if(this.eat('IDENT',variable + '_index')){
      track = true;
    }else{
      track = this.expression();
      if(track.constant){
        // true is means constant, we handle it just like xxx_index.
        track = true;
      }
    }
  }

  this.match('END');

  while( !(ll = this.eat('CLOSE')) ){
    if(this.eat('OPEN', 'else')){
      container =  alternate;
      this.match('END');
    }else{
      container.push(this.statement());
    }
  }
  
  if(ll.value !== 'list') this.error('expect ' + 'list got ' + '/' + ll.value + ' ', ll.pos );
  return node.list(sequence, variable, consequent, alternate, track);
}


op.expression = function(){
  var expression;
  if(this.eat('@(')){ //once bind
    expression = this.expr();
    expression.once = true;
    this.match(')')
  }else{
    expression = this.expr();
  }
  return expression;
}

op.expr = function(){
  this.depend = [];

  var buffer = this.filter()

  var body = buffer.get || buffer;
  var setbody = buffer.set;
  return node.expression(body, setbody, !this.depend.length, buffer.filters);
}


// filter
// assign ('|' filtername[':' args]) * 
op.filter = function(){
  var left = this.assign();
  var ll = this.eat('|');
  var buffer = [], filters,setBuffer, prefix,
    attr = "t", 
    set = left.set, get, 
    tmp = "";

  if(ll){
    if(set) {
      setBuffer = [];
      filters = [];
    }

    prefix = "(function(" + attr + "){";

    do{
      var filterName = this.match('IDENT').value;
      tmp = attr + " = " + ctxName + "._f_('" + filterName + "' ).get.call( "+_.ctxName +"," + attr ;
      if(this.eat(':')){
        tmp +=", "+ this.arguments("|").join(",") + ");"
      }else{
        tmp += ');'
      }
      buffer.push(tmp);
      
      if(set){
        // only in runtime ,we can detect  whether  the filter has a set function. 
        filters.push(filterName);
        setBuffer.unshift( tmp.replace(" ).get.call", " ).set.call") );
      }

    }while(ll = this.eat('|'));
    buffer.push("return " + attr );
    setBuffer && setBuffer.push("return " + attr);

    get =  prefix + buffer.join("") + "})("+left.get+")";
    // we call back to value.
    if(setBuffer){
      // change _ss__(name, _p_) to _s__(name, filterFn(_p_));
      set = set.replace(_.setName, 
        prefix + setBuffer.join("") + "})("+　_.setName　+")" );

    }
    // the set function is depend on the filter definition. if it have set method, the set will work
    var ret = getset(get, set);
    ret.filters = filters;
    return ret;
  }
  return left;
}

// assign
// left-hand-expr = condition
op.assign = function(){
  var left = this.condition(), ll;
  if(ll = this.eat(['=', '+=', '-=', '*=', '/=', '%='])){
    if(!left.set) this.error('invalid lefthand expression in assignment expression');
    return getset( left.set.replace( "," + _.setName, "," + this.condition().get ).replace("'='", "'"+ll.type+"'"), left.set);
    // return getset('(' + left.get + ll.type  + this.condition().get + ')', left.set);
  }
  return left;
}

// or
// or ? assign : assign
op.condition = function(){

  var test = this.or();
  if(this.eat('?')){
    return getset([test.get + "?", 
      this.assign().get, 
      this.match(":").type, 
      this.assign().get].join(""));
  }

  return test;
}

// and
// and && or
op.or = function(){

  var left = this.and();

  if(this.eat('||')){
    return getset(left.get + '||' + this.or().get);
  }

  return left;
}
// equal
// equal && and
op.and = function(){

  var left = this.equal();

  if(this.eat('&&')){
    return getset(left.get + '&&' + this.and().get);
  }
  return left;
}
// relation
// 
// equal == relation
// equal != relation
// equal === relation
// equal !== relation
op.equal = function(){
  var left = this.relation(), ll;
  // @perf;
  if( ll = this.eat(['==','!=', '===', '!=='])){
    return getset(left.get + ll.type + this.equal().get);
  }
  return left
}
// relation < additive
// relation > additive
// relation <= additive
// relation >= additive
// relation in additive
op.relation = function(){
  var left = this.additive(), ll;
  // @perf
  if(ll = (this.eat(['<', '>', '>=', '<=']) || this.eat('IDENT', 'in') )){
    return getset(left.get + ll.value + this.relation().get);
  }
  return left
}
// additive :
// multive
// additive + multive
// additive - multive
op.additive = function(){
  var left = this.multive() ,ll;
  if(ll= this.eat(['+','-']) ){
    return getset(left.get + ll.value + this.additive().get);
  }
  return left
}
// multive :
// unary
// multive * unary
// multive / unary
// multive % unary
op.multive = function(){
  var left = this.range() ,ll;
  if( ll = this.eat(['*', '/' ,'%']) ){
    return getset(left.get + ll.type + this.multive().get);
  }
  return left;
}

op.range = function(){
  var left = this.unary(), ll, right;

  if(ll = this.eat('..')){
    right = this.unary();
    var body = 
      "(function(start,end){var res = [],step=end>start?1:-1; for(var i = start; end>start?i <= end: i>=end; i=i+step){res.push(i); } return res })("+left.get+","+right.get+")"
    return getset(body);
  }

  return left;
}



// lefthand
// + unary
// - unary
// ~ unary
// ! unary
op.unary = function(){
  var ll;
  if(ll = this.eat(['+','-','~', '!'])){
    return getset('(' + ll.type + this.unary().get + ')') ;
  }else{
    return this.member()
  }
}

// call[lefthand] :
// member args
// member [ expression ]
// member . ident  

op.member = function(base, last, pathes, prevBase){
  var ll, path;


  var onlySimpleAccessor = false;
  if(!base){ //first
    path = this.primary();
    var type = typeof path;
    if(type === 'string'){ 
      pathes = [];
      pathes.push( path );
      last = path;
      base = ctxName + "._sg_('" + path + "', " + varName + ", " + extName + ")";
      onlySimpleAccessor = true;
    }else{ //Primative Type
      if(path.get === 'this'){
        base = ctxName;
        pathes = ['this'];
      }else{
        pathes = null;
        base = path.get;
      }
    }
  }else{ // not first enter
    if(typeof last === 'string' && isPath( last) ){ // is valid path
      pathes.push(last);
    }else{
      if(pathes && pathes.length) this.depend.push(pathes);
      pathes = null;
    }
  }
  if(ll = this.eat(['[', '.', '('])){
    switch(ll.type){
      case '.':
          // member(object, property, computed)
        var tmpName = this.match('IDENT').value;
        prevBase = base;
        if( this.la() !== "(" ){ 
          base = ctxName + "._sg_('" + tmpName + "', " + base + ")";
        }else{
          base += "." + tmpName ;
        }
        return this.member( base, tmpName, pathes,  prevBase);
      case '[':
          // member(object, property, computed)
        path = this.assign();
        prevBase = base;
        if( this.la() !== "(" ){ 
        // means function call, we need throw undefined error when call function
        // and confirm that the function call wont lose its context
          base = ctxName + "._sg_(" + path.get + ", " + base + ")";
        }else{
          base += "[" + path.get + "]";
        }
        this.match(']')
        return this.member(base, path, pathes, prevBase);
      case '(':
        // call(callee, args)

        base = base.replace(isLastBind, '.__bind__')
        var args = this.arguments().join(',');

        base =  base+"(" + args +")";
        this.match(')')
        return this.member(base, null, pathes);
    }
  }
  if( pathes && pathes.length ) this.depend.push( pathes );
  var res =  {get: base};
  if(last){
    res.set = ctxName + "._ss_(" + 
        (last.get? last.get : "'"+ last + "'") + 
        ","+ _.setName + ","+ 
        (prevBase?prevBase:_.varName) + 
        ", '=', "+ ( onlySimpleAccessor? 1 : 0 ) + ")";
  
  }
  return res;
}

/**
 * 
 */
op.arguments = function(end){
  end = end || ')'
  var args = [];
  do{
    if(this.la() !== end){
      args.push(this.assign().get)
    }
  }while( this.eat(','));
  return args
}


// primary :
// this 
// ident
// literal
// array
// object
// ( expression )

op.primary = function(){
  var ll = this.ll();
  switch(ll.type){
    case "{":
      return this.object();
    case "[":
      return this.array();
    case "(":
      return this.paren();
    // literal or ident
    case 'STRING':
      this.next();
      var value = "" + ll.value;
      var quota = ~value.indexOf("'")? "\"": "'" ;
      return getset(quota + value + quota);
    case 'NUMBER':
      this.next();
      return getset( "" + ll.value );
    case "IDENT":
      this.next();
      if(isKeyWord(ll.value)){
        return getset( ll.value );
      }
      return ll.value;
    default: 
      this.error('Unexpected Token: ' + ll.type);
  }
}

// object
//  {propAssign [, propAssign] * [,]}

// propAssign
//  prop : assign

// prop
//  STRING
//  IDENT
//  NUMBER

op.object = function(){
  var code = [this.match('{').type];

  var ll = this.eat( ['STRING', 'IDENT', 'NUMBER'] );
  while(ll){
    code.push("'" + ll.value + "'" + this.match(':').type);
    var get = this.assign().get;
    code.push(get);
    ll = null;
    if(this.eat(",") && (ll = this.eat(['STRING', 'IDENT', 'NUMBER'])) ) code.push(",");
  }
  code.push(this.match('}').type);
  return {get: code.join("")}
}

// array
// [ assign[,assign]*]
op.array = function(){
  var code = [this.match('[').type], item;
  if( this.eat("]") ){

     code.push("]");
  } else {
    while(item = this.assign()){
      code.push(item.get);
      if(this.eat(',')) code.push(",");
      else break;
    }
    code.push(this.match(']').type);
  }
  return {get: code.join("")};
}

// '(' expression ')'
op.paren = function(){
  this.match('(');
  var res = this.filter()
  res.get = '(' + res.get + ')';
  res.set = res.set;
  this.match(')');
  return res;
}

function getset(get, set){
  return {
    get: get,
    set: set
  }
}



module.exports = Parser;

},{"../config":50,"../util":77,"./Lexer":72,"./node":74}],74:[function(require,module,exports){
module.exports = {
  element: function(name, attrs, children){
    return {
      type: 'element',
      tag: name,
      attrs: attrs,
      children: children
    }
  },
  attribute: function(name, value, mdf){
    return {
      type: 'attribute',
      name: name,
      value: value,
      mdf: mdf
    }
  },
  "if": function(test, consequent, alternate){
    return {
      type: 'if',
      test: test,
      consequent: consequent,
      alternate: alternate
    }
  },
  list: function(sequence, variable, body, alternate, track){
    return {
      type: 'list',
      sequence: sequence,
      alternate: alternate,
      variable: variable,
      body: body,
      track: track
    }
  },
  expression: function( body, setbody, constant, filters ){
    return {
      type: "expression",
      body: body,
      constant: constant || false,
      setbody: setbody || false,
      filters: filters
    }
  },
  text: function(text){
    return {
      type: "text",
      text: text
    }
  },
  template: function(template){
    return {
      type: 'template',
      content: template
    }
  }
}

},{}],75:[function(require,module,exports){
/**
 * render for component in browsers
 */

var env = require('../env');
var Lexer = require('../parser/Lexer');
var Parser = require('../parser/Parser');
var config = require('../config');
var _ = require('../util');
var extend = require('../helper/extend');
var shared = require('./shared');
var combine = {};
if(env.browser){
  var dom = require("../dom");
  var walkers = require('../walkers');
  var Group = require('../group');
  var doc = dom.doc;
  combine = require('../helper/combine');
}
var events = require('../helper/event');
var Watcher = require('../helper/watcher');
var parse = require('../helper/parse');
var filter = require('../helper/filter');
var ERROR = require('../const').ERROR;
var nodeCursor = require('../helper/cursor');
var shared = require('./shared');
var NOOP = function(){};


/**
* `Regular` is regularjs's NameSpace and BaseClass. Every Component is inherited from it
* 
* @class Regular
* @module Regular
* @constructor
* @param {Object} options specification of the component
*/
var Regular = function(definition, options){
  var prevRunning = env.isRunning;
  env.isRunning = true;
  var node, template, cursor, context = this, body, mountNode;
  options = options || {};
  definition = definition || {};



  var dtemplate = definition.template;

  if(env.browser) {

    if( node = tryGetSelector( dtemplate ) ){
      dtemplate = node;
    }
    if( dtemplate && dtemplate.nodeType ){
      definition.template = dtemplate.innerHTML
    }
    
    mountNode = definition.mountNode;
    if(typeof mountNode === 'string'){
      mountNode = dom.find( mountNode );
      if(!mountNode) throw Error('mountNode ' + mountNode + ' is not found')
    } 

    if(mountNode){
      cursor = nodeCursor(mountNode.firstChild)
      delete definition.mountNode
    }else{
      cursor = options.cursor
    }
  }



  template = shared.initDefinition(context, definition)
  

  if(context.$parent){
     context.$parent._append(context);
  }
  context._children = [];
  context.$refs = {};

  var extra = options.extra;
  var oldModify = extra && extra.$$modify;

  if( oldModify ){
    oldModify(this);
  }
  context.$root = context.$root || context;
  
  var newExtra;
  if( body = context._body ){
    context._body = null
    var modifyBodyComponent = context.modifyBodyComponent;
    if( typeof modifyBodyComponent  === 'function'){
      modifyBodyComponent = modifyBodyComponent.bind(this)
      newExtra = _.createObject(extra);
      newExtra.$$modify = function( comp ){
        return modifyBodyComponent(comp, oldModify? oldModify: NOOP)
      }
    }else{ //@FIXIT: multiply modifier
      newExtra = extra
    }
    if(body.ast && body.ast.length){
      context.$body = _.getCompileFn(body.ast, body.ctx , {
        outer: context,
        namespace: options.namespace,
        extra: newExtra,
        record: true
      })
    }
  }

  // handle computed
  if(template){
    var cplOpt = {
      namespace: options.namespace,
      cursor: cursor
    }
    // if(extra && extra.$$modify){
      cplOpt.extra = {$$modify : extra&& extra.$$modify}
    // }
    context.group = context.$compile(template, cplOpt);
    combine.node(context);
  }


  // this is outest component
  if( !context.$parent ) context.$update();
  context.$ready = true;

  context.$emit("$init");
  if( context.init ) context.init( context.data );
  context.$emit("$afterInit");

  env.isRunning = prevRunning;

  // children is not required;
  
  if (this.devtools) {
    this.devtools.emit("init", this)
  }
}

// check if regular devtools hook exists
if(typeof window !== 'undefined'){
  var devtools = window.__REGULAR_DEVTOOLS_GLOBAL_HOOK__;
  if (devtools) {
    Regular.prototype.devtools = devtools;
  }
}

walkers && (walkers.Regular = Regular);


// description
// -------------------------
// 1. Regular and derived Class use same filter
_.extend(Regular, {
  // private data stuff
  _directives: { __regexp__:[] },
  _plugins: {},
  _protoInheritCache: [ 'directive', 'use'] ,
  __after__: function(supr, o) {

    var template;
    this.__after__ = supr.__after__;

    // use name make the component global.
    if(o.name) Regular.component(o.name, this);
    // this.prototype.template = dom.initTemplate(o)
    if(template = o.template){
      var node, name;
      if( env.browser ){
        if( node = tryGetSelector(template) ) template = node ;
        if( template && template.nodeType ){

          if(name = dom.attr(template, 'name')) Regular.component(name, this);

          template = template.innerHTML;
        } 
      }

      if(typeof template === 'string' ){
        this.prototype.template = config.PRECOMPILE? new Parser(template).parse(): template;
      }
    }

    if(o.computed) this.prototype.computed = shared.handleComputed(o.computed);
    // inherit directive and other config from supr
    Regular._inheritConfig(this, supr);

  },
  /**
   * Define a directive
   *
   * @method directive
   * @return {Object} Copy of ...
   */  
  directive: function(name, cfg){
    if(!name) return;

    var type = typeof name;
    if(type === 'object' && !cfg){
      for(var k in name){
        if(name.hasOwnProperty(k)) this.directive(k, name[k]);
      }
      return this;
    }
    var directives = this._directives, directive;
    if(cfg == null){
      if( type === 'string' ){
        if(directive = directives[name]) return directive;
        else{

          var regexp = directives.__regexp__;
          for(var i = 0, len = regexp.length; i < len ; i++){
            directive = regexp[i];
            var test = directive.regexp.test(name);
            if(test) return directive;
          }
        }
      }
    }else{
      if( typeof cfg === 'function') cfg = { link: cfg } 
      if( type === 'string' ) directives[name] = cfg;
      else{
        cfg.regexp = name;
        directives.__regexp__.push(cfg)
      }
      return this
    }
  },
  plugin: function(name, fn){
    var plugins = this._plugins;
    if(fn == null) return plugins[name];
    plugins[name] = fn;
    return this;
  },
  use: function(fn){
    if(typeof fn === "string") fn = Regular.plugin(fn);
    if(typeof fn !== "function") return this;
    fn(this, Regular);
    return this;
  },
  // config the Regularjs's global
  config: function(name, value){
    var needGenLexer = false;
    if(typeof name === "object"){
      for(var i in name){
        // if you config
        if( i ==="END" || i==='BEGIN' )  needGenLexer = true;
        config[i] = name[i];
      }
    }
    if(needGenLexer) Lexer.setup();
  },
  expression: parse.expression,
  Parser: Parser,
  Lexer: Lexer,
  _addProtoInheritCache: function(name, transform){
    if( Array.isArray( name ) ){
      return name.forEach(Regular._addProtoInheritCache);
    }
    var cacheKey = "_" + name + "s"
    Regular._protoInheritCache.push(name)
    Regular[cacheKey] = {};
    if(Regular[name]) return;
    Regular[name] = function(key, cfg){
      var cache = this[cacheKey];

      if(typeof key === "object"){
        for(var i in key){
          if(key.hasOwnProperty(i)) this[name](i, key[i]);
        }
        return this;
      }
      if(cfg == null) return cache[key];
      cache[key] = transform? transform(cfg) : cfg;
      return this;
    }
  },
  _inheritConfig: function(self, supr){

    // prototype inherit some Regular property
    // so every Component will have own container to serve directive, filter etc..
    var defs = Regular._protoInheritCache;
    var keys = _.slice(defs);
    keys.forEach(function(key){
      self[key] = supr[key];
      var cacheKey = '_' + key + 's';
      if(supr[cacheKey]) self[cacheKey] = _.createObject(supr[cacheKey]);
    })
    return self;
  }

});

extend(Regular);

Regular._addProtoInheritCache("component")

Regular._addProtoInheritCache("filter", function(cfg){
  return typeof cfg === "function"? {get: cfg}: cfg;
})


events.mixTo(Regular);
Watcher.mixTo(Regular);

Regular.implement({
  init: function(){},
  config: function(){},
  destroy: function(){
    // destroy event wont propgation;
    this.$emit("$destroy");
    this._watchers = null;
    this._watchersForStable = null;
    this.group && this.group.destroy(true);
    this.group = null;
    this.parentNode = null;
    this._children = null;
    this.$root = null;
    this._handles = null;
    this.$refs = null;
    var parent = this.$parent;
    if(parent && parent._children){
      var index = parent._children.indexOf(this);
      parent._children.splice(index,1);
    }
    this.$parent = null;

    if (this.devtools) {
      this.devtools.emit("destroy", this)
    }
    this._handles = null;
    this.$phase = "destroyed";
  },

  /**
   * compile a block ast ; return a group;
   * @param  {Array} parsed ast
   * @param  {[type]} record
   * @return {[type]}
   */
  $compile: function(ast, options){
    options = options || {};
    if(typeof ast === 'string'){
      ast = new Parser(ast).parse()
    }
    var preExt = this.__ext__,
      record = options.record, 
      records;

    if(options.extra) this.__ext__ = options.extra;


    if(record) this._record();
    var group = this._walk(ast, options);
    if(record){
      records = this._release();
      var self = this;
      if( records.length ){
        // auto destroy all wather;
        group.ondestroy = function(){ self.$unwatch(records); }
      }
    }
    if(options.extra) this.__ext__ = preExt;
    return group;
  },


  /**
   * create two-way binding with another component;
   * *warn*: 
   *   expr1 and expr2 must can operate set&get, for example: the 'a.b' or 'a[b + 1]' is set-able, but 'a.b + 1' is not, 
   *   beacuse Regular dont know how to inverse set through the expression;
   *   
   *   if before $bind, two component's state is not sync, the component(passed param) will sync with the called component;
   *
   * *example: *
   *
   * ```javascript
   * // in this example, we need to link two pager component
   * var pager = new Pager({}) // pager compoennt
   * var pager2 = new Pager({}) // another pager component
   * pager.$bind(pager2, 'current'); // two way bind throw two component
   * pager.$bind(pager2, 'total');   // 
   * // or just
   * pager.$bind(pager2, {"current": "current", "total": "total"}) 
   * ```
   * 
   * @param  {Regular} component the
   * @param  {String|Expression} expr1     required, self expr1 to operate binding
   * @param  {String|Expression} expr2     optional, other component's expr to bind with, if not passed, the expr2 will use the expr1;
   * @return          this;
   */
  $bind: function(component, expr1, expr2){
    var type = _.typeOf(expr1);
    if( expr1.type === 'expression' || type === 'string' ){
      this._bind(component, expr1, expr2)
    }else if( type === "array" ){ // multiply same path binding through array
      for(var i = 0, len = expr1.length; i < len; i++){
        this._bind(component, expr1[i]);
      }
    }else if(type === "object"){
      for(var i in expr1) if(expr1.hasOwnProperty(i)){
        this._bind(component, i, expr1[i]);
      }
    }
    // digest
    component.$update();
    return this;
  },
  /**
   * unbind one component( see $bind also)
   *
   * unbind will unbind all relation between two component
   * 
   * @param  {Regular} component [descriptionegular
   * @return {This}    this
   */
  $unbind: function(){
    // todo
  },
  $inject: combine.inject,
  $mute: function(isMute){

    isMute = !!isMute;

    var needupdate = isMute === false && this._mute;

    this._mute = !!isMute;

    if(needupdate) this.$update();
    return this;
  },
  // private bind logic
  _bind: function(component, expr1, expr2){

    var self = this;
    // basic binding

    if(!component || !(component instanceof Regular)) throw "$bind() should pass Regular component as first argument";
    if(!expr1) throw "$bind() should  pass as least one expression to bind";

    if(!expr2) expr2 = expr1;

    expr1 = parse.expression( expr1 );
    expr2 = parse.expression( expr2 );

    // set is need to operate setting ;
    if(expr2.set){
      var wid1 = this.$watch( expr1, function(value){
        component.$update(expr2, value)
      });
      component.$on('$destroy', function(){
        self.$unwatch(wid1)
      })
    }
    if(expr1.set){
      var wid2 = component.$watch(expr2, function(value){
        self.$update(expr1, value)
      });
      // when brother destroy, we unlink this watcher
      this.$on('$destroy', component.$unwatch.bind(component,wid2))
    }
    // sync the component's state to called's state
    expr2.set(component, expr1.get(this));
  },
  _walk: function(ast, options){
    if( Array.isArray(ast) ){
      var res = [];

      for(var i = 0, len = ast.length; i < len; i++){
        var ret = this._walk(ast[i], options);
        if(ret && ret.code === ERROR.UNMATCHED_AST){
          ast.splice(i, 1);
          i--;
          len--;
        }else res.push( ret );
      }
      return new Group(res);
    }
    if(typeof ast === 'string') return doc.createTextNode(ast)
    return walkers[ast.type || "default"].call(this, ast, options);
  },
  _append: function(component){
    this._children.push(component);
    component.$parent = this;
  },
  _handleEvent: function(elem, type, value, attrs){
    var Component = this.constructor,
      fire = typeof value !== "function"? _.handleEvent.call( this, value, type ) : value,
      handler = Component.event(type), destroy;

    if ( handler ) {
      destroy = handler.call(this, elem, fire, attrs);
    } else {
      dom.on(elem, type, fire);
    }
    return handler ? destroy : function() {
      dom.off(elem, type, fire);
    }
  },
  // 1. 用来处理exprBody -> Function
  // 2. list里的循环
  _touchExpr: function(expr, ext){
    var rawget, ext = this.__ext__, touched = {};
    if(expr.type !== 'expression' || expr.touched) return expr;

    rawget = expr.get;
    if(!rawget){
      rawget = expr.get = new Function(_.ctxName, _.extName , _.prefix+ "return (" + expr.body + ")");
      expr.body = null;
    }
    touched.get = !ext? rawget: function(context, e){
      return rawget( context, e || ext )
    }

    if(expr.setbody && !expr.set){
      var setbody = expr.setbody;
      var filters = expr.filters;
      var self = this;
      if(!filters || !_.some(filters, function(filter){ return !self._f_(filter).set }) ){
        expr.set = function(ctx, value, ext){
          expr.set = new Function(_.ctxName, _.setName , _.extName, _.prefix + setbody);          
          return expr.set(ctx, value, ext);
        }
      }
      expr.filters = expr.setbody = null;
    }
    if(expr.set){
      touched.set = !ext? expr.set : function(ctx, value){
        return expr.set(ctx, value, ext);
      }
    }

    touched.type = 'expression';
    touched.touched = true;
    touched.once = expr.once || expr.constant;
    return touched
  },
  // find filter
  _f_: function(name){
    var Component = this.constructor;
    var filter = Component.filter(name);
    if(!filter) throw Error('filter ' + name + ' is undefined');
    return filter;
  },
  // simple accessor get
  _sg_:function(path, defaults, ext){
    if( path === undefined ) return undefined;
    if(ext && typeof ext === 'object'){
      if(ext[path] !== undefined)  return ext[path];
    }
    var computed = this.computed,
      computedProperty = computed[path];
    if(computedProperty){
      if(computedProperty.type==='expression' && !computedProperty.get) this._touchExpr(computedProperty);
      if(computedProperty.get)  return computedProperty.get(this);
      else _.log("the computed '" + path + "' don't define the get function,  get data."+path + " altnately", "warn")
    }

    if( defaults === undefined  ){
      return undefined;
    }
    return defaults[path];

  },
  // simple accessor set
  _ss_:function(path, value, data , op, computed){
    var computed = this.computed,
      op = op || "=", prev, 
      computedProperty = computed? computed[path]:null;

    if(op !== '='){
      prev = computedProperty? computedProperty.get(this): data[path];
      switch(op){
        case "+=":
          value = prev + value;
          break;
        case "-=":
          value = prev - value;
          break;
        case "*=":
          value = prev * value;
          break;
        case "/=":
          value = prev / value;
          break;
        case "%=":
          value = prev % value;
          break;
      }
    }
    if(computedProperty) {
      if(computedProperty.set) return computedProperty.set(this, value);
      else _.log("the computed '" + path + "' don't define the set function,  assign data."+path + " altnately", "warn" )
    }
    data[path] = value;
    return value;
  }
});

Regular.prototype.inject = function(){
  _.log("use $inject instead of inject", "warn");
  return this.$inject.apply(this, arguments);
}


// only one builtin filter

Regular.filter(filter);

module.exports = Regular;



function tryGetSelector(tpl){
  var node;
  if( typeof tpl === 'string' && tpl.length < 16 && (node = dom.find( tpl )) ) {
    _.log("pass selector as template has be deprecated, pass node or template string instead", 'warn')
    return node
  }
}

},{"../config":50,"../const":51,"../dom":56,"../env":57,"../group":58,"../helper/combine":60,"../helper/cursor":61,"../helper/event":64,"../helper/extend":65,"../helper/filter":66,"../helper/parse":67,"../helper/watcher":69,"../parser/Lexer":72,"../parser/Parser":73,"../util":77,"../walkers":78,"./shared":76}],76:[function(require,module,exports){
var _ = require('../util');
var config = require('../config');
var parse = require('../helper/parse');
var node = require('../parser/node');


function initDefinition(context, definition, beforeConfig){

  var eventConfig, hasInstanceComputed = !!definition.computed, template;
  var usePrototyeString = typeof context.template === 'string' && !definition.template;

 // template is a string (len < 16). we will find it container first

  definition.data = definition.data || {};
  definition.computed = definition.computed || {};
  if( context.data ) _.extend( definition.data, context.data );
  if( context.computed ) _.extend( definition.computed, context.computed );

  var listeners = context._eventListeners || [];
  var normListener;
  // hanle initialized event binding
  if( definition.events){
    normListener = _.normListener(definition.events);
    if(normListener.length){
      listeners = listeners.concat(normListener)
    }
    delete definition.events;
  }


  definition.data = definition.data || {};
  definition.computed = definition.computed || {};
  if(context.data) _.extend(definition.data, context.data);
  if(context.computed) _.extend(definition.computed, context.computed);

  var usePrototyeString = typeof context.template === 'string' && !definition.template;

  _.extend(context, definition, true);



  if(listeners && listeners.length){
    listeners.forEach(function( item ){
      context.$on(item.type, item.listener)
    })
  }


  // we need add some logic at client.
  beforeConfig && beforeConfig();

  // only have instance computed, we need prepare the property
  if( hasInstanceComputed ) context.computed = handleComputed(context.computed);

  context.$emit( "$config", context.data );
  context.config && context.config( context.data );
  context.$emit( "$afterConfig", context.data );

  template = context.template;

 
  if(typeof template === 'string') {
    template = parse.parse(template);
    if(usePrototyeString) {
    // avoid multiply compile
      context.constructor.prototype.template = template;
    }else{
      delete context.template;
    }
  }
  return template;
}

var handleComputed = (function(){
  // wrap the computed getter;
  function wrapGet(get){
    return function(context){
      return get.call(context, context.data );
    }
  }
  // wrap the computed setter;
  function wrapSet(set){
    return function(context, value){
      set.call( context, value, context.data );
      return value;
    }
  }

  return function( computed ){
    if(!computed) return;
    var parsedComputed = {}, handle, pair, type;
    for(var i in computed){
      handle = computed[i]
      type = typeof handle;

      if(handle.type === 'expression'){
        parsedComputed[i] = handle;
        continue;
      }
      if( type === "string" ){
        parsedComputed[i] = parse.expression(handle)
      }else{
        pair = parsedComputed[i] = {type: 'expression'};
        if(type === "function" ){
          pair.get = wrapGet(handle);
        }else{
          if(handle.get) pair.get = wrapGet(handle.get);
          if(handle.set) pair.set = wrapSet(handle.set);
        }
      } 
    }
    return parsedComputed;
  }
})();


function prepareAttr ( ast ,directive ){
  if(ast.parsed ) return ast;
  var value = ast.value;
  var name=  ast.name, body, constant;
  if(typeof value === 'string' && ~value.indexOf(config.BEGIN) && ~value.indexOf(config.END) ){
    if( !directive || !directive.nps ) {
      var parsed = parse.parse(value, { mode: 2 });
      if(parsed.length === 1 && parsed[0].type === 'expression'){ 
        body = parsed[0];
      } else{
        constant = true;
        body = [];
        parsed.forEach(function(item){
          if(!item.constant) constant=false;
          // silent the mutiple inteplation
            body.push(item.body || "'" + item.text.replace(/'/g, "\\'") + "'");        
        });
        body = node.expression("[" + body.join(",") + "].join('')", null, constant);
      }
      ast.value = body;
    }
  }
  ast.parsed = true;
  return ast;
}

module.exports = {
  // share logic between server and client
  initDefinition: initDefinition,
  handleComputed: handleComputed,
  prepareAttr: prepareAttr
}
},{"../config":50,"../helper/parse":67,"../parser/node":74,"../util":77}],77:[function(require,module,exports){
(function (global){
require('./helper/shim')();



var _  = module.exports;
var entities = require('./helper/entities');
var slice = [].slice;
var o2str = ({}).toString;
var win = typeof window !=='undefined'? window: global;
var MAX_PRIORITY = 9999;
var config = require('./config');


_.noop = function(){};
_.uid = (function(){
  var _uid=0;
  return function(){
    return _uid++;
  }
})();

_.extend = function( o1, o2, override ){
  for(var i in o2) if (o2.hasOwnProperty(i)){
    if( o1[i] === undefined || override === true ){
      o1[i] = o2[i]
    }
  }
  return o1;
}

_.keys = Object.keys? Object.keys: function(obj){
  var res = [];
  for(var i in obj) if(obj.hasOwnProperty(i)){
    res.push(i);
  }
  return res;
}

_.some = function(list, fn){
  for(var i =0,len = list.length; i < len; i++){
    if(fn(list[i])) return true
  }
}

_.varName = 'd';
_.setName = 'p_';
_.ctxName = 'c';
_.extName = 'e';

_.rWord = /^[\$\w]+$/;
_.rSimpleAccessor = /^[\$\w]+(\.[\$\w]+)*$/;

_.nextTick = typeof setImmediate === 'function'? 
  setImmediate.bind(win) : 
  function(callback) {
    setTimeout(callback, 0) 
  }



_.prefix = "'use strict';var " + _.varName + "=" + _.ctxName + ".data;" +  _.extName  + "=" + _.extName + "||'';";


_.slice = function(obj, start, end){
  var res = [];
  for(var i = start || 0, len = end || obj.length; i < len; i++){
    res.push(obj[i])
  }
  return res;
}

// beacuse slice and toLowerCase is expensive. we handle undefined and null in another way
_.typeOf = function (o) {
  return o == null ? String(o) :o2str.call(o).slice(8, -1).toLowerCase();
}




_.makePredicate = function makePredicate(words, prefix) {
    if (typeof words === "string") {
        words = words.split(" ");
    }
    var f = "",
    cats = [];
    out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j){
          if (cats[j][0].length === words[i].length) {
              cats[j].push(words[i]);
              continue out;
          }
        }
        cats.push([words[i]]);
    }
    function compareTo(arr) {
        if (arr.length === 1) return f += "return str === '" + arr[0] + "';";
        f += "switch(str){";
        for (var i = 0; i < arr.length; ++i){
           f += "case '" + arr[i] + "':";
        }
        f += "return true}return false;";
    }

    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.
    if (cats.length > 3) {
        cats.sort(function(a, b) {
            return b.length - a.length;
        });
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
        }
        f += "}";

        // Otherwise, simply generate a flat `switch` statement.
    } else {
        compareTo(words);
    }
    return new Function("str", f);
}


_.trackErrorPos = (function (){
  // linebreak
  var lb = /\r\n|[\n\r\u2028\u2029]/g;
  var minRange = 20, maxRange = 20;
  function findLine(lines, pos){
    var tmpLen = 0;
    for(var i = 0,len = lines.length; i < len; i++){
      var lineLen = (lines[i] || "").length;

      if(tmpLen + lineLen > pos) {
        return {num: i, line: lines[i], start: pos - i - tmpLen , prev:lines[i-1], next: lines[i+1] };
      }
      // 1 is for the linebreak
      tmpLen = tmpLen + lineLen ;
    }
  }
  function formatLine(str,  start, num, target){
    var len = str.length;
    var min = start - minRange;
    if(min < 0) min = 0;
    var max = start + maxRange;
    if(max > len) max = len;

    var remain = str.slice(min, max);
    var prefix = "[" +(num+1) + "] " + (min > 0? ".." : "")
    var postfix = max < len ? "..": "";
    var res = prefix + remain + postfix;
    if(target) res += "\n" + new Array(start-min + prefix.length + 1).join(" ") + "^^^";
    return res;
  }
  return function(input, pos){
    if(pos > input.length-1) pos = input.length-1;
    lb.lastIndex = 0;
    var lines = input.split(lb);
    var line = findLine(lines,pos);
    var start = line.start, num = line.num;

    return (line.prev? formatLine(line.prev, start, num-1 ) + '\n': '' ) + 
      formatLine(line.line, start, num, true) + '\n' + 
      (line.next? formatLine(line.next, start, num+1 ) + '\n': '' );

  }
})();


var ignoredRef = /\((\?\!|\?\:|\?\=)/g;
_.findSubCapture = function (regStr) {
  var left = 0,
    right = 0,
    len = regStr.length,
    ignored = regStr.match(ignoredRef); // ignored uncapture
  if(ignored) ignored = ignored.length
  else ignored = 0;
  for (; len--;) {
    var letter = regStr.charAt(len);
    if (len === 0 || regStr.charAt(len - 1) !== "\\" ) { 
      if (letter === "(") left++;
      if (letter === ")") right++;
    }
  }
  if (left !== right) throw "RegExp: "+ regStr + "'s bracket is not marched";
  else return left - ignored;
};


_.escapeRegExp = function( str){// Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
  return str.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, function(match){
    return '\\' + match;
  });
};


var rEntity = new RegExp("&(?:(#x[0-9a-fA-F]+)|(#[0-9]+)|(" + _.keys(entities).join('|') + '));', 'gi');

_.convertEntity = function(chr){

  return ("" + chr).replace(rEntity, function(all, hex, dec, capture){
    var charCode;
    if( dec ) charCode = parseInt( dec.slice(1), 10 );
    else if( hex ) charCode = parseInt( hex.slice(2), 16 );
    else charCode = entities[capture]

    return String.fromCharCode( charCode )
  });

}


// simple get accessor

_.createObject = Object.create? function(o){
  return Object.create(o || null)
}: (function(){
    function Temp() {}
    return function(o){
      if(!o) return {}
      Temp.prototype = o;
      var obj = new Temp();
      Temp.prototype = null; // 不要保持一个 O 的杂散引用（a stray reference）...
      return obj
    }
})();

_.createProto = function(fn, o){
    function Foo() { this.constructor = fn;}
    Foo.prototype = o;
    return (fn.prototype = new Foo());
}


_.removeOne = function(list , filter){
  var len = list.length;
  for(;len--;){
    if(filter(list[len])) {
      list.splice(len, 1)
      return;
    }
  }
}


/**
clone
*/
_.clone = function clone(obj){
  if(!obj || (typeof obj !== 'object' )) return obj;
  if(Array.isArray(obj)){
    var cloned = [];
    for(var i=0,len = obj.length; i< len;i++){
      cloned[i] = obj[i]
    }
    return cloned;
  }else{
    var cloned = {};
    for(var i in obj) if(obj.hasOwnProperty(i)){
      cloned[i] = obj[i];
    }
    return cloned;
  }
}

_.equals = function(now, old){
  var type = typeof now;
  if(type === 'number' && typeof old === 'number'&& isNaN(now) && isNaN(old)) return true
  return now === old;
}

var dash = /-([a-z])/g;
_.camelCase = function(str){
  return str.replace(dash, function(all, capture){
    return capture.toUpperCase();
  })
}



_.throttle = function throttle(func, wait){
  var wait = wait || 100;
  var context, args, result;
  var timeout = null;
  var previous = 0;
  var later = function() {
    previous = +new Date;
    timeout = null;
    result = func.apply(context, args);
    context = args = null;
  };
  return function() {
    var now = + new Date;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
      context = args = null;
    } else if (!timeout) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};

// hogan escape
// ==============
_.escape = (function(){
  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  return function(str) {
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }
})();

_.cache = function(max){
  max = max || 1000;
  var keys = [],
      cache = {};
  return {
    set: function(key, value) {
      if (keys.length > this.max) {
        cache[keys.shift()] = undefined;
      }
      // 
      if(cache[key] === undefined){
        keys.push(key);
      }
      cache[key] = value;
      return value;
    },
    get: function(key) {
      if (key === undefined) return cache;
      return cache[key];
    },
    max: max,
    len:function(){
      return keys.length;
    }
  };
}

// // setup the raw Expression


// handle the same logic on component's `on-*` and element's `on-*`
// return the fire object
_.handleEvent = function(value, type ){
  var self = this, evaluate;
  if(value.type === 'expression'){ // if is expression, go evaluated way
    evaluate = value.get;
  }
  if(evaluate){
    return function fire(obj){
      self.$update(function(){
        var data = this.data;
        data.$event = obj;
        var res = evaluate(self);
        if(res === false && obj && obj.preventDefault) obj.preventDefault();
        data.$event = undefined;
      })

    }
  }else{
    return function fire(){
      var args = _.slice(arguments);
      args.unshift(value);
      self.$update(function(){
        self.$emit.apply(self, args);
      })
    }
  }
}

// only call once
_.once = function(fn){
  var time = 0;
  return function(){
    if( time++ === 0) fn.apply(this, arguments);
  }
}

_.fixObjStr = function(str){
  if(str.trim().indexOf('{') !== 0){
    return '{' + str + '}';
  }
  return str;
}


_.map= function(array, callback){
  var res = [];
  for (var i = 0, len = array.length; i < len; i++) {
    res.push(callback(array[i], i));
  }
  return res;
}

function log(msg, type){
  if(typeof console !== "undefined")  console[type || "log"](msg);
}

_.log = log;


_.normListener = function( events  ){
    var eventListeners = [];
    var pType = _.typeOf( events );
    if( pType === 'array' ){
      return events;
    }else if ( pType === 'object' ){
      for( var i in events ) if ( events.hasOwnProperty(i) ){
        eventListeners.push({
          type: i,
          listener: events[i]
        })
      }
    }
    return eventListeners;
}


//http://www.w3.org/html/wg/drafts/html/master/single-page.html#void-elements
_.isVoidTag = _.makePredicate("area base br col embed hr img input keygen link menuitem meta param source track wbr r-content");
_.isBooleanAttr = _.makePredicate('selected checked disabled readonly required open autofocus controls autoplay compact loop defer multiple');


_.isExpr = function(expr){
  return expr && expr.type === 'expression';
}
// @TODO: make it more strict
_.isGroup = function(group){
  return group.inject || group.$inject;
}

_.blankReg = /\s+/; 

_.getCompileFn = function(source, ctx, options){
  return function( passedOptions ){
    if( passedOptions && options ) _.extend( passedOptions , options );
    else passedOptions = options;
    return ctx.$compile(source, passedOptions )
  }
  return ctx.$compile.bind(ctx,source, options)
}

// remove directive param from AST
_.fixTagAST = function( tagAST, Component ){

  if( tagAST.touched ) return;

  var attrs = tagAST.attrs;

  if( !attrs ) return;

  // Maybe multiple directive need same param, 
  // We place all param in totalParamMap
  var len = attrs.length;
  if(!len) return;
  var directives=[], otherAttrMap = {};
  for(;len--;){

    var attr = attrs[ len ];


    // @IE fix IE9- input type can't assign after value
    if(attr.name === 'type') attr.priority = MAX_PRIORITY + 1;

    var directive = Component.directive( attr.name );
    if( directive ) {

      attr.priority = directive.priority || 1;
      attr.directive = true;
      directives.push(attr);

    }else if(attr.type === 'attribute'){
      otherAttrMap[attr.name] = attr.value;
    }
  }

  directives.forEach( function( attr ){
    var directive = Component.directive(attr.name);
    var param = directive.param;
    if(param && param.length){
      attr.param = {};
      param.forEach(function( name ){
        if( name in otherAttrMap ){
          attr.param[name] = otherAttrMap[name] === undefined? true: otherAttrMap[name]
          _.removeOne(attrs, function(attr){
            return attr.name === name
          })
        }
      })
    }
  });

  attrs.sort(function(a1, a2){
    
    var p1 = a1.priority;
    var p2 = a2.priority;

    if( p1 == null ) p1 = MAX_PRIORITY;
    if( p2 == null ) p2 = MAX_PRIORITY;

    return p2 - p1;

  })

  tagAST.touched = true;
}

_.findItem = function(list, filter){
  if(!list || !list.length) return;
  var len = list.length;
  while(len--){
    if(filter(list[len])) return list[len]
  }
}

_.getParamObj = function(component, param){
  var paramObj = {};
  if(param) {
    for(var i in param) if(param.hasOwnProperty(i)){
      var value = param[i];
      paramObj[i] =  value && value.type==='expression'? component.$get(value): value;
    }
  }
  return paramObj;
}
_.eventReg = /^on-(\w[-\w]+)$/;

_.toText = function(obj){
  return obj == null ? "": "" + obj;
}


// hogan
// https://github.com/twitter/hogan.js
// MIT
_.escape = (function(){
  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  function ignoreNullVal(val) {
    return String((val === undefined || val == null) ? '' : val);
  }

  return function (str) {
    str = ignoreNullVal(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

})();








}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2hlbHBlci9zaGltJykoKTtcblxuXG5cbnZhciBfICA9IG1vZHVsZS5leHBvcnRzO1xudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnLi9oZWxwZXIvZW50aXRpZXMnKTtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIG8yc3RyID0gKHt9KS50b1N0cmluZztcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSd1bmRlZmluZWQnPyB3aW5kb3c6IGdsb2JhbDtcbnZhciBNQVhfUFJJT1JJVFkgPSA5OTk5O1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cblxuXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXy51aWQgPSAoZnVuY3Rpb24oKXtcbiAgdmFyIF91aWQ9MDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIF91aWQrKztcbiAgfVxufSkoKTtcblxuXy5leHRlbmQgPSBmdW5jdGlvbiggbzEsIG8yLCBvdmVycmlkZSApe1xuICBmb3IodmFyIGkgaW4gbzIpIGlmIChvMi5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgaWYoIG8xW2ldID09PSB1bmRlZmluZWQgfHwgb3ZlcnJpZGUgPT09IHRydWUgKXtcbiAgICAgIG8xW2ldID0gbzJbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG8xO1xufVxuXG5fLmtleXMgPSBPYmplY3Qua2V5cz8gT2JqZWN0LmtleXM6IGZ1bmN0aW9uKG9iail7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yKHZhciBpIGluIG9iaikgaWYob2JqLmhhc093blByb3BlcnR5KGkpKXtcbiAgICByZXMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5fLnNvbWUgPSBmdW5jdGlvbihsaXN0LCBmbil7XG4gIGZvcih2YXIgaSA9MCxsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICBpZihmbihsaXN0W2ldKSkgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5fLnZhck5hbWUgPSAnZCc7XG5fLnNldE5hbWUgPSAncF8nO1xuXy5jdHhOYW1lID0gJ2MnO1xuXy5leHROYW1lID0gJ2UnO1xuXG5fLnJXb3JkID0gL15bXFwkXFx3XSskLztcbl8uclNpbXBsZUFjY2Vzc29yID0gL15bXFwkXFx3XSsoXFwuW1xcJFxcd10rKSokLztcblxuXy5uZXh0VGljayA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbic/IFxuICBzZXRJbW1lZGlhdGUuYmluZCh3aW4pIDogXG4gIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCkgXG4gIH1cblxuXG5cbl8ucHJlZml4ID0gXCIndXNlIHN0cmljdCc7dmFyIFwiICsgXy52YXJOYW1lICsgXCI9XCIgKyBfLmN0eE5hbWUgKyBcIi5kYXRhO1wiICsgIF8uZXh0TmFtZSAgKyBcIj1cIiArIF8uZXh0TmFtZSArIFwifHwnJztcIjtcblxuXG5fLnNsaWNlID0gZnVuY3Rpb24ob2JqLCBzdGFydCwgZW5kKXtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IodmFyIGkgPSBzdGFydCB8fCAwLCBsZW4gPSBlbmQgfHwgb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICByZXMucHVzaChvYmpbaV0pXG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gYmVhY3VzZSBzbGljZSBhbmQgdG9Mb3dlckNhc2UgaXMgZXhwZW5zaXZlLiB3ZSBoYW5kbGUgdW5kZWZpbmVkIGFuZCBudWxsIGluIGFub3RoZXIgd2F5XG5fLnR5cGVPZiA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBvID09IG51bGwgPyBTdHJpbmcobykgOm8yc3RyLmNhbGwobykuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG59XG5cblxuXG5cbl8ubWFrZVByZWRpY2F0ZSA9IGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUod29yZHMsIHByZWZpeCkge1xuICAgIGlmICh0eXBlb2Ygd29yZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgd29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG4gICAgfVxuICAgIHZhciBmID0gXCJcIixcbiAgICBjYXRzID0gW107XG4gICAgb3V0OiBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2F0cy5sZW5ndGg7ICsrail7XG4gICAgICAgICAgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09PSB3b3Jkc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHJldHVybiBmICs9IFwicmV0dXJuIHN0ciA9PT0gJ1wiICsgYXJyWzBdICsgXCInO1wiO1xuICAgICAgICBmICs9IFwic3dpdGNoKHN0cil7XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgZiArPSBcImNhc2UgJ1wiICsgYXJyW2ldICsgXCInOlwiO1xuICAgICAgICB9XG4gICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIHRocmVlIGxlbmd0aCBjYXRlZ29yaWVzLCBhbiBvdXRlclxuICAgIC8vIHN3aXRjaCBmaXJzdCBkaXNwYXRjaGVzIG9uIHRoZSBsZW5ndGhzLCB0byBzYXZlIG9uIGNvbXBhcmlzb25zLlxuICAgIGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgY2F0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgZiArPSBcInN3aXRjaChzdHIubGVuZ3RoKXtcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2F0ID0gY2F0c1tpXTtcbiAgICAgICAgICAgIGYgKz0gXCJjYXNlIFwiICsgY2F0WzBdLmxlbmd0aCArIFwiOlwiO1xuICAgICAgICAgICAgY29tcGFyZVRvKGNhdCk7XG4gICAgICAgIH1cbiAgICAgICAgZiArPSBcIn1cIjtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIHNpbXBseSBnZW5lcmF0ZSBhIGZsYXQgYHN3aXRjaGAgc3RhdGVtZW50LlxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBhcmVUbyh3b3Jkcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIiwgZik7XG59XG5cblxuXy50cmFja0Vycm9yUG9zID0gKGZ1bmN0aW9uICgpe1xuICAvLyBsaW5lYnJlYWtcbiAgdmFyIGxiID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG4gIHZhciBtaW5SYW5nZSA9IDIwLCBtYXhSYW5nZSA9IDIwO1xuICBmdW5jdGlvbiBmaW5kTGluZShsaW5lcywgcG9zKXtcbiAgICB2YXIgdG1wTGVuID0gMDtcbiAgICBmb3IodmFyIGkgPSAwLGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgIHZhciBsaW5lTGVuID0gKGxpbmVzW2ldIHx8IFwiXCIpLmxlbmd0aDtcblxuICAgICAgaWYodG1wTGVuICsgbGluZUxlbiA+IHBvcykge1xuICAgICAgICByZXR1cm4ge251bTogaSwgbGluZTogbGluZXNbaV0sIHN0YXJ0OiBwb3MgLSBpIC0gdG1wTGVuICwgcHJldjpsaW5lc1tpLTFdLCBuZXh0OiBsaW5lc1tpKzFdIH07XG4gICAgICB9XG4gICAgICAvLyAxIGlzIGZvciB0aGUgbGluZWJyZWFrXG4gICAgICB0bXBMZW4gPSB0bXBMZW4gKyBsaW5lTGVuIDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0TGluZShzdHIsICBzdGFydCwgbnVtLCB0YXJnZXQpe1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBtaW4gPSBzdGFydCAtIG1pblJhbmdlO1xuICAgIGlmKG1pbiA8IDApIG1pbiA9IDA7XG4gICAgdmFyIG1heCA9IHN0YXJ0ICsgbWF4UmFuZ2U7XG4gICAgaWYobWF4ID4gbGVuKSBtYXggPSBsZW47XG5cbiAgICB2YXIgcmVtYWluID0gc3RyLnNsaWNlKG1pbiwgbWF4KTtcbiAgICB2YXIgcHJlZml4ID0gXCJbXCIgKyhudW0rMSkgKyBcIl0gXCIgKyAobWluID4gMD8gXCIuLlwiIDogXCJcIilcbiAgICB2YXIgcG9zdGZpeCA9IG1heCA8IGxlbiA/IFwiLi5cIjogXCJcIjtcbiAgICB2YXIgcmVzID0gcHJlZml4ICsgcmVtYWluICsgcG9zdGZpeDtcbiAgICBpZih0YXJnZXQpIHJlcyArPSBcIlxcblwiICsgbmV3IEFycmF5KHN0YXJ0LW1pbiArIHByZWZpeC5sZW5ndGggKyAxKS5qb2luKFwiIFwiKSArIFwiXl5eXCI7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIHBvcyl7XG4gICAgaWYocG9zID4gaW5wdXQubGVuZ3RoLTEpIHBvcyA9IGlucHV0Lmxlbmd0aC0xO1xuICAgIGxiLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQobGIpO1xuICAgIHZhciBsaW5lID0gZmluZExpbmUobGluZXMscG9zKTtcbiAgICB2YXIgc3RhcnQgPSBsaW5lLnN0YXJ0LCBudW0gPSBsaW5lLm51bTtcblxuICAgIHJldHVybiAobGluZS5wcmV2PyBmb3JtYXRMaW5lKGxpbmUucHJldiwgc3RhcnQsIG51bS0xICkgKyAnXFxuJzogJycgKSArIFxuICAgICAgZm9ybWF0TGluZShsaW5lLmxpbmUsIHN0YXJ0LCBudW0sIHRydWUpICsgJ1xcbicgKyBcbiAgICAgIChsaW5lLm5leHQ/IGZvcm1hdExpbmUobGluZS5uZXh0LCBzdGFydCwgbnVtKzEgKSArICdcXG4nOiAnJyApO1xuXG4gIH1cbn0pKCk7XG5cblxudmFyIGlnbm9yZWRSZWYgPSAvXFwoKFxcP1xcIXxcXD9cXDp8XFw/XFw9KS9nO1xuXy5maW5kU3ViQ2FwdHVyZSA9IGZ1bmN0aW9uIChyZWdTdHIpIHtcbiAgdmFyIGxlZnQgPSAwLFxuICAgIHJpZ2h0ID0gMCxcbiAgICBsZW4gPSByZWdTdHIubGVuZ3RoLFxuICAgIGlnbm9yZWQgPSByZWdTdHIubWF0Y2goaWdub3JlZFJlZik7IC8vIGlnbm9yZWQgdW5jYXB0dXJlXG4gIGlmKGlnbm9yZWQpIGlnbm9yZWQgPSBpZ25vcmVkLmxlbmd0aFxuICBlbHNlIGlnbm9yZWQgPSAwO1xuICBmb3IgKDsgbGVuLS07KSB7XG4gICAgdmFyIGxldHRlciA9IHJlZ1N0ci5jaGFyQXQobGVuKTtcbiAgICBpZiAobGVuID09PSAwIHx8IHJlZ1N0ci5jaGFyQXQobGVuIC0gMSkgIT09IFwiXFxcXFwiICkgeyBcbiAgICAgIGlmIChsZXR0ZXIgPT09IFwiKFwiKSBsZWZ0Kys7XG4gICAgICBpZiAobGV0dGVyID09PSBcIilcIikgcmlnaHQrKztcbiAgICB9XG4gIH1cbiAgaWYgKGxlZnQgIT09IHJpZ2h0KSB0aHJvdyBcIlJlZ0V4cDogXCIrIHJlZ1N0ciArIFwiJ3MgYnJhY2tldCBpcyBub3QgbWFyY2hlZFwiO1xuICBlbHNlIHJldHVybiBsZWZ0IC0gaWdub3JlZDtcbn07XG5cblxuXy5lc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiggc3RyKXsvLyBDcmVkaXQ6IFhSZWdFeHAgMC42LjEgKGMpIDIwMDctMjAwOCBTdGV2ZW4gTGV2aXRoYW4gPGh0dHA6Ly9zdGV2ZW5sZXZpdGhhbi5jb20vcmVnZXgveHJlZ2V4cC8+IE1JVCBMaWNlbnNlXG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxde30oKSorPy5cXFxcXiR8LCNcXHNdL2csIGZ1bmN0aW9uKG1hdGNoKXtcbiAgICByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7XG4gIH0pO1xufTtcblxuXG52YXIgckVudGl0eSA9IG5ldyBSZWdFeHAoXCImKD86KCN4WzAtOWEtZkEtRl0rKXwoI1swLTldKyl8KFwiICsgXy5rZXlzKGVudGl0aWVzKS5qb2luKCd8JykgKyAnKSk7JywgJ2dpJyk7XG5cbl8uY29udmVydEVudGl0eSA9IGZ1bmN0aW9uKGNocil7XG5cbiAgcmV0dXJuIChcIlwiICsgY2hyKS5yZXBsYWNlKHJFbnRpdHksIGZ1bmN0aW9uKGFsbCwgaGV4LCBkZWMsIGNhcHR1cmUpe1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICBpZiggZGVjICkgY2hhckNvZGUgPSBwYXJzZUludCggZGVjLnNsaWNlKDEpLCAxMCApO1xuICAgIGVsc2UgaWYoIGhleCApIGNoYXJDb2RlID0gcGFyc2VJbnQoIGhleC5zbGljZSgyKSwgMTYgKTtcbiAgICBlbHNlIGNoYXJDb2RlID0gZW50aXRpZXNbY2FwdHVyZV1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaGFyQ29kZSApXG4gIH0pO1xuXG59XG5cblxuLy8gc2ltcGxlIGdldCBhY2Nlc3NvclxuXG5fLmNyZWF0ZU9iamVjdCA9IE9iamVjdC5jcmVhdGU/IGZ1bmN0aW9uKG8pe1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShvIHx8IG51bGwpXG59OiAoZnVuY3Rpb24oKXtcbiAgICBmdW5jdGlvbiBUZW1wKCkge31cbiAgICByZXR1cm4gZnVuY3Rpb24obyl7XG4gICAgICBpZighbykgcmV0dXJuIHt9XG4gICAgICBUZW1wLnByb3RvdHlwZSA9IG87XG4gICAgICB2YXIgb2JqID0gbmV3IFRlbXAoKTtcbiAgICAgIFRlbXAucHJvdG90eXBlID0gbnVsbDsgLy8g5LiN6KaB5L+d5oyB5LiA5LiqIE8g55qE5p2C5pWj5byV55So77yIYSBzdHJheSByZWZlcmVuY2XvvIkuLi5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG59KSgpO1xuXG5fLmNyZWF0ZVByb3RvID0gZnVuY3Rpb24oZm4sIG8pe1xuICAgIGZ1bmN0aW9uIEZvbygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGZuO31cbiAgICBGb28ucHJvdG90eXBlID0gbztcbiAgICByZXR1cm4gKGZuLnByb3RvdHlwZSA9IG5ldyBGb28oKSk7XG59XG5cblxuXy5yZW1vdmVPbmUgPSBmdW5jdGlvbihsaXN0ICwgZmlsdGVyKXtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBmb3IoO2xlbi0tOyl7XG4gICAgaWYoZmlsdGVyKGxpc3RbbGVuXSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGxlbiwgMSlcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbmNsb25lXG4qL1xuXy5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iail7XG4gIGlmKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICkpIHJldHVybiBvYmo7XG4gIGlmKEFycmF5LmlzQXJyYXkob2JqKSl7XG4gICAgdmFyIGNsb25lZCA9IFtdO1xuICAgIGZvcih2YXIgaT0wLGxlbiA9IG9iai5sZW5ndGg7IGk8IGxlbjtpKyspe1xuICAgICAgY2xvbmVkW2ldID0gb2JqW2ldXG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1lbHNle1xuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBmb3IodmFyIGkgaW4gb2JqKSBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpe1xuICAgICAgY2xvbmVkW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59XG5cbl8uZXF1YWxzID0gZnVuY3Rpb24obm93LCBvbGQpe1xuICB2YXIgdHlwZSA9IHR5cGVvZiBub3c7XG4gIGlmKHR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvbGQgPT09ICdudW1iZXInJiYgaXNOYU4obm93KSAmJiBpc05hTihvbGQpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gbm93ID09PSBvbGQ7XG59XG5cbnZhciBkYXNoID0gLy0oW2Etel0pL2c7XG5fLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZShkYXNoLCBmdW5jdGlvbihhbGwsIGNhcHR1cmUpe1xuICAgIHJldHVybiBjYXB0dXJlLnRvVXBwZXJDYXNlKCk7XG4gIH0pXG59XG5cblxuXG5fLnRocm90dGxlID0gZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCl7XG4gIHZhciB3YWl0ID0gd2FpdCB8fCAxMDA7XG4gIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcHJldmlvdXMgPSArbmV3IERhdGU7XG4gICAgdGltZW91dCA9IG51bGw7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm93ID0gKyBuZXcgRGF0ZTtcbiAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG4vLyBob2dhbiBlc2NhcGVcbi8vID09PT09PT09PT09PT09XG5fLmVzY2FwZSA9IChmdW5jdGlvbigpe1xuICB2YXIgckFtcCA9IC8mL2csXG4gICAgICByTHQgPSAvPC9nLFxuICAgICAgckd0ID0gLz4vZyxcbiAgICAgIHJBcG9zID0gL1xcJy9nLFxuICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgaENoYXJzID0gL1smPD5cXFwiXFwnXS87XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBoQ2hhcnMudGVzdChzdHIpID9cbiAgICAgIHN0clxuICAgICAgICAucmVwbGFjZShyQW1wLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZShyTHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2Uockd0LCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKHJBcG9zLCAnJiMzOTsnKVxuICAgICAgICAucmVwbGFjZShyUXVvdCwgJyZxdW90OycpIDpcbiAgICAgIHN0cjtcbiAgfVxufSkoKTtcblxuXy5jYWNoZSA9IGZ1bmN0aW9uKG1heCl7XG4gIG1heCA9IG1heCB8fCAxMDAwO1xuICB2YXIga2V5cyA9IFtdLFxuICAgICAgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIGNhY2hlW2tleXMuc2hpZnQoKV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAvLyBcbiAgICAgIGlmKGNhY2hlW2tleV0gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgY2FjaGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNhY2hlO1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgfSxcbiAgICBtYXg6IG1heCxcbiAgICBsZW46ZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICB9XG4gIH07XG59XG5cbi8vIC8vIHNldHVwIHRoZSByYXcgRXhwcmVzc2lvblxuXG5cbi8vIGhhbmRsZSB0aGUgc2FtZSBsb2dpYyBvbiBjb21wb25lbnQncyBgb24tKmAgYW5kIGVsZW1lbnQncyBgb24tKmBcbi8vIHJldHVybiB0aGUgZmlyZSBvYmplY3Rcbl8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSApe1xuICB2YXIgc2VsZiA9IHRoaXMsIGV2YWx1YXRlO1xuICBpZih2YWx1ZS50eXBlID09PSAnZXhwcmVzc2lvbicpeyAvLyBpZiBpcyBleHByZXNzaW9uLCBnbyBldmFsdWF0ZWQgd2F5XG4gICAgZXZhbHVhdGUgPSB2YWx1ZS5nZXQ7XG4gIH1cbiAgaWYoZXZhbHVhdGUpe1xuICAgIHJldHVybiBmdW5jdGlvbiBmaXJlKG9iail7XG4gICAgICBzZWxmLiR1cGRhdGUoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGRhdGEuJGV2ZW50ID0gb2JqO1xuICAgICAgICB2YXIgcmVzID0gZXZhbHVhdGUoc2VsZik7XG4gICAgICAgIGlmKHJlcyA9PT0gZmFsc2UgJiYgb2JqICYmIG9iai5wcmV2ZW50RGVmYXVsdCkgb2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuJGV2ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSlcblxuICAgIH1cbiAgfWVsc2V7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpcmUoKXtcbiAgICAgIHZhciBhcmdzID0gXy5zbGljZShhcmd1bWVudHMpO1xuICAgICAgYXJncy51bnNoaWZ0KHZhbHVlKTtcbiAgICAgIHNlbGYuJHVwZGF0ZShmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLiRlbWl0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSBjYWxsIG9uY2Vcbl8ub25jZSA9IGZ1bmN0aW9uKGZuKXtcbiAgdmFyIHRpbWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBpZiggdGltZSsrID09PSAwKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbl8uZml4T2JqU3RyID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYoc3RyLnRyaW0oKS5pbmRleE9mKCd7JykgIT09IDApe1xuICAgIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5fLm1hcD0gZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrKXtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXMucHVzaChjYWxsYmFjayhhcnJheVtpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2csIHR5cGUpe1xuICBpZih0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgIGNvbnNvbGVbdHlwZSB8fCBcImxvZ1wiXShtc2cpO1xufVxuXG5fLmxvZyA9IGxvZztcblxuXG5fLm5vcm1MaXN0ZW5lciA9IGZ1bmN0aW9uKCBldmVudHMgICl7XG4gICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdmFyIHBUeXBlID0gXy50eXBlT2YoIGV2ZW50cyApO1xuICAgIGlmKCBwVHlwZSA9PT0gJ2FycmF5JyApe1xuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9ZWxzZSBpZiAoIHBUeXBlID09PSAnb2JqZWN0JyApe1xuICAgICAgZm9yKCB2YXIgaSBpbiBldmVudHMgKSBpZiAoIGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShpKSApe1xuICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpLFxuICAgICAgICAgIGxpc3RlbmVyOiBldmVudHNbaV1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJzO1xufVxuXG5cbi8vaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc2luZ2xlLXBhZ2UuaHRtbCN2b2lkLWVsZW1lbnRzXG5fLmlzVm9pZFRhZyA9IF8ubWFrZVByZWRpY2F0ZShcImFyZWEgYmFzZSBiciBjb2wgZW1iZWQgaHIgaW1nIGlucHV0IGtleWdlbiBsaW5rIG1lbnVpdGVtIG1ldGEgcGFyYW0gc291cmNlIHRyYWNrIHdiciByLWNvbnRlbnRcIik7XG5fLmlzQm9vbGVhbkF0dHIgPSBfLm1ha2VQcmVkaWNhdGUoJ3NlbGVjdGVkIGNoZWNrZWQgZGlzYWJsZWQgcmVhZG9ubHkgcmVxdWlyZWQgb3BlbiBhdXRvZm9jdXMgY29udHJvbHMgYXV0b3BsYXkgY29tcGFjdCBsb29wIGRlZmVyIG11bHRpcGxlJyk7XG5cblxuXy5pc0V4cHIgPSBmdW5jdGlvbihleHByKXtcbiAgcmV0dXJuIGV4cHIgJiYgZXhwci50eXBlID09PSAnZXhwcmVzc2lvbic7XG59XG4vLyBAVE9ETzogbWFrZSBpdCBtb3JlIHN0cmljdFxuXy5pc0dyb3VwID0gZnVuY3Rpb24oZ3JvdXApe1xuICByZXR1cm4gZ3JvdXAuaW5qZWN0IHx8IGdyb3VwLiRpbmplY3Q7XG59XG5cbl8uYmxhbmtSZWcgPSAvXFxzKy87IFxuXG5fLmdldENvbXBpbGVGbiA9IGZ1bmN0aW9uKHNvdXJjZSwgY3R4LCBvcHRpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBwYXNzZWRPcHRpb25zICl7XG4gICAgaWYoIHBhc3NlZE9wdGlvbnMgJiYgb3B0aW9ucyApIF8uZXh0ZW5kKCBwYXNzZWRPcHRpb25zICwgb3B0aW9ucyApO1xuICAgIGVsc2UgcGFzc2VkT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGN0eC4kY29tcGlsZShzb3VyY2UsIHBhc3NlZE9wdGlvbnMgKVxuICB9XG4gIHJldHVybiBjdHguJGNvbXBpbGUuYmluZChjdHgsc291cmNlLCBvcHRpb25zKVxufVxuXG4vLyByZW1vdmUgZGlyZWN0aXZlIHBhcmFtIGZyb20gQVNUXG5fLmZpeFRhZ0FTVCA9IGZ1bmN0aW9uKCB0YWdBU1QsIENvbXBvbmVudCApe1xuXG4gIGlmKCB0YWdBU1QudG91Y2hlZCApIHJldHVybjtcblxuICB2YXIgYXR0cnMgPSB0YWdBU1QuYXR0cnM7XG5cbiAgaWYoICFhdHRycyApIHJldHVybjtcblxuICAvLyBNYXliZSBtdWx0aXBsZSBkaXJlY3RpdmUgbmVlZCBzYW1lIHBhcmFtLCBcbiAgLy8gV2UgcGxhY2UgYWxsIHBhcmFtIGluIHRvdGFsUGFyYW1NYXBcbiAgdmFyIGxlbiA9IGF0dHJzLmxlbmd0aDtcbiAgaWYoIWxlbikgcmV0dXJuO1xuICB2YXIgZGlyZWN0aXZlcz1bXSwgb3RoZXJBdHRyTWFwID0ge307XG4gIGZvcig7bGVuLS07KXtcblxuICAgIHZhciBhdHRyID0gYXR0cnNbIGxlbiBdO1xuXG5cbiAgICAvLyBASUUgZml4IElFOS0gaW5wdXQgdHlwZSBjYW4ndCBhc3NpZ24gYWZ0ZXIgdmFsdWVcbiAgICBpZihhdHRyLm5hbWUgPT09ICd0eXBlJykgYXR0ci5wcmlvcml0eSA9IE1BWF9QUklPUklUWSArIDE7XG5cbiAgICB2YXIgZGlyZWN0aXZlID0gQ29tcG9uZW50LmRpcmVjdGl2ZSggYXR0ci5uYW1lICk7XG4gICAgaWYoIGRpcmVjdGl2ZSApIHtcblxuICAgICAgYXR0ci5wcmlvcml0eSA9IGRpcmVjdGl2ZS5wcmlvcml0eSB8fCAxO1xuICAgICAgYXR0ci5kaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgZGlyZWN0aXZlcy5wdXNoKGF0dHIpO1xuXG4gICAgfWVsc2UgaWYoYXR0ci50eXBlID09PSAnYXR0cmlidXRlJyl7XG4gICAgICBvdGhlckF0dHJNYXBbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGlyZWN0aXZlcy5mb3JFYWNoKCBmdW5jdGlvbiggYXR0ciApe1xuICAgIHZhciBkaXJlY3RpdmUgPSBDb21wb25lbnQuZGlyZWN0aXZlKGF0dHIubmFtZSk7XG4gICAgdmFyIHBhcmFtID0gZGlyZWN0aXZlLnBhcmFtO1xuICAgIGlmKHBhcmFtICYmIHBhcmFtLmxlbmd0aCl7XG4gICAgICBhdHRyLnBhcmFtID0ge307XG4gICAgICBwYXJhbS5mb3JFYWNoKGZ1bmN0aW9uKCBuYW1lICl7XG4gICAgICAgIGlmKCBuYW1lIGluIG90aGVyQXR0ck1hcCApe1xuICAgICAgICAgIGF0dHIucGFyYW1bbmFtZV0gPSBvdGhlckF0dHJNYXBbbmFtZV0gPT09IHVuZGVmaW5lZD8gdHJ1ZTogb3RoZXJBdHRyTWFwW25hbWVdXG4gICAgICAgICAgXy5yZW1vdmVPbmUoYXR0cnMsIGZ1bmN0aW9uKGF0dHIpe1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KTtcblxuICBhdHRycy5zb3J0KGZ1bmN0aW9uKGExLCBhMil7XG4gICAgXG4gICAgdmFyIHAxID0gYTEucHJpb3JpdHk7XG4gICAgdmFyIHAyID0gYTIucHJpb3JpdHk7XG5cbiAgICBpZiggcDEgPT0gbnVsbCApIHAxID0gTUFYX1BSSU9SSVRZO1xuICAgIGlmKCBwMiA9PSBudWxsICkgcDIgPSBNQVhfUFJJT1JJVFk7XG5cbiAgICByZXR1cm4gcDIgLSBwMTtcblxuICB9KVxuXG4gIHRhZ0FTVC50b3VjaGVkID0gdHJ1ZTtcbn1cblxuXy5maW5kSXRlbSA9IGZ1bmN0aW9uKGxpc3QsIGZpbHRlcil7XG4gIGlmKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlKGxlbi0tKXtcbiAgICBpZihmaWx0ZXIobGlzdFtsZW5dKSkgcmV0dXJuIGxpc3RbbGVuXVxuICB9XG59XG5cbl8uZ2V0UGFyYW1PYmogPSBmdW5jdGlvbihjb21wb25lbnQsIHBhcmFtKXtcbiAgdmFyIHBhcmFtT2JqID0ge307XG4gIGlmKHBhcmFtKSB7XG4gICAgZm9yKHZhciBpIGluIHBhcmFtKSBpZihwYXJhbS5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbVtpXTtcbiAgICAgIHBhcmFtT2JqW2ldID0gIHZhbHVlICYmIHZhbHVlLnR5cGU9PT0nZXhwcmVzc2lvbic/IGNvbXBvbmVudC4kZ2V0KHZhbHVlKTogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbU9iajtcbn1cbl8uZXZlbnRSZWcgPSAvXm9uLShcXHdbLVxcd10rKSQvO1xuXG5fLnRvVGV4dCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBvYmogPT0gbnVsbCA/IFwiXCI6IFwiXCIgKyBvYmo7XG59XG5cblxuLy8gaG9nYW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2l0dGVyL2hvZ2FuLmpzXG4vLyBNSVRcbl8uZXNjYXBlID0gKGZ1bmN0aW9uKCl7XG4gIHZhciByQW1wID0gLyYvZyxcbiAgICAgIHJMdCA9IC88L2csXG4gICAgICByR3QgPSAvPi9nLFxuICAgICAgckFwb3MgPSAvXFwnL2csXG4gICAgICByUXVvdCA9IC9cXFwiL2csXG4gICAgICBoQ2hhcnMgPSAvWyY8PlxcXCJcXCddLztcblxuICBmdW5jdGlvbiBpZ25vcmVOdWxsVmFsKHZhbCkge1xuICAgIHJldHVybiBTdHJpbmcoKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PSBudWxsKSA/ICcnIDogdmFsKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgc3RyID0gaWdub3JlTnVsbFZhbChzdHIpO1xuICAgIHJldHVybiBoQ2hhcnMudGVzdChzdHIpID9cbiAgICAgIHN0clxuICAgICAgICAucmVwbGFjZShyQW1wLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZShyTHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2Uockd0LCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKHJBcG9zLCAnJiMzOTsnKVxuICAgICAgICAucmVwbGFjZShyUXVvdCwgJyZxdW90OycpIDpcbiAgICAgIHN0cjtcbiAgfVxuXG59KSgpO1xuXG5cblxuXG5cblxuXG4iXX0=
},{"./config":50,"./helper/entities":63,"./helper/shim":68}],78:[function(require,module,exports){
var diffArray = require('./helper/diff').diffArray;
var combine = require('./helper/combine');
var animate = require("./helper/animate");
var Parser = require('./parser/Parser');
var node = require("./parser/node");
var Group = require('./group');
var dom = require("./dom");
var _ = require('./util');
var consts = require('./const');
var OPTIONS = consts.OPTIONS;
var ERROR = consts.ERROR;
var MSG = consts.MSG;
var nodeCursor = require('./helper/cursor');
var config = require('./config')
var shared = require('./render/shared');



var walkers = module.exports = {};



// used in walkers.list
// remove block in group
function removeRange(index, rlen, children){
  for(var j = 1; j <= rlen; j++){ //removed
    var removed = children[ index + j ];
    if(removed) removed.destroy(true);
  }
  children.splice(index+1, rlen);
}


walkers.list = function(ast, options){

  var Regular = walkers.Regular;  
  var placeholder = document.createComment("Regular list"),
    namespace = options.namespace,
    extra = options.extra;

  var self = this;
  var group = new Group([placeholder]);
  var children = group.children;

  var indexName = ast.variable + '_index';
  var keyName = ast.variable + '_key';
  var variable = ast.variable;
  var alternate = ast.alternate;
  var track = ast.track, keyOf, extraObj;
  var cursor = options.cursor;

  if( track && track !== true ){
    
    track = this._touchExpr(track);
    extraObj = _.createObject(extra);
    keyOf = function( item, index ){
      extraObj[ variable ] = item;
      extraObj[ indexName ] = index;
      // @FIX keyName
      return track.get( self, extraObj );
    }
  }

  function addRange(index, end, newList, rawNewValue){
    for(var o = index; o < end; o++){ //add
      // prototype inherit
      var item = newList[o];
      var data = _.createObject(extra);
      updateTarget(data, o, item, rawNewValue);

      var section = self.$compile(ast.body, {
        extra: data,
        namespace:namespace,
        record: true,
        outer: options.outer,
        cursor: cursor
      })
      section.data = data;
      // autolink
      var insert =  combine.last(group.get(o));
      if(insert.parentNode && !(cursor && cursor.node) ){
        animate.inject(combine.node(section),insert, 'after');
      }
      // insert.parentNode.insertBefore(combine.node(section), insert.nextSibling);
      children.splice( o + 1 , 0, section);
    }
  }

  function updateTarget(target, index, item, rawNewValue){
      target[ indexName ] = index;
      if( rawNewValue ){
        target[ keyName ] = item;
        target[ variable ] = rawNewValue[ item ];
      }else{
        target[ variable ] = item;
        target[keyName] = null
      }
  }


  function updateRange(start, end, newList, rawNewValue){
    for(var k = start; k < end; k++){ // no change
      var sect = group.get( k + 1 ), item = newList[ k ];
      updateTarget(sect.data, k, item, rawNewValue);
    }
  }

  function updateLD(newList, oldList, splices , rawNewValue ){

    var cur = placeholder;
    var m = 0, len = newList.length;

    if(!splices && (len !==0 || oldList.length !==0)  ){
      splices = diffArray(newList, oldList, true);
    }

    if(!splices || !splices.length) return;
      
    for(var i = 0; i < splices.length; i++){ //init
      var splice = splices[i];
      var index = splice.index; // beacuse we use a comment for placeholder
      var removed = splice.removed;
      var add = splice.add;
      var rlen = removed.length;
      // for track
      if( track && rlen && add ){
        var minar = Math.min(rlen, add);
        var tIndex = 0;
        while(tIndex < minar){
          if( keyOf(newList[index], index) !== keyOf( removed[0], index ) ){
            removeRange(index, 1, children)
            addRange(index, index+1, newList, rawNewValue)
          }
          removed.shift();
          add--;
          index++;
          tIndex++;
        }
        rlen = removed.length;
      }
      // update
      updateRange(m, index, newList, rawNewValue);

      removeRange( index ,rlen, children)

      addRange(index, index+add, newList, rawNewValue)

      m = index + add - rlen;
      m  = m < 0? 0 : m;

    }
    if(m < len){
      for(var i = m; i < len; i++){
        var pair = group.get(i + 1);
        pair.data[indexName] = i;
        // @TODO fix keys
      }
    }
  }

  // if the track is constant test.
  function updateSimple(newList, oldList, rawNewValue ){

    var nlen = newList.length;
    var olen = oldList.length;
    var mlen = Math.min(nlen, olen);

    updateRange(0, mlen, newList, rawNewValue)
    if(nlen < olen){ //need add
      removeRange(nlen, olen-nlen, children);
    }else if(nlen > olen){
      addRange(olen, nlen, newList, rawNewValue);
    }
  }

  function update(newValue, oldValue, splices){

    var nType = _.typeOf( newValue );
    var oType = _.typeOf( oldValue );

    var newList = getListFromValue( newValue, nType );
    var oldList = getListFromValue( oldValue, oType );

    var rawNewValue;


    var nlen = newList && newList.length;
    var olen = oldList && oldList.length;

    // if previous list has , we need to remove the altnated section.
    if( !olen && nlen && group.get(1) ){
      var altGroup = children.pop();
      if(altGroup.destroy)  altGroup.destroy(true);
    }

    if( nType === 'object' ) rawNewValue = newValue;

    if(track === true){
      updateSimple( newList, oldList,  rawNewValue );
    }else{
      updateLD( newList, oldList, splices, rawNewValue );
    }

    // @ {#list} {#else}
    if( !nlen && alternate && alternate.length){
      var section = self.$compile(alternate, {
        extra: extra,
        record: true,
        outer: options.outer,
        namespace: namespace
      })
      children.push(section);
      if(placeholder.parentNode){
        animate.inject(combine.node(section), placeholder, 'after');
      }
    }
  }

  this.$watch(ast.sequence, update, { 
    init: true, 
    diff: track !== true ,
    deep: true
  });
  //@FIXIT, beacuse it is sync process, we can 
  cursor = null;
  return group;
}



// {#include } or {#inc template}
walkers.template = function(ast, options){
  var content = ast.content, compiled;
  var placeholder = document.createComment('inlcude');
  var compiled, namespace = options.namespace, extra = options.extra;
  var group = new Group([placeholder]);
  var cursor = options.cursor;

  if(content){
    var self = this;
    this.$watch(content, function(value){
      var removed = group.get(1), type= typeof value;
      if( removed){
        removed.destroy(true); 
        group.children.pop();
      }
      if(!value) return;

      group.push( compiled = type === 'function' ? value(cursor? {cursor: cursor}: null): self.$compile( type !== 'object'? String(value): value, {
        record: true,
        outer: options.outer,
        namespace: namespace,
        cursor: cursor,
        extra: extra}) ); 
      if(placeholder.parentNode) {
        compiled.$inject(placeholder, 'before')
      }
    }, OPTIONS.INIT);
  }
  return group;
};

function getListFromValue(value, type){
  return type === 'array'? value: (type === 'object'? _.keys(value) :  []);
}


// how to resolve this problem
var ii = 0;
walkers['if'] = function(ast, options){
  var self = this, consequent, alternate, extra = options.extra;
  if(options && options.element){ // attribute inteplation
    var update = function(nvalue){
      if(!!nvalue){
        if(alternate) combine.destroy(alternate)
        if(ast.consequent) consequent = self.$compile(ast.consequent, {
          record: true, 
          element: options.element , 
          extra:extra
        });
      }else{
        if( consequent ) combine.destroy(consequent)
        if( ast.alternate ) alternate = self.$compile(ast.alternate, {record: true, element: options.element, extra: extra});
      }
    }
    this.$watch(ast.test, update, OPTIONS.FORCE);
    return {
      destroy: function(){
        if(consequent) combine.destroy(consequent);
        else if(alternate) combine.destroy(alternate);
      }
    }
  }

  var test, node;
  var placeholder = document.createComment("Regular if" + ii++);
  var group = new Group();
  group.push(placeholder);
  var preValue = null, namespace= options.namespace;
  var cursor = options.cursor;
  if(cursor && cursor.node){
    dom.inject( placeholder , cursor.node,'before')
  }


  var update = function (nvalue, old){
    var value = !!nvalue, compiledSection;
    if(value === preValue) return;
    preValue = value;
    if(group.children[1]){
      group.children[1].destroy(true);
      group.children.pop();
    }
    var curOptions = {
      record: true, 
      outer: options.outer,
      namespace: namespace, 
      extra: extra,
      cursor: cursor
    }
    if(value){ //true

      if(ast.consequent && ast.consequent.length){ 
        compiledSection = self.$compile( ast.consequent , curOptions );
      }
    }else{ //false
      if(ast.alternate && ast.alternate.length){
        compiledSection = self.$compile(ast.alternate, curOptions);
      }
    }
    // placeholder.parentNode && placeholder.parentNode.insertBefore( node, placeholder );
    if(compiledSection){
      group.push(compiledSection);
      if(placeholder.parentNode){
        animate.inject(combine.node(compiledSection), placeholder, 'before');
      }
    }
    cursor = null;
    // after first mount , we need clear this flat;
  }
  this.$watch(ast.test, update, OPTIONS.FORCE_INIT);

  return group;
}


walkers._handleMountText = function(cursor, astText){
    var node, mountNode = cursor.node;
    // fix unused black in astText;
    var nodeText = dom.text(mountNode);

    if( nodeText === astText ){
      node = mountNode;
      cursor.next();
    }else{
      // maybe have some redundancy  blank
      var index = nodeText.indexOf(astText);
      if(~index){
        node = document.createTextNode(astText);
        dom.text( mountNode, nodeText.slice(index + astText.length) );
      } else {
        // if( _.blankReg.test( astText ) ){ }
        throw Error( MSG[ERROR.UNMATCHED_AST]);
      }
    }

    return node;
}


walkers.expression = function(ast, options){

  var cursor = options.cursor, node,
    mountNode = cursor && cursor.node;

  if(mountNode){
    //@BUG: if server render &gt; in Expression will cause error
    var astText = _.toText( this.$get(ast) );

    node = walkers._handleMountText(cursor, astText);

  }else{
    node = document.createTextNode("");
  }

  this.$watch(ast, function(newval){
    dom.text(node, _.toText(newval));
  }, OPTIONS.STABLE_INIT )
  return node;

}


walkers.text = function(ast, options){
  var cursor = options.cursor , node;
  var text = ast.text;
  var astText = text.indexOf('&') !== -1? _.convertEntity(text): text;

  if(cursor && cursor.node) { 
    var mountNode = cursor.node;
    // maybe regularjs parser have some difference with html builtin parser when process  empty text
    // @todo error report
    if(mountNode.nodeType !== 3 ){

      if( _.blankReg.test(astText) ) return {
        code:  ERROR.UNMATCHED_AST
      }

    }else{
      node = walkers._handleMountText( cursor, astText )
    } 
  }
      

  return node || document.createTextNode( astText );
}




/**
 * walkers element (contains component)
 */
walkers.element = function(ast, options){

  var attrs = ast.attrs, self = this,
    Constructor = this.constructor,
    children = ast.children,
    namespace = options.namespace, 
    extra = options.extra,
    cursor = options.cursor,
    tag = ast.tag,
    Component = Constructor.component(tag),
    ref, group, element, mountNode;

  // if inititalized with mount mode, sometime, 
  // browser will ignore the whitespace between node, and sometimes it won't
  if(cursor){
    // textCOntent with Empty text
    if(cursor.node && cursor.node.nodeType === 3){
      if(_.blankReg.test(dom.text(cursor.node) ) ) cursor.next();
      else throw Error(MSG[ERROR.UNMATCHED_AST]);
    }
  }

  if(cursor) mountNode = cursor.node;

  if( tag === 'r-content' ){
    _.log('r-content is deprecated, use {#inc this.$body} instead (`{#include}` as same)', 'warn');
    return this.$body && this.$body(cursor? {cursor: cursor}: null);
  } 

  if(Component || tag === 'r-component'){
    options.Component = Component;
    return walkers.component.call(this, ast, options)
  }

  if(tag === 'svg') namespace = "svg";
  // @Deprecated: may be removed in next version, use {#inc } instead
  
  if( children && children.length ){

    var subMountNode = mountNode? mountNode.firstChild: null;
    group = this.$compile(children, {
      extra: extra ,
      outer: options.outer,
      namespace: namespace, 
      cursor:  subMountNode? nodeCursor(subMountNode): null
    });
  }


  if(mountNode){
    element = mountNode
    cursor.next();
  }else{
    element = dom.create( tag, namespace, attrs);
  }
  

  if(group && !_.isVoidTag(tag) ){ // if not init with mount mode
    animate.inject( combine.node(group) , element)
  }

  // fix tag ast, some infomation only avaliable at runtime (directive etc..)
  _.fixTagAST(ast, Constructor)

  var destroies = walkAttributes.call(this, attrs, element, extra);

  return {
    type: "element",
    group: group,
    node: function(){
      return element;
    },
    last: function(){
      return element;
    },
    destroy: function(first){
      if( first ){
        animate.remove( element, group? group.destroy.bind( group ): _.noop );
      }else if(group) {
        group.destroy();
      }
      // destroy ref
      if( destroies.length ) {
        destroies.forEach(function( destroy ){
          if( destroy ){
            if( typeof destroy.destroy === 'function' ){
              destroy.destroy()
            }else{
              destroy();
            }
          }
        })
      }
    }
  }
}

walkers.component = function(ast, options){
  var attrs = ast.attrs, 
    Component = options.Component,
    cursor = options.cursor,
    Constructor = this.constructor,
    isolate, 
    extra = options.extra,
    namespace = options.namespace,
    refDirective = walkers.Regular.directive('ref'),
    ref, self = this, is;

  var data = {}, events;

  for(var i = 0, len = attrs.length; i < len; i++){
    var attr = attrs[i];
    // consider disabled   equlasto  disabled={true}

    shared.prepareAttr( attr, attr.name === 'ref' && refDirective );

    var value = this._touchExpr(attr.value === undefined? true: attr.value);
    if(value.constant) value = attr.value = value.get(this);
    if(attr.value && attr.value.constant === true){
      value = value.get(this);
    }
    var name = attr.name;
    if(!attr.event){
      var etest = name.match(_.eventReg);
      // event: 'nav'
      if(etest) attr.event = etest[1];
    }

    // @compile modifier
    if(attr.mdf === 'cmpl'){
      value = _.getCompileFn(value, this, {
        record: true, 
        namespace:namespace, 
        extra: extra, 
        outer: options.outer
      })
    }
    
    // @if is r-component . we need to find the target Component
    if(name === 'is' && !Component){
      is = value;
      var componentName = this.$get(value, true);
      Component = Constructor.component(componentName)
      if(typeof Component !== 'function') throw new Error("component " + componentName + " has not registed!");
    }
    // bind event proxy
    var eventName;
    if(eventName = attr.event){
      events = events || {};
      events[eventName] = _.handleEvent.call(this, value, eventName);
      continue;
    }else {
      name = attr.name = _.camelCase(name);
    }

    if(!value || value.type !== 'expression'){
      data[name] = value;
    }else{
      data[name] = value.get(self); 
    }
    if( name === 'ref'  && value != null){
      ref = value
    }
    if( name === 'isolate'){
      // 1: stop: composite -> parent
      // 2. stop: composite <- parent
      // 3. stop 1 and 2: composite <-> parent
      // 0. stop nothing (defualt)
      isolate = value.type === 'expression'? value.get(self): parseInt(value === true? 3: value, 10);
      data.isolate = isolate;
    }
  }

  var definition = { 
    data: data, 
    events: events, 
    $parent: (isolate & 2)? null: this,
    $root: this.$root,
    $outer: options.outer,
    _body: {
      ctx: this,
      ast: ast.children
    }
  }
  var options = {
    namespace: namespace, 
    cursor: cursor,
    extra: options.extra
  }


  var component = new Component(definition, options), reflink;


  if(ref && this.$refs){
    reflink = refDirective.link;
    var refDestroy = reflink.call(this, component, ref);
    component.$on('$destroy', refDestroy);
  }
  for(var i = 0, len = attrs.length; i < len; i++){
    var attr = attrs[i];
    var value = attr.value||true;
    var name = attr.name;
    // need compiled
    if(value.type === 'expression' && !attr.event){
      value = self._touchExpr(value);
      // use bit operate to control scope
      if( !(isolate & 2) ) 
        this.$watch(value, (function(name, val){
          this.data[name] = val;
        }).bind(component, name), OPTIONS.SYNC)
      if( value.set && !(isolate & 1 ) ) 
        // sync the data. it force the component don't trigger attr.name's first dirty echeck
        component.$watch(name, self.$update.bind(self, value), OPTIONS.INIT);
    }
  }
  if(is && is.type === 'expression'  ){
    var group = new Group();
    group.push(component);
    this.$watch(is, function(value){
      // found the new component
      var Component = Constructor.component(value);
      if(!Component) throw new Error("component " + value + " has not registed!");
      var ncomponent = new Component(definition);
      var component = group.children.pop();
      group.push(ncomponent);
      ncomponent.$inject(combine.last(component), 'after')
      component.destroy();
      // @TODO  if component changed , we need update ref
      if(ref){
        self.$refs[ref] = ncomponent;
      }
    }, OPTIONS.SYNC)
    return group;
  }
  return component;
}

function walkAttributes(attrs, element, extra){
  var bindings = []
  for(var i = 0, len = attrs.length; i < len; i++){
    var binding = this._walk(attrs[i], {element: element, fromElement: true, attrs: attrs, extra: extra})
    if(binding) bindings.push(binding);
  }
  return bindings;
}


walkers.attribute = function(ast ,options){

  var attr = ast;
  var Component = this.constructor;
  var name = attr.name;
  var directive = Component.directive(name);

  shared.prepareAttr(ast, directive);

  var value = attr.value || "";
  var constant = value.constant;
  var element = options.element;
  var self = this;



  value = this._touchExpr(value);

  if(constant) value = value.get(this);

  if(directive && directive.link){
    var extra = {
      attrs: options.attrs,
      param: _.getParamObj(this, attr.param) 
    }
    var binding = directive.link.call(self, element, value, name, extra);
    // if update has been passed in , we will  automately watch value for user
    if( typeof directive.update === 'function'){
      if(_.isExpr(value)){
        this.$watch(value, function(val, old){
          directive.update.call(self, element, val, old, extra); 
        })
      }else{
        directive.update.call(self, element, value, undefined, extra );
      }
    }
    if(typeof binding === 'function') binding = {destroy: binding}; 
    return binding;
  } else{
    if(value.type === 'expression' ){
      this.$watch(value, function(nvalue, old){
        dom.attr(element, name, nvalue);
      }, OPTIONS.STABLE_INIT);
    }else{
      if(_.isBooleanAttr(name)){
        dom.attr(element, name, true);
      }else{
        dom.attr(element, name, value);
      }
    }
    if(!options.fromElement){
      return {
        destroy: function(){
          dom.attr(element, name, null);
        }
      }
    }
  }

}



},{"./config":50,"./const":51,"./dom":56,"./group":58,"./helper/animate":59,"./helper/combine":60,"./helper/cursor":61,"./helper/diff":62,"./parser/Parser":73,"./parser/node":74,"./render/shared":76,"./util":77}],79:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2015
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var context = this

  if ('window' in context) {
    var doc = document
      , byTag = 'getElementsByTagName'
      , head = doc[byTag]('head')[0]
  } else {
    var XHR2
    try {
      XHR2 = require('xhr2')
    } catch (ex) {
      throw new Error('Peer dependency `xhr2` required! Please npm install xhr2')
    }
  }


  var httpsRe = /^http/
    , protocolRe = /(^\w+):\/\//
    , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = context[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (context[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (context[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else if (XHR2) {
          return new XHR2()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function succeed(r) {
    var protocol = protocolRe.exec(r.url)
    protocol = (protocol && protocol[1]) || context.location.protocol
    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response
  }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (succeed(r)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    var isAFormData = typeof FormData !== 'undefined' && (o['data'] instanceof FormData);
    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    context[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (context[xDomainRequest] && http instanceof context[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header === null) return undefined; //In case of no content-type.
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        timedOut()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = context.JSON ? context.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function timedOut() {
      self._timedOut = true
      self.request.abort()
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  , 'catch': function (fn) {
      return this.fail(fn)
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{"xhr2":43}],80:[function(require,module,exports){

var win = window, 
  doc = document;

var b = module.exports = {
  hash: "onhashchange" in win && (!doc.documentMode || doc.documentMode > 7),
  history: win.history && "onpopstate" in win,
  location: win.location,
  getHref: function(node){
    return "href" in node ? node.getAttribute("href", 2) : node.getAttribute("href");
  },
  on: "addEventListener" in win ?  // IE10 attachEvent is not working when binding the onpopstate, so we need check addEventLister first
      function(node,type,cb){return node.addEventListener( type, cb )}
    : function(node,type,cb){return node.attachEvent( "on" + type, cb )},
    
  off: "removeEventListener" in win ? 
      function(node,type,cb){return node.removeEventListener( type, cb )}
    : function(node,type,cb){return node.detachEvent( "on" + type, cb )}
}


},{}],81:[function(require,module,exports){

// MIT
// Thx Backbone.js 1.1.2  and https://github.com/cowboy/jquery-hashchange/blob/master/jquery.ba-hashchange.js
// for iframe patches in old ie.

var browser = require("./browser.js");
var _ = require("./util.js");


// the mode const
var QUIRK = 3,
  HASH = 1,
  HISTORY = 2;



// extract History for test
// resolve the conficlt with the Native History
function Histery(options){
  options = options || {};

  // Trick from backbone.history for anchor-faked testcase 
  this.location = options.location || browser.location;

  // mode config, you can pass absolute mode (just for test);
  this.html5 = options.html5;
  this.mode = options.html5 && browser.history ? HISTORY: HASH; 
  if( !browser.hash ) this.mode = QUIRK;
  if(options.mode) this.mode = options.mode;

  // hash prefix , used for hash or quirk mode
  this.prefix = "#" + (options.prefix || "") ;
  this.rPrefix = new RegExp(this.prefix + '(.*)$');
  this.interval = options.interval || 66;

  // the root regexp for remove the root for the path. used in History mode
  this.root = options.root ||  "/" ;
  this.rRoot = new RegExp("^" +  this.root);

  this._fixInitState();

  this.autolink = options.autolink!==false;

  this.curPath = undefined;
}

_.extend( _.emitable(Histery), {
  // check the 
  start: function(){
    var path = this.getPath();
    this._checkPath = _.bind(this.checkPath, this);

    if( this.isStart ) return;
    this.isStart = true;

    if(this.mode === QUIRK){
      this._fixHashProbelm(path); 
    }

    switch ( this.mode ){
      case HASH: 
        browser.on(window, "hashchange", this._checkPath); 
        break;
      case HISTORY:
        browser.on(window, "popstate", this._checkPath);
        break;
      case QUIRK:
        this._checkLoop();
    }
    // event delegate
    this.autolink && this._autolink();

    this.curPath = path;

    this.emit("change", path);
  },
  // the history teardown
  stop: function(){

    browser.off(window, 'hashchange', this._checkPath)  
    browser.off(window, 'popstate', this._checkPath)  
    clearTimeout(this.tid);
    this.isStart = false;
    this._checkPath = null;
  },
  // get the path modify
  checkPath: function(ev){

    var path = this.getPath(), curPath = this.curPath;

    //for oldIE hash history issue
    if(path === curPath && this.iframe){
      path = this.getPath(this.iframe.location);
    }

    if( path !== curPath ) {
      this.iframe && this.nav(path, {silent: true});
      this.curPath = path;
      this.emit('change', path);
    }
  },
  // get the current path
  getPath: function(location){
    var location = location || this.location, tmp;
    if( this.mode !== HISTORY ){
      tmp = location.href.match(this.rPrefix);
      return tmp && tmp[1]? tmp[1]: "";

    }else{
      return _.cleanPath(( location.pathname + location.search || "" ).replace( this.rRoot, "/" ))
    }
  },

  nav: function(to, options ){

    var iframe = this.iframe;

    options = options || {};

    to = _.cleanPath(to);

    if(this.curPath == to) return;

    // pushState wont trigger the checkPath
    // but hashchange will
    // so we need set curPath before to forbit the CheckPath
    this.curPath = to;

    // 3 or 1 is matched
    if( this.mode !== HISTORY ){
      this._setHash(this.location, to, options.replace)
      if( iframe && this.getPath(iframe.location) !== to ){
        if(!options.replace) iframe.document.open().close();
        this._setHash(this.iframe.location, to, options.replace)
      }
    }else{
      history[options.replace? 'replaceState': 'pushState']( {}, options.title || "" , _.cleanPath( this.root + to ) )
    }

    if( !options.silent ) this.emit('change', to);
  },
  _autolink: function(){
    if(this.mode!==HISTORY) return;
    // only in html5 mode, the autolink is works
    // if(this.mode !== 2) return;
    var prefix = this.prefix, self = this;
    browser.on( document.body, "click", function(ev){

      var target = ev.target || ev.srcElement;
      if( target.tagName.toLowerCase() !== "a" ) return;
      var tmp = (browser.getHref(target)||"").match(self.rPrefix);
      var hash = tmp && tmp[1]? tmp[1]: "";

      if(!hash) return;
      
      ev.preventDefault && ev.preventDefault();
      self.nav( hash )
      return (ev.returnValue = false);
    } )
  },
  _setHash: function(location, path, replace){
    var href = location.href.replace(/(javascript:|#).*$/, '');
    if (replace){
      location.replace(href + this.prefix+ path);
    }
    else location.hash = this.prefix+ path;
  },
  // for browser that not support onhashchange
  _checkLoop: function(){
    var self = this; 
    this.tid = setTimeout( function(){
      self._checkPath();
      self._checkLoop();
    }, this.interval );
  },
  // if we use real url in hash env( browser no history popstate support)
  // or we use hash in html5supoort mode (when paste url in other url)
  // then , histery should repara it
  _fixInitState: function(){
    var pathname = _.cleanPath(this.location.pathname), hash, hashInPathName;

    // dont support history popstate but config the html5 mode
    if( this.mode !== HISTORY && this.html5){

      hashInPathName = pathname.replace(this.rRoot, "")
      if(hashInPathName) this.location.replace(this.root + this.prefix + hashInPathName);

    }else if( this.mode === HISTORY /* && pathname === this.root*/){

      hash = this.location.hash.replace(this.prefix, "");
      if(hash) history.replaceState({}, document.title, _.cleanPath(this.root + hash))

    }
  },
  // Thanks for backbone.history and https://github.com/cowboy/jquery-hashchange/blob/master/jquery.ba-hashchange.js
  // for helping stateman fixing the oldie hash history issues when with iframe hack
  _fixHashProbelm: function(path){
    var iframe = document.createElement('iframe'), body = document.body;
    iframe.src = 'javascript:;';
    iframe.style.display = 'none';
    iframe.tabIndex = -1;
    iframe.title = "";
    this.iframe = body.insertBefore(iframe, body.firstChild).contentWindow;
    this.iframe.document.open().close();
    this.iframe.location.hash = '#' + path;
  }
  
})





module.exports = Histery;
},{"./browser.js":80,"./util.js":85}],82:[function(require,module,exports){

var StateMan = require("./stateman.js");
StateMan.Histery = require("./histery.js");
StateMan.util = require("./util.js");
StateMan.State = require("./state.js");

module.exports = StateMan;

},{"./histery.js":81,"./state.js":83,"./stateman.js":84,"./util.js":85}],83:[function(require,module,exports){
var _ = require("./util.js");



function State(option){
  this._states = {};
  this._pending = false;
  this.visited = false;
  if(option) this.config(option);
}


//regexp cache
State.rCache = {};

_.extend( _.emitable( State ), {
  
  state: function(stateName, config){
    if(_.typeOf(stateName) === "object"){
      for(var i in stateName){
        this.state(i, stateName[i])
      }
      return this;
    }
    var current, next, nextName, states = this._states, i=0;

    if( typeof stateName === "string" ) stateName = stateName.split(".");

    var slen = stateName.length, current = this;
    var stack = [];


    do{
      nextName = stateName[i];
      next = states[nextName];
      stack.push(nextName);
      if(!next){
        if(!config) return;
        next = states[nextName] = new State();
        _.extend(next, {
          parent: current,
          manager: current.manager || current,
          name: stack.join("."),
          currentName: nextName
        })
        current.hasNext = true;
        next.configUrl();
      }
      current = next;
      states = next._states;
    }while((++i) < slen )

    if(config){
       next.config(config);
       return this;
    } else {
      return current;
    }
  },

  config: function(configure){

    configure = this._getConfig(configure);

    for(var i in configure){
      var prop = configure[i];
      switch(i){
        case "url": 
          if(typeof prop === "string"){
            this.url = prop;
            this.configUrl();
          }
          break;
        case "events": 
          this.on(prop)
          break;
        default:
          this[i] = prop;
      }
    }
  },

  // children override
  _getConfig: function(configure){
    return typeof configure === "function"? {enter: configure} : configure;
  },

  //from url 

  configUrl: function(){
    var url = "" , base = this, currentUrl;
    var _watchedParam = [];

    while( base ){

      url = (typeof base.url === "string" ? base.url: (base.currentName || "")) + "/" + url;

      // means absolute;
      if(url.indexOf("^/") === 0) {
        url = url.slice(1);
        break;
      }
      base = base.parent;
    }
    this.pattern = _.cleanPath("/" + url);
    var pathAndQuery = this.pattern.split("?");
    this.pattern = pathAndQuery[0];
    // some Query we need watched

    _.extend(this, _.normalize(this.pattern), true);
  },
  encode: function(param){
    var state = this;
    param = param || {};
    
    var matched = "%";

    var url = state.matches.replace(/\(([\w-]+)\)/g, function(all, capture){
      var sec = param[capture] || "";
      matched+= capture + "%";
      return sec;
    }) + "?";

    // remained is the query, we need concat them after url as query
    for(var i in param) {
      if( matched.indexOf("%"+i+"%") === -1) url += i + "=" + param[i] + "&";
    }
    return _.cleanPath( url.replace(/(?:\?|&)$/,"") )
  },
  decode: function( path ){
    var matched = this.regexp.exec(path),
      keys = this.keys;

    if(matched){

      var param = {};
      for(var i =0,len=keys.length;i<len;i++){
        param[keys[i]] = matched[i+1] 
      }
      return param;
    }else{
      return false;
    }
  },
  // by default, all lifecycle is permitted

  async: function(){
    throw new Error( 'please use option.async instead')
  }

})


module.exports = State;
},{"./util.js":85}],84:[function(require,module,exports){
var State = require("./state.js"),
  Histery = require("./histery.js"),
  brow = require("./browser.js"),
  _ = require("./util.js"),
  baseTitle = document.title,
  stateFn = State.prototype.state;


function StateMan(options){

  if(this instanceof StateMan === false){ return new StateMan(options)}
  options = options || {};
  // if(options.history) this.history = options.history;

  this._states = {};
  this._stashCallback = [];
  this.strict = options.strict;
  this.current = this.active = this;
  this.title = options.title;
  this.on("end", function(){
    var cur = this.current,title;
    while( cur ){
      title = cur.title;
      if(title) break; 
      cur = cur.parent;
    }
    document.title = typeof title === "function"? cur.title(): String( title || baseTitle ) ;
  })

}


_.extend( _.emitable( StateMan ), {
    // keep blank
    name: '',

    state: function(stateName, config){

      var active = this.active;
      if(typeof stateName === "string" && active){
         stateName = stateName.replace("~", active.name)
         if(active.parent) stateName = stateName.replace("^", active.parent.name || "");
      }
      // ^ represent current.parent
      // ~ represent  current
      // only 
      return stateFn.apply(this, arguments);

    },
    start: function(options){

      if( !this.history ) this.history = new Histery(options); 
      if( !this.history.isStart ){
        this.history.on("change", _.bind(this._afterPathChange, this));
        this.history.start();
      } 
      return this;

    },
    stop: function(){
      this.history.stop();
    },
    // @TODO direct go the point state
    go: function(state, option, callback){
      option = option || {};
      if(typeof state === "string") state = this.state(state);

      if(!state) return;

      if(typeof option === "function"){
        callback = option;
        option = {};
      }

      if(option.encode !== false){
        var url = state.encode(option.param)
        option.path = url;
        this.nav(url, {silent: true, replace: option.replace});
      }

      this._go(state, option, callback);

      return this;
    },
    nav: function(url, options, callback){
      if(typeof options === "function"){
        callback = options;
        options = {};
      }
      options = options || {};

      options.path = url;

      this.history.nav( url, _.extend({silent: true}, options));
      if(!options.silent) this._afterPathChange( _.cleanPath(url) , options , callback)

      return this;
    },
    decode: function(path){

      var pathAndQuery = path.split("?");
      var query = this._findQuery(pathAndQuery[1]);
      path = pathAndQuery[0];
      var state = this._findState(this, path);
      if(state) _.extend(state.param, query);
      return state;

    },
    encode: function(stateName, param){
      var state = this.state(stateName);
      return state? state.encode(param) : '';
    },
    // notify specify state
    // check the active statename whether to match the passed condition (stateName and param)
    is: function(stateName, param, isStrict){
      if(!stateName) return false;
      var stateName = (stateName.name || stateName);
      var current = this.current, currentName = current.name;
      var matchPath = isStrict? currentName === stateName : (currentName + ".").indexOf(stateName + ".")===0;
      return matchPath && (!param || _.eql(param, this.param)); 
    },
    // after pathchange changed
    // @TODO: afterPathChange need based on decode
    _afterPathChange: function(path, options ,callback){

      this.emit("history:change", path);

      var found = this.decode(path);

      options = options || {};

      options.path = path;

      if(!found){
        // loc.nav("$default", {silent: true})
        return this._notfound(options);
      }

      options.param = found.param;

      this._go( found, options, callback );
    },
    _notfound: function(options){

      // var $notfound = this.state("$notfound");

      // if( $notfound ) this._go($notfound, options);

      return this.emit("notfound", options);
    },
    // goto the state with some option
    _go: function(state, option, callback){

      var over;

      // if(typeof state === "string") state = this.state(state);

      // if(!state) return _.log("destination is not defined")

      if(state.hasNext && this.strict) return this._notfound({name: state.name});

      // not touch the end in previous transtion

      // if( this.pending ){
      //   var pendingCurrent = this.pending.current;
      //   this.pending.stop();
      //   _.log("naving to [" + pendingCurrent.name + "] will be stoped, trying to ["+state.name+"] now");
      // }
      // if(this.active !== this.current){
      //   // we need return
      //   _.log("naving to [" + this.current.name + "] will be stoped, trying to ["+state.name+"] now");
      //   this.current = this.active;
      //   // back to before
      // }
      option.param = option.param || {};

      var current = this.current,
        baseState = this._findBase(current, state),
        prepath = this.path,
        self = this;


      if( typeof callback === "function" ) this._stashCallback.push(callback);
      // if we done the navigating when start
      function done(success){
        over = true;
        if( success !== false ) self.emit("end");
        self.pending = null;
        self._popStash(option);
      }
      
      option.previous = current;
      option.current = state;

      if(current !== state){
        option.stop = function(){
          done(false);
          self.nav( prepath? prepath: "/", {silent:true});
        }
        self.emit("begin", option);

      }
      // if we stop it in 'begin' listener
      if(over === true) return;

      if(current !== state){
        // option as transition object.

        option.phase = 'permission';
        this._walk(current, state, option, true , _.bind( function( notRejected ){

          if( notRejected===false ){
            // if reject in callForPermission, we will return to old 
            prepath && this.nav( prepath, {silent: true})

            done(false, 2)

            return this.emit('abort', option);

          } 

          // stop previous pending.
          if(this.pending) this.pending.stop() 
          this.pending = option;
          this.path = option.path;
          this.current = option.current;
          this.param = option.param;
          this.previous = option.previous;
          option.phase = 'navigation';
          this._walk(current, state, option, false, _.bind(function( notRejected ){

            if( notRejected === false ){
              this.current = this.active;
              done(false)
              return this.emit('abort', option);
            }


            this.active = option.current;

            option.phase = 'completion';
            return done()

          }, this) )

        }, this) )

      }else{
        self._checkQueryAndParam(baseState, option);
        this.pending = null;
        done();
      }
      
    },
    _popStash: function(option){

      var stash = this._stashCallback, len = stash.length;

      this._stashCallback = [];

      if(!len) return;

      for(var i = 0; i < len; i++){
        stash[i].call(this, option)
      }
    },

    // the transition logic  Used in Both canLeave canEnter && leave enter LifeCycle

    _walk: function(from, to, option, callForPermit , callback){

      // nothing -> app.state
      var parent = this._findBase(from , to);


      option.basckward = true;
      this._transit( from, parent, option, callForPermit , _.bind( function( notRejected ){

        if( notRejected === false ) return callback( notRejected );

        // only actual transiton need update base state;
        if( !callForPermit )  this._checkQueryAndParam(parent, option)

        option.basckward = false;
        this._transit( parent, to, option, callForPermit,  callback)

      }, this) )

    },

    _transit: function(from, to, option, callForPermit, callback){
      //  touch the ending
      if( from === to ) return callback();

      var back = from.name.length > to.name.length;
      var method = back? 'leave': 'enter';
      var applied;

      // use canEnter to detect permission
      if( callForPermit) method = 'can' + method.replace(/^\w/, function(a){ return a.toUpperCase() });

      var loop = _.bind(function( notRejected ){


        // stop transition or touch the end
        if( applied === to || notRejected === false ) return callback(notRejected);

        if( !applied ) {

          applied = back? from : this._computeNext(from, to);

        }else{

          applied = this._computeNext(applied, to);
        }

        if( (back && applied === to) || !applied )return callback( notRejected )

        this._moveOn( applied, method, option, loop );

      }, this);

      loop();
    },

    _moveOn: function( applied, method, option, callback){

      var isDone = false;
      var isPending = false;

      option.async = function(){

        isPending = true;

        return done;
      }

      function done( notRejected ){
        if( isDone ) return;
        isPending = false;
        isDone = true;
        callback( notRejected );
      }

      

      option.stop = function(){
        done( false );
      }


      this.active = applied;
      var retValue = applied[method]? applied[method]( option ): true;

      if(method === 'enter') applied.visited = true;
      // promise
      // need breadk , if we call option.stop first;

      if( _.isPromise(retValue) ){

        return this._wrapPromise(retValue, done); 

      }

      // if haven't call option.async yet
      if( !isPending ) done( retValue )

    },


    _wrapPromise: function( promise, next ){

      return promise.then( next, function(){next(false)}) ;

    },

    _computeNext: function( from, to ){

      var fname = from.name;
      var tname = to.name;

      var tsplit = tname.split('.')
      var fsplit = fname.split('.')

      var tlen = tsplit.length;
      var flen = fsplit.length;

      if(fname === '') flen = 0;
      if(tname === '') tlen = 0;

      if( flen < tlen ){
        fsplit[flen] = tsplit[flen];
      }else{
        fsplit.pop();
      }

      return this.state(fsplit.join('.'))

    },

    _findQuery: function(querystr){

      var queries = querystr && querystr.split("&"), query= {};
      if(queries){
        var len = queries.length;
        var query = {};
        for(var i =0; i< len; i++){
          var tmp = queries[i].split("=");
          query[tmp[0]] = tmp[1];
        }
      }
      return query;

    },
    _findState: function(state, path){
      var states = state._states, found, param;

      // leaf-state has the high priority upon branch-state
      if(state.hasNext){
        for(var i in states) if(states.hasOwnProperty(i)){
          found = this._findState( states[i], path );
          if( found ) return found;
        }
      }
      // in strict mode only leaf can be touched
      // if all children is don. will try it self
      param = state.regexp && state.decode(path);
      if(param){
        state.param = param;
        return state;
      }else{
        return false;
      }
    },
    // find the same branch;
    _findBase: function(now, before){

      if(!now || !before || now == this || before == this) return this;
      var np = now, bp = before, tmp;
      while(np && bp){
        tmp = bp;
        while(tmp){
          if(np === tmp) return tmp;
          tmp = tmp.parent;
        }
        np = np.parent;
      }
    },
    // check the query and Param
    _checkQueryAndParam: function(baseState, options){

      var from = baseState;
      while( from !== this ){
        from.update && from.update(options);
        from = from.parent;
      }

    }

}, true)



module.exports = StateMan;


},{"./browser.js":80,"./histery.js":81,"./state.js":83,"./util.js":85}],85:[function(require,module,exports){
var _ = module.exports = {};
var slice = [].slice, o2str = ({}).toString;


// merge o2's properties to Object o1. 
_.extend = function(o1, o2, override){
  for(var i in o2) if(override || o1[i] === undefined){
    o1[i] = o2[i]
  }
  return o1;
}



_.slice = function(arr, index){
  return slice.call(arr, index);
}

_.typeOf = function typeOf (o) {
  return o == null ? String(o) : o2str.call(o).slice(8, -1).toLowerCase();
}

//strict eql
_.eql = function(o1, o2){
  var t1 = _.typeOf(o1), t2 = _.typeOf(o2);
  if( t1 !== t2) return false;
  if(t1 === 'object'){
    var equal = true;
    // only check the first's propertie
    for(var i in o1){
      if( o1[i] !== o2[i] ) equal = false;
    }
    return equal;
  }
  return o1 === o2;
}


// small emitter 
_.emitable = (function(){
  function norm(ev){
    var eventAndNamespace = (ev||'').split(':');
    return {event: eventAndNamespace[0], namespace: eventAndNamespace[1]}
  }
  var API = {
    once: function(event, fn){
      var callback = function(){
        fn.apply(this, arguments)
        this.off(event, callback)
      }
      return this.on(event, callback)
    },
    on: function(event, fn) {
      if(typeof event === 'object'){
        for (var i in event) {
          this.on(i, event[i]);
        }
        return this;
      }
      var ne = norm(event);
      event=ne.event;
      if(event && typeof fn === 'function' ){
        var handles = this._handles || (this._handles = {}),
          calls = handles[event] || (handles[event] = []);
        fn._ns = ne.namespace;
        calls.push(fn);
      }
      return this;
    },
    off: function(event, fn) {
      var ne = norm(event); event = ne.event;
      if(!event || !this._handles) this._handles = {};

      var handles = this._handles , calls;

      if (calls = handles[event]) {
        if (!fn && !ne.namespace) {
          handles[event] = [];
        }else{
          for (var i = 0, len = calls.length; i < len; i++) {
            if ( (!fn || fn === calls[i]) && (!ne.namespace || calls[i]._ns === ne.namespace) ) {
              calls.splice(i, 1);
              return this;
            }
          }
        }
      }
      return this;
    },
    emit: function(event){
      var ne = norm(event); event = ne.event;

      var args = _.slice(arguments, 1),
        handles = this._handles, calls;

      if (!handles || !(calls = handles[event])) return this;
      for (var i = 0, len = calls.length; i < len; i++) {
        var fn = calls[i];
        if( !ne.namespace || fn._ns === ne.namespace ) fn.apply(this, args)
      }
      return this;
    }
  }
  return function(obj){
      obj = typeof obj == "function" ? obj.prototype : obj;
      return _.extend(obj, API)
  }
})();



_.bind = function(fn, context){
  return function(){
    return fn.apply(context, arguments);
  }
}

var rDbSlash = /\/+/g, // double slash
  rEndSlash = /\/$/;    // end slash

_.cleanPath = function (path){
  return ("/" + path).replace( rDbSlash,"/" ).replace( rEndSlash, "" ) || "/";
}

// normalize the path
function normalizePath(path) {
  // means is from 
  // (?:\:([\w-]+))?(?:\(([^\/]+?)\))|(\*{2,})|(\*(?!\*)))/g
  var preIndex = 0;
  var keys = [];
  var index = 0;
  var matches = "";

  path = _.cleanPath(path);

  var regStr = path
    //  :id(capture)? | (capture)   |  ** | * 
    .replace(/\:([\w-]+)(?:\(([^\/]+?)\))?|(?:\(([^\/]+)\))|(\*{2,})|(\*(?!\*))/g, 
      function(all, key, keyformat, capture, mwild, swild, startAt) {
        // move the uncaptured fragment in the path
        if(startAt > preIndex) matches += path.slice(preIndex, startAt);
        preIndex = startAt + all.length;
        if( key ){
          matches += "(" + key + ")";
          keys.push(key)
          return "("+( keyformat || "[\\w-]+")+")";
        }
        matches += "(" + index + ")";

        keys.push( index++ );

        if( capture ){
           // sub capture detect
          return "(" + capture +  ")";
        } 
        if(mwild) return "(.*)";
        if(swild) return "([^\\/]*)";
    })

  if(preIndex !== path.length) matches += path.slice(preIndex)

  return {
    regexp: new RegExp("^" + regStr +"/?$"),
    keys: keys,
    matches: matches || path
  }
}

_.log = function(msg, type){
  typeof console !== "undefined" && console[type || "log"](msg)
}

_.isPromise = function( obj ){

  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';

}



_.normalize = normalizePath;


},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvY2xpZW50L2pzL2VudHJ5LmpzIiwiYXBwL2NsaWVudC9qcy9iYXNlL2NvbXBvbmVudC5qcyIsImFwcC9jbGllbnQvanMvYmFzZS9jb25zdGFudC5qcyIsImFwcC9jbGllbnQvanMvYmFzZS9lbWl0LmpzIiwiYXBwL2NsaWVudC9qcy9iYXNlL2ZpbHRlci5qcyIsImFwcC9jbGllbnQvanMvYmFzZS9yZXF1ZXN0LmpzIiwiYXBwL2NsaWVudC9qcy9iYXNlL3V0aWwuanMiLCJhcHAvY2xpZW50L2pzL2NvbW1vbi9tYXNrLmh0bWwiLCJhcHAvY2xpZW50L2pzL2NvbW1vbi9tYXNrLmpzIiwiYXBwL2NsaWVudC9qcy9jb21tb24vbW9kYWwuaHRtbCIsImFwcC9jbGllbnQvanMvY29tbW9uL21vZGFsLmpzIiwiYXBwL2NsaWVudC9qcy9jb21tb24vbm90aWZ5Lmh0bWwiLCJhcHAvY2xpZW50L2pzL2NvbW1vbi9ub3RpZnkuanMiLCJhcHAvY2xpZW50L2pzL2NvbW1vbi9wYWdlci5odG1sIiwiYXBwL2NsaWVudC9qcy9jb21tb24vcGFnZXIuanMiLCJhcHAvY2xpZW50L2pzL2NvbW1vbi9zZWFyY2guaHRtbCIsImFwcC9jbGllbnQvanMvY29tbW9uL3NlYXJjaC5qcyIsImFwcC9jbGllbnQvanMvbW9kdWxlL2FkbWluL2luZGV4Lmh0bWwiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9hZG1pbi9pbmRleC5qcyIsImFwcC9jbGllbnQvanMvbW9kdWxlL2FwcC9hcHAuaHRtbCIsImFwcC9jbGllbnQvanMvbW9kdWxlL2FwcC9hcHAuanMiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9kZXRhaWwvaW5kZXguaHRtbCIsImFwcC9jbGllbnQvanMvbW9kdWxlL2RldGFpbC9pbmRleC5qcyIsImFwcC9jbGllbnQvanMvbW9kdWxlL2hlYWRodW50ZXIvaW5kZXguaHRtbCIsImFwcC9jbGllbnQvanMvbW9kdWxlL2hlYWRodW50ZXIvaW5kZXguanMiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9ob21lL2luZGV4Lmh0bWwiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9ob21lL2luZGV4LmpzIiwiYXBwL2NsaWVudC9qcy9tb2R1bGUvaHVudGVyRGV0YWlsL2luZGV4Lmh0bWwiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9odW50ZXJEZXRhaWwvaW5kZXguanMiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9sb2dpbi9jaGFuZ2VQd2QuaHRtbCIsImFwcC9jbGllbnQvanMvbW9kdWxlL2xvZ2luL2NoYW5nZVB3ZC5qcyIsImFwcC9jbGllbnQvanMvbW9kdWxlL2xvZ2luL2luZGV4Lmh0bWwiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9sb2dpbi9pbmRleC5qcyIsImFwcC9jbGllbnQvanMvbW9kdWxlL2xvZ2luL3Jlc2V0UHdkLmh0bWwiLCJhcHAvY2xpZW50L2pzL21vZHVsZS9sb2dpbi9yZXNldFB3ZC5qcyIsImFwcC9jbGllbnQvanMvbW9kdWxlL3JlY29tbWVuZC9pbmRleC5odG1sIiwiYXBwL2NsaWVudC9qcy9tb2R1bGUvcmVjb21tZW5kL2luZGV4LmpzIiwiYXBwL2NsaWVudC9qcy9tb2R1bGUvdXBsb2FkL2luZGV4Lmh0bWwiLCJhcHAvY2xpZW50L2pzL21vZHVsZS91cGxvYWQvaW5kZXguanMiLCJhcHAvY2xpZW50L2pzL21vZHVsZS91cGxvYWQvc2VsZWN0TW9kZWwuaHRtbCIsImFwcC9jbGllbnQvanMvcm91dGVyLmpzIiwiYXBwL2NsaWVudC9qcy9zZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9qcy1jb29raWUvc3JjL2pzLmNvb2tpZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXItc3RhdGUvcmVzdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2NvbnN0LmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvZGlyZWN0aXZlL2FuaW1hdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2RpcmVjdGl2ZS9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvZGlyZWN0aXZlL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvZGlyZWN0aXZlL2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9kb20uanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9lbnYuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9ncm91cC5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2hlbHBlci9hbmltYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvaGVscGVyL2NvbWJpbmUuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9oZWxwZXIvY3Vyc29yLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvaGVscGVyL2RpZmYuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9oZWxwZXIvZW50aXRpZXMuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9oZWxwZXIvZXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9oZWxwZXIvZXh0ZW5kLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvaGVscGVyL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2hlbHBlci9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL2hlbHBlci9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvaGVscGVyL3dhdGNoZXIuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL21vZHVsZS90aW1lb3V0LmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvcGFyc2VyL0xleGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvcGFyc2VyL1BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL3BhcnNlci9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvcmVuZGVyL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWd1bGFyanMvbGliL3JlbmRlci9zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvcmVndWxhcmpzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3JlZ3VsYXJqcy9saWIvd2Fsa2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9yZXF3ZXN0L3JlcXdlc3QuanMiLCJub2RlX21vZHVsZXMvc3RhdGVtYW4vc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RhdGVtYW4vc3JjL2hpc3RlcnkuanMiLCJub2RlX21vZHVsZXMvc3RhdGVtYW4vc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0YXRlbWFuL3NyYy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zdGF0ZW1hbi9zcmMvc3RhdGVtYW4uanMiLCJub2RlX21vZHVsZXMvc3RhdGVtYW4vc3JjL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBzaGltID0gcmVxdWlyZShcImVzNS1zaGltXCIpO1xyXG52YXIgcm91dGVyID0gcmVxdWlyZShcIi4vcm91dGVyLmpzXCIpO1xyXG5cclxuXHJcbnJvdXRlci5zdGFydCh7IGh0bWw1OiBmYWxzZSwgcm9vdDogXCJcIn0pO1xyXG5cclxuXHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWd1bGFyID0gcmVxdWlyZSgncmVndWxhcmpzJyk7XHJcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlci5qcycpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcbnZhciBkb20gPSBSZWd1bGFyLmRvbTsgXHJcblxyXG52YXIgQ29tcG9uZW50ID0gUmVndWxhci5leHRlbmQoe1xyXG5cdC8vIHJlcXVlc3RcclxuXHQkcmVxdWVzdDogZnVuY3Rpb24oKXt9LFxyXG5cclxuICAgICRsb2dpbjpmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfVxyXG59KVxyXG4uZmlsdGVyKGZpbHRlcilcclxuLmRpcmVjdGl2ZSh7XHJcbiAgICAvLyBpZiBleHByZXNzaW9uIGV2YWx1YXRlZCB0byB0cnVlIHRoZW4gYWRkQ2xhc3Mgei1jcnQuXHJcbiAgICAvLyBvdGhlcndpc2UsIHJlbW92ZSBpdFxyXG4gICAgLy8gPGxpIHotY3J0PXt0aGlzLiRzdGF0ZS5jdXJyZW50Lm5hbWU9PT0nYXBwLnRlc3QuZXhhbS5jaG9pY2UnfT5cclxuICAgICd6LWNydCc6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKXtcclxuICAgICAgICB0aGlzLiR3YXRjaCh2YWx1ZSwgZnVuY3Rpb24odmFsKXtcclxuICAgICAgICAgICAgZG9tW3ZhbD8gJ2FkZENsYXNzJzogJ2RlbENsYXNzJ10oZWxlbSwgJ3otY3J0Jyk7XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICAncS1yZW5kZXInOiBmdW5jdGlvbihlbGVtLCB2YWx1ZSl7XHJcbiAgICAgICAgdGhpcy4kd2F0Y2godmFsdWUsIGZ1bmN0aW9uKHZhbCl7XHJcbiAgICAgICAgICAgIGlmKHZhbCkgZWxlbS5pbm5lckhUTUwgPSBxcy5yZW5kZXIodmFsKVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgJ3ItYXV0b2ZvY3VzJzogZnVuY3Rpb24oZWxlbSwgdmFsdWUpe1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGVsZW0uZm9jdXMoKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH0sXHJcbiAgICAnci1zY3JvbGwnOiBmdW5jdGlvbihlbGVtLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbihuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZihuZXdWYWx1ZSAmJiBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZF9kYiA9IGVsZW0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBncmlkX2RiLnNjcm9sbFRvcCA9IGVsZW0ub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgJ3ItaHJlZic6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4kd2F0Y2godmFsdWUsIGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gbG9jYXRpb24uaHJlZi5zcGxpdCgnIycpO1xyXG4gICAgICAgICAgICBoYXNoID0gaGFzaFsxXSB8fCAnJztcclxuICAgICAgICAgICAgZG9tLmF0dHIoZWxlbSwgJ2hyZWYnLCAnIycgKyBwYXRoLmpvaW4oaGFzaCwgbmV3VmFsdWUgKyAnJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KVxyXG4uZXZlbnQoJ2VudGVyJywgZnVuY3Rpb24oZWxlbSwgZmlyZSl7XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlKGV2KXtcclxuICAgICAgICBpZihldi53aGljaCA9PSAxMyl7IC8vIEVOVEVSIGtleVxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBmaXJlKGV2KTsgLy8gaWYga2V5IGlzIGVudGVyICwgd2UgZmlyZSB0aGUgZXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZG9tLm9uKGVsZW0sIFwia2V5cHJlc3NcIiwgdXBkYXRlKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBkZXN0cm95KCl7IC8vIHJldHVybiBhIGRlc3Ryb3kgZnVuY3Rpb25cclxuICAgICAgICBkb20ub2ZmKGVsZW0sIFwia2V5cHJlc3NcIiwgdXBkYXRlKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDsiLCJcclxubW9kdWxlLmV4cG9ydHMgPXtcclxuICAgIE5PVElGWU5VTTowLFxyXG4gICAgQURNSU46MSwgICAgICAgICAgICAgICAgICAgLy/nrqHnkIblkZhcclxuICAgIFVTRVI6MiwgICAgICAgICAgICAgICAgICAgIC8v5pmu6YCa55So5oi377yI54yO5aS077yJXHJcbiAgICBVU0VSTkFWUzpbeyAgICAgICAgICAgICAgICAvL+aZrumAmueUqOaIt+WvvOiIquagj1xyXG4gICAgICAgIG5hbWU6J+mmliAgIOmhtScsXHJcbiAgICAgICAgdXJsOicjL2hvbWUnLFxyXG4gICAgICAgIG1hdGNoOidob21lfGRldGFpbHx1cGxvYWQnXHJcbiAgICB9LHtcclxuICAgICAgICBuYW1lOifmiJHnmoTmjqjojZAnLFxyXG4gICAgICAgIHVybDonIy9yZWNvbW1lbmQnLFxyXG4gICAgICAgIG1hdGNoOidyZWNvbW1lbmQnXHJcbiAgICB9LHtcclxuICAgICAgICBuYW1lOiflhbPkuo7njI7lpLQnLFxyXG4gICAgICAgIHVybDonIy9oZWFkaHVudGVyJyxcclxuICAgICAgICBtYXRjaDonaGVhZGh1bnRlcidcclxuICAgIH1dLFxyXG4gICAgQURNSU5OQVZTOlt7ICAgICAgICAgICAgICAgLy8g566h55CG5ZGY5a+86Iiq5qCPXHJcbiAgICAgICAgbmFtZTon54yO5aS0566h55CGJyxcclxuICAgICAgICB1cmw6JyMvYWRtaW4nLFxyXG4gICAgICAgIG1hdGNoOidhZG1pbnxodW50ZXJEZXRhaWwnXHJcbiAgICB9XVxyXG5cclxufSIsIi8qKlxyXG4gKlxyXG4gKiBAaHp6aGFuZ3poYW5nMUBjb3JwLm5ldGVhc2UuY29tO1xyXG4gKiBAIOWFqOWxgOS6i+S7tuazqOWGjFxyXG4gKiBAIHVzZVxyXG4gKiBfLm9ic2VydmVyLnJlZ2lzdCgnZXZlcnl0aGluZycsIGZ1bmN0aW9uKHJlcyl7XHJcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKTsvLyB7a2V5OnZhbHVlfVxyXG4gICAgICAgIH0pXHJcbiAqIF8ub2JzZXJ2ZXIuZmlyZSgnZXZlcnl0aGluZycsIHtrZXk6dmFsdWV9KVxyXG4gKi9cclxuXHJcbnZhciBfID0ge307XHJcblxyXG5fLm9ic2VydmVyID0gKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIGhhbmxkZXIgPSB7fTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDms6jlhozkuovku7ZcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19ICAgdHlwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdpc3Q6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7ICAgICAgIC8vbmF2U2hvdyAgIGZ1bm50aW9uKHJlcyl7c2VsZi5uYXZTaG93KCl9O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmxkZXJbdHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5sZGVyW3R5cGVdID0gW2ZuXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhbmxkZXJbdHlwZV0ucHVzaChmbik7ICAgLy9oYW5sZGVyW25hdlNob3ddLnB1c2goZnVubnRpb24ocmVzKXtzZWxmLm5hdlNob3coKX07KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5omn6KGM5LqL5Lu2XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGRhdGEgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmlyZTogZnVuY3Rpb24odHlwZSwgZGF0YSkgeyAgLy9uYXZTaG93IGRhdGFcclxuICAgICAgICAgICAgaWYgKCFoYW5sZGVyW3R5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhIHx8IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoYW5sZGVyW3R5cGVdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5sZGVyW3R5cGVdW2ldKGV2ZW50cyk7IC8vaGFuZGxlW25hdlNob3ddWzBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDnp7vpmaTkuovku7ZcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19ICAgdHlwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFubGRlclt0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhhbmxkZXJbdHlwZV0gPSBoYW5sZGVyW3R5cGVdLmZpbHRlcihmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSBmbjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF87IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGZpbHRlciA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIDxwPnt0aW1lfCBmb3JtYXQ6ICd5eXl5LU1NLWRkIEhIOm1tJ308L3A+XHJcbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuZmlsdGVyLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZnVuY3Rpb24gZml4KHN0cikge1xyXG4gICAgICAgIHN0ciA9ICcnICsgKFN0cmluZyhzdHIpIHx8ICcnKTtcclxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCA8PSAxPyAnMCcgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcbiAgICB2YXIgbWFwcyA9IHtcclxuICAgICAgICAneXl5eSc6IGZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLmdldEZ1bGxZZWFyKCl9LFxyXG4gICAgICAgICdNTSc6IGZ1bmN0aW9uKGRhdGUpe3JldHVybiBmaXgoZGF0ZS5nZXRNb250aCgpICsgMSk7IH0sXHJcbiAgICAgICAgJ2RkJzogZnVuY3Rpb24oZGF0ZSl7IHJldHVybiBmaXgoZGF0ZS5nZXREYXRlKCkpIH0sXHJcbiAgICAgICAgJ0hIJzogZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGZpeChkYXRlLmdldEhvdXJzKCkpIH0sXHJcbiAgICAgICAgJ21tJzogZnVuY3Rpb24oZGF0ZSl7IHJldHVybiBmaXgoZGF0ZS5nZXRNaW51dGVzKCkpfSxcclxuICAgICAgICAnc3MnOiBmdW5jdGlvbihkYXRlKXsgcmV0dXJuIGZpeChkYXRlLmdldFNlY29uZHMoKSl9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB0cnVuayA9IG5ldyBSZWdFeHAoT2JqZWN0LmtleXMobWFwcykuam9pbignfCcpLCdnJyk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQpIHtcclxuICAgICAgICBpZighdmFsdWUpe3JldHVybiAnJzt9XHJcblxyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAneXl5eS1NTS1kZCBISDptbSc7XHJcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSh0cnVuaywgZnVuY3Rpb24oY2FwdHVyZSl7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBzW2NhcHR1cmVdPyBtYXBzW2NhcHR1cmVdKHZhbHVlKTogJyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0oKTtcclxuXHJcbmZpbHRlci50b3RhbCA9IGZ1bmN0aW9uKGFycmF5LCBrZXkpIHtcclxuICAgIHZhciB0b3RhbCA9IDA7XHJcbiAgICBpZighYXJyYXkpIHJldHVybjtcclxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24oIGl0ZW0gKXtcclxuICAgICAgICB0b3RhbCArPSBrZXk/IGl0ZW1ba2V5XSA6IGl0ZW07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0b3RhbDtcclxufTtcclxuXHJcbmZpbHRlci5maWx0ZXIgPSBmdW5jdGlvbihhcnJheSwgZmlsdGVyRm4pIHtcclxuICAgIGlmKCFhcnJheSB8fCAhYXJyYXkubGVuZ3RoKSByZXR1cm47XHJcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KXtcclxuICAgICAgICByZXR1cm4gZmlsdGVyRm4oaXRlbSwgaW5kZXgpO1xyXG4gICAgfSlcclxufTtcclxuXHJcbmZpbHRlci5wZXJtaXNzaW9uID0gZnVuY3Rpb24odmFsdWUsIHBlcm1pc3Npb24pIHtcclxuICAgIGlmKHBlcm1pc3Npb24gPT09ICdtb2RpZnknKVxyXG4gICAgICAgIHJldHVybiAodmFsdWU+PjIpJTI7XHJcbiAgICBlbHNlIGlmKHBlcm1pc3Npb24gPT09ICdyZW1vdmUnKVxyXG4gICAgICAgIHJldHVybiAodmFsdWU+PjMpJTI7XHJcbiAgICBlbHNlIGlmKHBlcm1pc3Npb24gPT09ICdyZWNoZWNrJylcclxuICAgICAgICByZXR1cm4gKHZhbHVlPj40KSUyO1xyXG5cclxufTtcclxuXHJcbmZpbHRlci5yZW5kZXIgPSBmdW5jdGlvbih2YWx1ZSwgYW5zd2VyKXtcclxuICAgIHJldHVybiBxdWVzLnJlbmRlcih2YWx1ZSwgYW5zd2VyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiDov4fmu6RpbnB1dCDovpPlhaUg6Ziy5q2i6ISa5pys5rOo5YWlXHJcbiAqIEBwYXJhbSAge1t0eXBlXX0gdmFsIFtkZXNjcmlwdGlvbl1cclxuICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuZmlsdGVyLmVzY2FwZSA9IGZ1bmN0aW9uKHZhbCl7XHJcblxyXG4gIHJldHVybiAodmFsIHx8ICcnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpXHJcbn07XHJcblxyXG5maWx0ZXIuYXZlcmFnZSA9IGZ1bmN0aW9uKGFycmF5LCBrZXkpe1xyXG4gICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcclxuICAgIHJldHVybiBhcnJheS5sZW5ndGg/IGZpbHRlci50b3RhbChhcnJheSwga2V5KS8gYXJyYXkubGVuZ3RoIDogMDtcclxufTtcclxuXHJcbmZpbHRlci5iaXRhbmQgID0gZnVuY3Rpb24odmFsdWUsIGJpdCl7XHJcbiAgICByZXR1cm4gKHZhbHVlfHwwKSAmIGJpdDtcclxufTtcclxuXHJcbmZpbHRlci5qb2luID0gZnVuY3Rpb24odmFsdWUsc3BsaXRvcil7XHJcbiAgICByZXR1cm4gdmFsdWUuam9pbihzcGxpdG9yIHx8ICcsJyk7XHJcbn07XHJcbmZpbHRlci5qc29uID0gZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciByZXF3ZXN0ID0gcmVxdWlyZSgncmVxd2VzdCcpO1xyXG52YXIgYWpheCA9IHt9O1xyXG5cclxudmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi4vYmFzZS9jb25zdGFudC5qcycpO1xyXG52YXIgTWFzayA9IHJlcXVpcmUoJy4uL2NvbW1vbi9ub3RpZnkuanMnKTtcclxudmFyIE5vdGlmeSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9ub3RpZnkuanMnKTtcclxudmFyIENvb2tpZSAgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtY29va2llL3NyYy9qcy5jb29raWUuanMnKTtcclxudmFyIGNhY2hlU2VydmVyID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xyXG5cclxuYWpheC5yZXF1ZXN0ID0gZnVuY3Rpb24ob3B0KSB7XHJcbiAgICB2YXIgb3B0RXJyb3IgPSBmdW5jdGlvbihkYXRhLHJlc3VsdCkge1xyXG5cclxuICAgICAgICBpZihyZXN1bHQuY29kZSA9PSAnVE8nKXtcclxuICAgICAgICAgICAgaWYoY29uc3RhbnQuTk9USUZZTlVNKysgJiYgY29uc3RhbnQuTk9USUZZTlVNPjEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXNrID0gbmV3IE1hc2soKS4kaW5qZWN0KGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgICAgICBOb3RpZnkud2FybmluZygn55m75b2V6LaF5pe277yM6Ieq5Yqo6Lez6L2s6Iez55m75b2V6aG16Z2ificpO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXHJcbiAgICAgICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIENvb2tpZS5yZW1vdmUoJ3Bhc3Nwb3J0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFzay5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gJyMvbG9naW4nO1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKHRydWUpO1xyXG4gICAgICAgICAgICB9LDEwMDApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHJlc3VsdC5jb2RlID09ICc1MDAnKXtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9ICcvNTB4Lmh0bWwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL29wdC5wcm9ncmVzcyAmJiBwcm9ncmVzcy5lbmQodHJ1ZSk7XHJcbiAgICAgICAgLy9vbGRFcnJvcihkYXRhLnJlc3VsdCwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHZhciBvbGRFcnJvciA9IG9wdC5lcnJvciB8fCBvcHRFcnJvcixcclxuICAgICAgICBvbGRTdWNjZXNzID0gb3B0LnN1Y2Nlc3MgfHwgbm9vcCxcclxuICAgICAgICBvbGRDb21wbGV0ZSA9IG9wdC5jb21wbGV0ZSB8fCBub29wO1xyXG5cclxuICAgIG9wdC5kYXRhID0gb3B0LmRhdGEgfHwge307XHJcblxyXG4gICAgaWYob3B0Lm1ldGhvZCAmJiBvcHQubWV0aG9kLnRvTG93ZXJDYXNlKCkgIT09ICdnZXQnKVxyXG4gICAgICAgIG9wdC5jb250ZW50VHlwZSA9IG9wdC5jb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgb3B0LmRhdGEudGltZXN0YW1wID0gK25ldyBEYXRlO1xyXG5cclxuICAgIGlmKG9wdC5jb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nIHx8IG9wdC5oZWFkZXJzICYmIG9wdC5oZWFkZXJzLmNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicgKSB7XHJcblxyXG4gICAgICAgIG9wdC5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0LmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vYWpheC4kZW1pdCgnc3RhcnQnLCBvcHQpO1xyXG4gICAgLy9vcHQucHJvZ3Jlc3MgJiYgcHJvZ3Jlc3Muc3RhcnQoKTtcclxuXHJcbiAgICBvcHQuc3VjY2VzcyA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgLy9hamF4LiRlbWl0KCdzdWNjZXNzJywgZGF0YSk7XHJcbiAgICAgICAgLy9vcHQucHJvZ3Jlc3MgJiYgcHJvZ3Jlc3MuZW5kKCk7XHJcbiAgICAgICAgaWYoZGF0YS5jb2RlICE9IDIwMCkge1xyXG5cclxuICAgICAgICAgICAvLyBOb3RpZnkuc3VjY2VzcyhkYXRhLm1zZyk7XHJcbiAgICAgICAgICAgIG9sZEVycm9yKGRhdGEucmVzdWx0fHxkYXRhLmRhdGEsIGRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9sZFN1Y2Nlc3MoZGF0YS5yZXN1bHR8fGRhdGEuZGF0YSwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAvL2FqYXguJGVtaXQoZWNvbXBsZXRlJywgZGF0YSk7XHJcbiAgICAgICAgb2xkQ29tcGxldGUoZGF0YS5yZXN1bHQsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9wdC5tZXRob2QgJiYgb3B0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09ICdwb3N0Jyl7XHJcbiAgICAgICAgY2FjaGVTZXJ2ZXIuZ2V0VG9rZW4oZnVuY3Rpb24oZGF0YSxyZXN1bHQpe1xyXG4gICAgICAgICAgICAvKm9wdC5kYXRhID0gSlNPTi5wYXJzZShvcHQuZGF0YSk7XHJcbiAgICAgICAgICAgIG9wdC5kYXRhLnRva2VuID0gZGF0YTtcclxuICAgICAgICAgICAgb3B0LmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHQuZGF0YSkqL1xyXG4gICAgICAgICAgICBvcHQuaGVhZGVycyA9IHt0b2tlbjpkYXRhfTtcclxuICAgICAgICAgICAgcmVxd2VzdChvcHQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlcXdlc3Qob3B0KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhamF4OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWd1bGFyID0gcmVxdWlyZSgncmVndWxhcmpzJyk7XHJcblxyXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG52YXIgXyA9IHtcclxuICAgIGV4dGVuZDogZnVuY3Rpb24obzEsIG8yLCBvdmVycmlkZSkge1xyXG4gICAgICAgIGZvcih2YXIgaSBpbiBvMilcclxuICAgICAgICAgICAgaWYob3ZlcnJpZGUgfHwgbzFbaV0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIG8xW2ldID0gbzJbaV07XHJcbiAgICAgICAgcmV0dXJuIG8xO1xyXG4gICAgfSxcclxuICAgIGRvbTogUmVndWxhci5kb20sXHJcbiAgICBtdWx0aWxpbmU6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gZnVuYy50b1N0cmluZygpLnJlcGxhY2UoL15mdW5jdGlvblxccypcXChcXClcXHMqXFx7XFxzKlxcL1xcKisvLCAnJykucmVwbGFjZSgvXFwqK1xcL1xccypcXH0kLywgJycpLnRyaW0oKTtcclxuICAgIH0sXHJcbiAgICBpc0FycmF5OiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh0YXJnZXQpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfSxcclxuICAgIGNsb25lOmZ1bmN0aW9uKG9iail7XHJcbiAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xyXG4gICAgICAgIGZvcih2YXIgZWxlbWVudHMgaW4gb2JqKXtcclxuICAgICAgICAgIG5ld09ialtlbGVtZW50c10gPSBvYmpbZWxlbWVudHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgfSAgIFxyXG59O1xyXG5cclxudmFyIG8yc3RyID0gKHt9KS50b1N0cmluZztcclxuXy5leHRlbmQoXywge1xyXG4gICAgJDogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+iOt+WPlnVybOS4reeahOWPguaVsFxyXG4gICAgZ2V0UGFyYW1zOiBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdmFyIHJlZyA9IC8oXFx3Kyk9KFteJl0rKS9nLFxyXG4gICAgICAgICAgICBwYXJhbXMgPSB7fSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIHVybCA9ICh1cmwuc3BsaXQoJz8nKVsxXSB8fCAnJyk7XHJcblxyXG4gICAgICAgIHdoaWxlKHJlc3VsdCA9IHJlZy5leGVjKHVybCkpIHtcclxuICAgICAgICAgICAgcGFyYW1zW3Jlc3VsdFsxXV0gPSByZXN1bHRbMl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuXHJcblxyXG5cclxuICAgIGFycmF5Mm1hcDpmdW5jdGlvbihsaXN0LCBrZXksIHByZWZpeCkge1xyXG4gICAgICAgIHZhciByZXN1bHQ9e30sIGksIGwsIHAsIGl0ZW07XHJcbiAgICAgICAgZm9yKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspe1xyXG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgcCA9IHByZWZpeCArIGxpc3RbaV1ba2V5XTtcclxuICAgICAgICAgICAgcmVzdWx0W3BdID0gbGlzdFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICAvKmV4dGVuZDogIGZ1bmN0aW9uKG8xLCBvMiwgb3ZlcnJpZGUpe1xyXG4gICAgICAgIGZvcih2YXIgaSBpbiBvMikgaWYob3ZlcnJpZGUgfHwgbzFbaV0gPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG8xW2ldID0gbzJbaV1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG8xO1xyXG4gICAgfSwqL1xyXG4gICAgLy/liKTmlq3nsbvlnotcclxuICAgIHR5cGVPZjogZnVuY3Rpb24obyl7XHJcbiAgICAgICAgcmV0dXJuIG8gPT0gbnVsbCA/IFN0cmluZyhvKSA6IG8yc3RyLmNhbGwobykuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9LFxyXG4gICAgLy/liKTmlq3mmK/lkKbmmK/miYvmnLrlj7dcclxuICAgIG1vYmlsZTogZnVuY3Rpb24gKG1vYmlsZSkge1xyXG4gICAgICAgIC8qIOWPt+eggeauteadpeiHqiBodHRwOi8vdC5jbi9SdjZRdlJyICovXHJcbiAgICAgICAgcmV0dXJuIC9eKDEzWzAtOV18MTRbNTddfDE1WzAtMzUtOV18MTdbMC05XXwxOFswLTldKVxcZHs4fSR8MTcwWzAxMjU3ODldXFxkezd9JC8udGVzdChtb2JpbGUpO1xyXG4gICAgfSxcclxuICAgIC8v5Yik5pat5piv5ZCm5pivZW1haWxcclxuICAgIGVtYWlsOiBmdW5jdGlvbiAoZW1haWwpIHtcclxuICAgICAgICByZXR1cm4gL15bYS16QS1aMC05Xy1dK0BbYS16QS1aMC05Xy1dKyhcXC5bYS16QS1aMC05Xy1dKykrJC9pLnRlc3QoZW1haWwpXHJcbiAgICB9LFxyXG4gICAgLy/kuK3lm73ouqvku73or4Hlj7fliKTmlq1cclxuICAgIGlkTnVtYmVyOmZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICB2YXIgaXNJZENhcmQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZVsxN10udG9Mb3dlckNhc2UoKSA9PSBcInhcIiAmJiAoZVsxN10gPSAxMCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDE3OyBuKyspIHQgKz0gb1tuXSAqIGVbbl07XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsQ29kZVBvc2l0aW9uID0gdCAlIDExO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVbMTddID09IHVbdmFsQ29kZVBvc2l0aW9uXSA/ICEwIDogITE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuc3Vic3RyaW5nKDYsIDEwKSwgbiA9IGUuc3Vic3RyaW5nKDEwLCAxMiksIHIgPSBlLnN1YnN0cmluZygxMiwgMTQpLCBpID0gbmV3IERhdGUodCwgcGFyc2VGbG9hdChuKSAtIDEsIHBhcnNlRmxvYXQocikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSAtIHBhcnNlSW50KHQpIDwgMTggPyAhMSA6IGkuZ2V0RnVsbFllYXIoKSAhPSBwYXJzZUZsb2F0KHQpIHx8IGkuZ2V0TW9udGgoKSAhPSBwYXJzZUZsb2F0KG4pIC0gMSB8fCBpLmdldERhdGUoKSAhPSBwYXJzZUZsb2F0KHIpID8gITEgOiAhMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zdWJzdHJpbmcoNiwgOCksIG4gPSBlLnN1YnN0cmluZyg4LCAxMCksIHIgPSBlLnN1YnN0cmluZygxMCwgMTIpLCBpID0gbmV3IERhdGUodCwgcGFyc2VGbG9hdChuKSAtIDEsIHBhcnNlRmxvYXQocikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuZ2V0WWVhcigpICE9IHBhcnNlRmxvYXQodCkgfHwgaS5nZXRNb250aCgpICE9IHBhcnNlRmxvYXQobikgLSAxIHx8IGkuZ2V0RGF0ZSgpICE9IHBhcnNlRmxvYXQocikgPyAhMSA6ICEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZSgvIC9nLCBcIlwiKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5sZW5ndGggPT0gMTUpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aCA9PSAxOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5zcGxpdChcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcihlKSAmJiBuKGkpID8gITAgOiAhMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbyA9IFsgNywgOSwgMTAsIDUsIDgsIDQsIDIsIDEsIDYsIDMsIDcsIDksIDEwLCA1LCA4LCA0LCAyLCAxIF0sIHUgPSBbIDEsIDAsIDEwLCA5LCA4LCA3LCA2LCA1LCA0LCAzLCAyIF07XHJcbiAgICAgICAgICAgIHJldHVybiBzKGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFzdHIpIHJldHVybjtcclxuICAgICAgICB2YXIgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIGlzSWRDYXJkKFN0cmluZyhzdHIpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/lpJblm73ouqvku73or4Hlj7fliKTmlq1cclxuICAgIGZvcmVpZ25JZE51bWJlcjpmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICByZXR1cm4gc3RyLmxlbmd0aDwxOD90cnVlOmZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+WIpOaWrXRhcmdldOaYr+WQpuWcqG9iauWGhVxyXG4gICAgY29udGFpbnM6ZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKG9ialtpXSA9PT0gdGFyZ2V0KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICAvL+WIpOaWrWRhdGHmmK/lkKbkuLp0eXBl57G75Z6LXHJcbiAgICBpc1R5cGVPZiA6IGZ1bmN0aW9uKF9kYXRhLF90eXBlKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICBfdHlwZSA9IF90eXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2RhdGE9PT1udWxsKSByZXR1cm4gX3R5cGU9PSdudWxsJztcclxuICAgICAgICAgICAgICAgIGlmIChfZGF0YT09PXVuZGVmaW5lZCkgcmV0dXJuIF90eXBlPT0ndW5kZWZpbmVkJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoX2RhdGEpLnRvTG93ZXJDYXNlKCk9PSdbb2JqZWN0ICcrX3R5cGUrJ10nO1xyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaXNTdHJpbmcgOiBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICByZXR1cm4gdXRpbC5pc1R5cGVPZihkYXRhLCdzdHJpbmcnKTtcclxuICAgIH0sXHJcbiAgICBnZXRDYWxlbmRhckkxOG46ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNNb250aCA6ICfkuIrmnIgnLFxyXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoICAgICA6ICfkuIvmnIgnLFxyXG4gICAgICAgICAgICAgICAgbW9udGhzICAgICAgICA6IFsnMeaciCcsJzLmnIgnLCcz5pyIJywnNOaciCcsJzXmnIgnLCc25pyIJywnN+aciCcsJzjmnIgnLCc55pyIJywnMTDmnIgnLCcxMeaciCcsJzEy5pyIJ10sXHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5cyAgICAgIDogWyfml6UnLCfkuIAnLCfkuownLCfkuIknLCflm5snLCfkupQnLCflha0nXSxcclxuICAgICAgICAgICAgICAgIHdlZWtkYXlzU2hvcnQgOiBbJ+aXpScsJ+S4gCcsJ+S6jCcsJ+S4iScsJ+WbmycsJ+S6lCcsJ+WFrSddLFxyXG4gICAgICAgICAgICAgICAgbWlkbmlnaHQ6J+WHjOaZqCcsXHJcbiAgICAgICAgICAgICAgICBub29uOifkuK3ljYgnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcblxyXG5cclxuICAgIHdyYXBSZXE6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihqc29uKXtcclxuICAgICAgICAgICAgICAgIGlmKGpzb24gJiYganNvbi5jb2RlIDwgMzAwKXtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBqc29uKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGpzb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oanNvbil7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBmaW5kUXVlc3Rpb246IGZ1bmN0aW9uKHFpZCwgdGVzdCl7XHJcbiAgICAgICAgdmFyIGNvbXBlbGV0ZSA9IHRlc3QucXVlc3Rpb25zWzNdO1xyXG4gICAgICAgIHZhciBjb2RpbmcgPSB0ZXN0LnF1ZXN0aW9uc1s0XTtcclxuICAgICAgICB2YXIgY2hlY2tlciA9IGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gaXRlbS5xdWVzdGlvbklkID09IHFpZCB9O1xyXG4gICAgICAgIGlmKCFjb21wZWxldGUpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgcXVlc3Rpb24gPSBjb21wZWxldGUuZmlsdGVyKGNoZWNrZXIpWzBdO1xyXG4gICAgICAgIGlmKCFxdWVzdGlvbikgcXVlc3Rpb24gPSBjb2RpbmcuZmlsdGVyKGNoZWNrZXIpWzBdO1xyXG4gICAgICAgIHJldHVybiBxdWVzdGlvbjtcclxuICAgIH0sXHJcbiAgICBoYXNBdXRob3JpdHk6IGZ1bmN0aW9uKG51bSwgYXV0aG9yaXR5KXtcclxuICAgICAgICByZXR1cm4gYXV0aG9yaXR5ICYgTWF0aC5wb3coMiwgbnVtKVxyXG4gICAgfSxcclxuICAgIHVuaXF1ZUFycjpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgZGF0YSA9IGRhdGEgfHwgW107XHJcbiAgICAgICAgICAgIHZhciBhID0ge307XHJcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHYgPSBkYXRhW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YoYVt2XSkgPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgYVt2XSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICAgZGF0YS5sZW5ndGg9MDtcclxuICAgICAgZm9yICh2YXIgaSBpbiBhKXtcclxuICAgICAgICBkYXRhW2RhdGEubGVuZ3RoXSA9IGk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG4gICAgc3BsaWNlQXJyYXk6ZnVuY3Rpb24oYXJyMSwgYXJyMiwga2V5KXtcclxuICAgICAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIxWzBdKTtcclxuICAgICAgICB2YXIgdGVtcEFyciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJyMSkpO1xyXG4gICAgICAgIGlmKHR5cGUgPT0gJ1tvYmplY3QgT2JqZWN0XScpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLGxlbjIgPSBhcnIyLmxlbmd0aDsgaSA8bGVuMjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTAsbGVuMSA9IGFycjEubGVuZ3RoOyBqPGxlbjE7aisrKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhcnIyW2ldW2tleV0rJywnK2FycjFbal1ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXJyMltpXVtrZXldID09IGFycjFbal1ba2V5XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEFyci5zcGxpY2UoaiwxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRlbXBBcnI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICBmb3IodmFyIGxlbiA9IGFycjIubGVuZ3RoOyBsZW4tLTsgKVxyXG4gICAgICAgICAgICAgICAgdGVtcEFyci5zcGxpY2UoYXJyMS5pbmRleE9mKGFycjJbbGVuXSksMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wQXJyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgbXVsdGlsaW5lOmZ1bmN0aW9uKGZ1bmMpe1xyXG4gICAgICAgIHZhciByZWcgPSAvXmZ1bmN0aW9uXFxzKlxcKFxcKVxccypcXHtcXHMqXFwvXFwqK1xccyooW1xcc1xcU10qKVxccypcXCorXFwvXFxzKlxcfSQvO1xyXG4gICAgICAgIHJldHVybiByZWcuZXhlYyhmdW5jKVsxXTtcclxuICAgIH0sXHJcbiAgICBoYXNDbGFzczogZnVuY3Rpb24gKG9iaiwgY2xzKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBvYmouY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoJyhcXFxcc3xeKScgKyBjbHMgKyAnKFxcXFxzfCQpJykpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDbGFzczpmdW5jdGlvbiAob2JqLCBjbHMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzQ2xhc3Mob2JqLCBjbHMpKSBvYmouY2xhc3NOYW1lICs9IFwiIFwiICsgY2xzO1xyXG4gICAgfSxcclxuXHJcbiAgICBoaWRlOmZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9LFxyXG4gICAgc2hvdzpmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB9LFxyXG4gICAgICAgXHJcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKG9iaiwgY2xzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2xhc3Mob2JqLCBjbHMpKSB7XHJcbiAgICAgICAgICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xzICsgJyhcXFxcc3wkKScpO1xyXG4gICAgICAgICAgICBvYmouY2xhc3NOYW1lID0gb2JqLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmFuZG9tTnVtOmZ1bmN0aW9uKG1pbk51bSwgbWF4TnVtKXtcclxuICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7IFxyXG4gICAgICAgICAgICBjYXNlIDE6IFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGgucmFuZG9tKCkqbWluTnVtKzEpOyBcclxuICAgICAgICAgICAgYnJlYWs7IFxyXG4gICAgICAgICAgICBjYXNlIDI6IFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGgucmFuZG9tKCkqKG1heE51bS1taW5OdW0rMSkrbWluTnVtKTsgXHJcbiAgICAgICAgICAgIGJyZWFrOyBcclxuICAgICAgICAgICAgZGVmYXVsdDogXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDsgXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvL+mqjOivgeaYr+WQpuS4uuepuuWvueixoVxyXG4gICAgaXNFbXB0eU9iamVjdDpmdW5jdGlvbihvYmope1xyXG4gICAgICAgIGZvcih2YXIgaXRlbSBpbiAgb2JqKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuXy5DT0xPUl9TVUNDRVNTID0gJyM1Y2I4NWMnO1xyXG5fLkNPTE9SX0lORk8gPSAnIzViYzBkZSc7XHJcbl8uQ09MT1JfREFOR0VSID0gJyNkOTUzNGYnO1xyXG5fLkNPTE9SX1dBUk5JTkcgPSAnI2YwYWQ0ZSc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF87IiwibW9kdWxlLmV4cG9ydHM9XCI8ZGl2IGNsYXNzPVxcXCJ1LW1hc2tcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcInUtbG9hZGluZ1xcXCI+PC9kaXY+XCIiLCJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vYmFzZS9jb21wb25lbnQuanMnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9tYXNrLmh0bWwnKTtcclxuXHJcbnZhciBNYXNrID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcblx0dGVtcGxhdGU6IHRlbXBsYXRlLFxyXG5cdGNvbmZpZzogZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgXHJcblx0fSxcclxuXHRpbml0OiBmdW5jdGlvbigpe1xyXG5cdFx0XHJcblx0fSxcclxuXHRjbG9zZTogZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn0pO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hc2s7XHJcbiIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwibS1tb2RhbCB7QChjbGFzcyl9XFxcIiBvbi1rZXl1cD17dGhpcy5rZXl1cCgkZXZlbnQpfSAgPiAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbF9kaWFsb2dcXFwiIHsjaWYgd2lkdGh9c3R5bGU9XFxcIndpZHRoOiB7d2lkdGh9cHhcXFwiey9pZn0+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbF9oZFxcXCI+ICAgICAgICAgICAgPGEgY2xhc3M9XFxcIm1vZGFsX2Nsb3NlXFxcIiBvbi1jbGljaz17dGhpcy5jbG9zZSghY2FuY2VsQnV0dG9uKX0+PGkgY2xhc3M9XFxcInUtaWNvbi1jbG9zZVxcXCIgci1oaWRlPXt0b2dnbGVDbG9zZX0+PC9pPjxpIGNsYXNzPVxcXCJ1LWljb24tY2xvc2UtMVxcXCIgci1oaWRlPXshdG9nZ2xlQ2xvc2V9PjwvaT48L2E+ICAgICAgICAgICAgPGgzIGNsYXNzPVxcXCJtb2RhbF90aXRsZVxcXCI+PGkgY2xhc3M9XFxcInUtaWNvbi1ub3RpY2VcXFwiIHItaGlkZT17IWhhc0ljb259PjwvaT4ge3RpdGxlfTwvaDM+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsX2JkXFxcIj4gICAgICAgICAgICB7I2lmIGNvbnRlbnRUZW1wbGF0ZX17I2luY2x1ZGUgY29udGVudFRlbXBsYXRlfXsjZWxzZX17Y29udGVudH17L2lmfSAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbF9mdFxcXCI+ICAgICAgICAgICAgeyNpZiBva0J1dHRvbn0gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnRuLWFjdGl2ZVxcXCIgb24tY2xpY2s9e3RoaXMuY2xvc2UodHJ1ZSl9Pntva0J1dHRvbiA9PT0gdHJ1ZSA/IChva1ZhbHVlIHx8IFxcJ+ehruiupFxcJykgOiBva0J1dHRvbn08L2J1dHRvbj4gICAgICAgICAgICB7L2lmfSAgICAgICAgICAgIHsjaWYgY2FuY2VsQnV0dG9ufSAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidG4tZ3JheVxcXCIgb24tY2xpY2s9e3RoaXMuY2xvc2UoZmFsc2UpfT57Y2FuY2VsQnV0dG9uID09PSB0cnVlID8gXFwn5Y+W5raIXFwnIDogY2FuY2VsQnV0dG9ufTwvYnV0dG9uPiAgICAgICAgICAgIHsvaWZ9ICAgICAgICA8L2Rpdj4gICAgPC9kaXY+PC9kaXY+XCIiLCIvKipcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIE1vZGFsICAgICDmqKHmgIHlr7nor53moYZcclxuICogQGF1dGhvciAgIHNlbnNlbihyYWluZm9yZXN0OTJAMTI2LmNvbSlcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2Jhc2UvY29tcG9uZW50LmpzJyk7XHJcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vbW9kYWwuaHRtbCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2Jhc2UvdXRpbC5qcycpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBNb2RhbFxyXG4gKiBAZXh0ZW5kIENvbXBvbmVudFxyXG4gKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgICAgICAgICAgICAgICAgICAgIOe7keWumuWxnuaApyB8IEJpbmRpbmcgUHJvcGVydGllc1xyXG4gKiBAcGFyYW0ge3N0cmluZz0n5o+Q56S6J30gICAgICAgICAgIG9wdGlvbnMuZGF0YS50aXRsZSAgICAgICAgICAgICAg5a+56K+d5qGG5qCH6aKYIHwgVGl0bGUgb2YgRGlhbG9nXHJcbiAqIEBwYXJhbSB7c3RyaW5nPScnfSAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5jb250ZW50ICAgICAgICAgICAg5a+56K+d5qGG5YaF5a65XHJcbiAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW49dHJ1ZX0gICAgIG9wdGlvbnMuZGF0YS5va0J1dHRvbiAgICAgICAgICAg5piv5ZCm5pi+56S656Gu5a6a5oyJ6ZKu44CC5YC85Li6YHN0cmluZ2Dml7bmmL7npLror6XmrrXmloflrZfjgIJcclxuICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbj1mYWxzZX0gICAgb3B0aW9ucy5kYXRhLmNhbmNlbEJ1dHRvbiAgICAgICDmmK/lkKbmmL7npLrlj5bmtojmjInpkq7jgILlgLzkuLpgc3RyaW5nYOaXtuaYvuekuuivpeauteaWh+Wtl+OAglxyXG4gKiBAcGFyYW0ge251bWJlcj1udWxsfSAgICAgICAgICAgICBvcHRpb25zLmRhdGEud2lkdGggICAgICAgICAgICAgIOWvueivneahhuWuveW6puOAguWAvOS4uuWQpuWumuaXtuWuveW6puS4ukNTU+iuvue9rueahOWuveW6puOAglxyXG4gKiBAcGFyYW0ge3N0cmluZz0nJ30gICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuY2xhc3MgICAgICAgICAgICAgIOihpeWFhWNsYXNzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgICAgICAgICAgICAgIG9wdGlvbnMub2sgICAgICAgICAgICAgICAgICAgICAg5b2T54K55Ye756Gu5a6a55qE5pe25YCZ5omn6KGMXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FuY2VsICAgICAgICAgICAgICAgICAg5b2T54K55Ye75Y+W5raI55qE5pe25YCZ5omn6KGMXHJcbiAqL1xyXG52YXIgTW9kYWwgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgIG5hbWU6ICdtb2RhbCcsXHJcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAvKipcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgY29uZmlnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBfLmV4dGVuZCh0aGlzLmRhdGEsIHtcclxuICAgICAgICAgICAgdGl0bGU6ICfmj5DnpLonLFxyXG4gICAgICAgICAgICBjb250ZW50OiAnJyxcclxuICAgICAgICAgICAgb2tCdXR0b246IHRydWUsXHJcbiAgICAgICAgICAgIGNhbmNlbEJ1dHRvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHdpZHRoOiBudWxsLFxyXG4gICAgICAgICAgICBcImNsYXNzXCI6JydcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICB0aGlzLmRhdGEuY2xhc3MgKz0gICcgbS1tb2RhbC1vcGVuJztcclxuICAgICAgICAvLyAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgLy8gfS5iaW5kKHRoaXMpLDQwMCk7XHJcbiAgICAgICAgdGhpcy5zdXByKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLnN1cHIoKTtcclxuICAgICAgICAvLyDor4HmmI7kuI3mmK/lhoXltYznu4Tku7ZcclxuICAgICAgICBpZih0aGlzLiRyb290ID09PSB0aGlzKVxyXG4gICAgICAgICAgICB0aGlzLiRpbmplY3QoZG9jdW1lbnQuYm9keSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0UGFnZSgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnm5HlkKxwYWdlcue7hOS7tueahOmhteaVsOWPmOWMllxyXG4gICAgICovXHJcbiAgICBzZWxlY3RQYWdlKCkge1xyXG4gICAgICAgIHRoaXMuJG9uKCdzZWxlY3RQYWdlJywob2JqKT0+e1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VOb3cob2JqKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNsb3NlKHJlc3VsdCkg5YWz6Zet5qih5oCB5a+56K+d5qGGXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSByZXN1bHQg54K55Ye756Gu5a6a6L+Y5piv5Y+W5raIXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBjbG9zZTogZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGV2ZW50IGNsb3NlIOWFs+mXreWvueivneahhuaXtuinpuWPkVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVzdWx0IOeCueWHu+S6huehruWumui/mOaYr+WPlua2iFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJywge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXN1bHQgPyB0aGlzLm9rKCkgOiB0aGlzLmNhbmNlbCgpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIG9rOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAZXZlbnQgb2sg56Gu5a6a5a+56K+d5qGG5pe26Kem5Y+RXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy4kZW1pdCgnb2snKTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBldmVudCBjbG9zZSDlj5bmtojlr7nor53moYbml7bop6blj5FcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgdGhpcy4kZW1pdCgnY2FuY2VsJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgfSxcclxuICAgIGtleXVwOiBmdW5jdGlvbigkZXZlbnQpIHtcclxuICAgICAgICBpZigkZXZlbnQud2hpY2ggPT0gMTMpe1xyXG4gICAgICAgICAgICB0aGlzLm9rKCk7XHJcbiAgICAgICAgICAgICRldmVudC5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhbGVydChbY29udGVudF1bLHRpdGxlXSkg5by55Ye65LiA5LiqYWxlcnTlr7nor53moYbjgILlhbPpl63ml7blp4vnu4jop6blj5Hnoa7lrprkuovku7bjgIJcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gIHtzdHJpbmc9Jyd9IGNvbnRlbnQg5a+56K+d5qGG5YaF5a65XHJcbiAqIEBwYXJhbSAge3N0cmluZz0n5o+Q56S6J30gdGl0bGUg5a+56K+d5qGG5qCH6aKYXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqL1xyXG5Nb2RhbC5hbGVydCA9IGZ1bmN0aW9uKGNvbnRlbnQsIHRpdGxlLCBva0J1dHRvbikge1xyXG4gICAgdmFyIG1vZGFsID0gbmV3IE1vZGFsKHtcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgICAgb2tCdXR0b246IG9rQnV0dG9uXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbW9kYWw7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjb25maXJtKFtjb250ZW50XVssdGl0bGVdKSDlvLnlh7rkuIDkuKpjb25maXJt5a+56K+d5qGGXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtICB7c3RyaW5nPScnfSBjb250ZW50IOWvueivneahhuWGheWuuVxyXG4gKiBAcGFyYW0gIHtzdHJpbmc9J+aPkOekuid9IHRpdGxlIOWvueivneahhuagh+mimFxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cclxuTW9kYWwuY29uZmlybSA9IGZ1bmN0aW9uKGNvbnRlbnQsIHRpdGxlLCBva0J1dHRvbiwgY2FuY2VsQnV0dG9uKSB7XHJcbiAgICB2YXIgbW9kYWwgPSBuZXcgTW9kYWwoe1xyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxyXG4gICAgICAgICAgICBva0J1dHRvbjogb2tCdXR0b24sXHJcbiAgICAgICAgICAgIGNhbmNlbEJ1dHRvbjogY2FuY2VsQnV0dG9uIHx8IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbW9kYWw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGFsO1xyXG4iLCJtb2R1bGUuZXhwb3J0cz1cIjxkaXYgY2xhc3M9XFxcIm0tbm90aWZ5IG0tbm90aWZ5LXtAKHBvc2l0aW9uKX0ge0AoY2xhc3MpfVxcXCI+ICAgIHsjbGlzdCBtZXNzYWdlcyBhcyBtZXNzYWdlfSAgICA8ZGl2IGNsYXNzPVxcXCJub3RpZnlfbWVzc2FnZSBub3RpZnlfbWVzc2FnZS17QChtZXNzYWdlLnR5cGUpfVxcXCIgci1hbmltYXRpb249XFwnb246IGVudGVyOyBjbGFzczogYW5pbWF0ZWQgZmFkZUluIGZhc3Q7IG9uOiBsZWF2ZTsgY2xhc3M6IGFuaW1hdGVkIGZhZGVPdXQgZmFzdDtcXCc+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJub3RpZnlfdGV4dFxcXCI+e0AobWVzc2FnZS50ZXh0KX08L2Rpdj4gICAgPC9kaXY+ICAgIHsvbGlzdH08L2Rpdj5cIiIsIi8qKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogTm90aWZ5ICAgIOmAmuefpVxyXG4gKiBAYXV0aG9yICAgc2Vuc2VuKHJhaW5mb3Jlc3Q5MkAxMjYuY29tKVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vYmFzZS9jb21wb25lbnQuanMnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9ub3RpZnkuaHRtbCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2Jhc2UvdXRpbC5qcycpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBOb3RpZnlcclxuICogQGV4dGVuZCBDb21wb25lbnRcclxuICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhICAgICAgICAgICAgICAgICAgICDnm5HlkKzmlbDmja5cclxuICogQHBhcmFtIHtzdHJpbmc9J3RvcGNlbnRlcid9ICAgICAgb3B0aW9ucy5kYXRhLnBvc2l0aW9uICAgICAgICAgICDpgJrnn6XnmoTkvY3nva7vvIzlj6/pgInlj4LmlbDvvJpgdG9wY2VudGVyYOOAgWB0b3BsZWZ0YOOAgWB0b3ByaWdodGDjgIFgYm90dG9tY2VudGVyYOOAgWBib3R0b21sZWZ0YOOAgWBib3R0b21yaWdodGDjgIFgc3RhdGljYFxyXG4gKiBAcGFyYW0ge251bWJlcj0yMDAwfSAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZHVyYXRpb24gICAgICAgICAgIOavj+adoea2iOaBr+eahOWBnOeVmeavq+enkuaVsO+8jOWmguaenOS4ujDvvIzliJnooajnpLrmtojmga/luLjpqbvkuI3mtojlpLHjgIJcclxuICogQHBhcmFtIHtzdHJpbmc9Jyd9ICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmNsYXNzICAgICAgICAgICAgICDooaXlhYVjbGFzc1xyXG4gKi9cclxudmFyIE5vdGlmeSA9IENvbXBvbmVudC5leHRlbmQoe1xyXG4gICAgbmFtZTogJ25vdGlmeScsXHJcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAvKipcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgY29uZmlnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBfLmV4dGVuZCh0aGlzLmRhdGEsIHtcclxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3RvcGNlbnRlcicsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxMDAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdXByKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3VwcigpO1xyXG4gICAgICAgIC8vIOivgeaYjuS4jeaYr+WGheW1jOe7hOS7tlxyXG4gICAgICAgIGlmKHRoaXMuJHJvb3QgPT09IHRoaXMpXHJcbiAgICAgICAgICAgIHRoaXMuJGluamVjdChkb2N1bWVudC5ib2R5KTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2hvdyh0ZXh0Wyx0eXBlXVssZHVyYXRpb25dKSDlvLnlh7rkuIDkuKrmtojmga9cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBwYXJhbSAge3N0cmluZz0nJ30gdGV4dCDmtojmga/lhoXlrrlcclxuICAgICAqIEBwYXJhbSAge3N0cmluZz1udWxsfSB0eXBlIOa2iOaBr+exu+Wei++8jOWPr+mAieWPguaVsO+8mmBpbmZvYOOAgWBzdWNjZXNzYOOAgWB3YXJuaW5nYOOAgWBlcnJvcmBcclxuICAgICAqIEBwYXJhbSAge251bWJlcj1ub3RpZnkuZHVyYXRpb259IGR1cmF0aW9uIOivpeadoea2iOaBr+eahOWBnOeVmeavq+enkuaVsO+8jOWmguaenOS4ujDvvIzliJnooajnpLrmtojmga/luLjpqbvkuI3mtojlpLHjgIJcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIHNob3c6IGZ1bmN0aW9uKHRleHQsIHR5cGUsIGR1cmF0aW9uKSB7XHJcblxyXG4gICAgICAgIHZhciBtZXNzYWdlID0ge1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gPj0gMCA/IGR1cmF0aW9uIDogdGhpcy5kYXRhLmR1cmF0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRhdGEubWVzc2FnZXMudW5zaGlmdChtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuXHJcbiAgICAgICAgaWYobWVzc2FnZS5kdXJhdGlvbilcclxuICAgICAgICAgICAgdGhpcy4kdGltZW91dCh0aGlzLmNsb3NlLmJpbmQodGhpcywgbWVzc2FnZSksIG1lc3NhZ2UuZHVyYXRpb24pO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGV2ZW50IHNob3cg5by55Ye65LiA5Liq5raI5oGv5pe26Kem5Y+RXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IG1lc3NhZ2Ug5by55Ye655qE5raI5oGv5a+56LGhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy4kZW1pdCgnc2hvdycsIHtcclxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY2xvc2UobWVzc2FnZSkg5YWz6Zet5p+Q5p2h5raI5oGvXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG1lc3NhZ2Ug6ZyA6KaB5YWz6Zet55qE5raI5oGv5a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBjbG9zZTogZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGF0YS5tZXNzYWdlcy5pbmRleE9mKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuZGF0YS5tZXNzYWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBldmVudCBjbG9zZSDlhbPpl63mn5DmnaHmtojmga/ml7bop6blj5FcclxuICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gbWVzc2FnZSDlhbPpl63kuobnmoTmtojmga/lr7nosaFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScsIHtcclxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjbG9zZUFsbCgpIOWFs+mXreaJgOaciea2iOaBr1xyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgY2xvc2VBbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgnbWVzc2FnZXMnLCBbXSk7XHJcbiAgICB9XHJcbn0pLnVzZSgnJHRpbWVvdXQnKTtcclxuXHJcblxyXG4vKipcclxuICog55u05o6l5Yid5aeL5YyW5LiA5Liq5a6e5L6LXHJcbiAqIEB0eXBlIHtOb3RpZnl9XHJcbiAqL1xyXG52YXIgbm90aWZ5ID0gbmV3IE5vdGlmeSgpO1xyXG5Ob3RpZnkubm90aWZ5ID0gbm90aWZ5O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2hvdyh0ZXh0Wyx0eXBlXVssZHVyYXRpb25dKSDlvLnlh7rkuIDkuKrmtojmga9cclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0gIHtzdHJpbmc9Jyd9IHRleHQg5raI5oGv5YaF5a65XHJcbiAqIEBwYXJhbSAge3N0cmluZz1udWxsfSB0eXBlIOa2iOaBr+exu+Wei++8jOWPr+mAieWPguaVsO+8mmBpbmZvYOOAgWBzdWNjZXNzYOOAgWB3YXJuaW5nYOOAgWBlcnJvcmBcclxuICogQHBhcmFtICB7bnVtYmVyPW5vdGlmeS5kdXJhdGlvbn0gZHVyYXRpb24g6K+l5p2h5raI5oGv55qE5YGc55WZ5q+r56eS5pWw77yM5aaC5p6c5Li6MO+8jOWImeihqOekuua2iOaBr+W4uOmpu+S4jea2iOWkseOAglxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cclxuTm90aWZ5LnNob3cgPSBmdW5jdGlvbigpIHtcclxuICAgIG5vdGlmeS5zaG93LmFwcGx5KG5vdGlmeSwgYXJndW1lbnRzKTtcclxufTtcclxuLyoqXHJcbiAqIEBtZXRob2QgY2xvc2UobWVzc2FnZSkg5YWz6Zet5p+Q5p2h5raI5oGvXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtICB7b2JqZWN0fSBtZXNzYWdlIOmcgOimgeWFs+mXreeahOa2iOaBr+WvueixoVxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cclxuTm90aWZ5LmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBub3RpZnkuY2xvc2UuYXBwbHkobm90aWZ5LCBhcmd1bWVudHMpO1xyXG59O1xyXG4vKipcclxuICogQG1ldGhvZCBjbG9zZUFsbCgpIOWFs+mXreaJgOaciea2iOaBr1xyXG4gKiBAc3RhdGljXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqL1xyXG5Ob3RpZnkuY2xvc2VBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgIG5vdGlmeS5jbG9zZUFsbC5hcHBseShub3RpZnksIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5Ob3RpZnkuJG9uID0gZnVuY3Rpb24oKXtcclxuICAgIG5vdGlmeS4kb24uYXBwbHkobm90aWZ5LGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgdHlwZXMgPSBbJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdpbmZvJywgJ2Vycm9yJ107XHJcbnR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xyXG4gICAgTm90aWZ5W3R5cGVdID0gZnVuY3Rpb24odGV4dCxkdXJhdGlvbikge1xyXG4gICAgICAgIE5vdGlmeS5zaG93KHRleHQsIHR5cGUsZHVyYXRpb24pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm90aWZ5OyIsIm1vZHVsZS5leHBvcnRzPVwiPCEtLXItaGlkZT17IXZpc2libGV9LS0+PHVsIGNsYXNzPVxcXCJtLXBhZ2VyIG0tcGFnZXIte0AocG9zaXRpb24pfSB7Y2xhc3N9XFxcIiB6LWRpcz17ZGlzYWJsZWR9ID4gICAgPGxpIGNsYXNzPVxcXCJwYWdlcl9wcmV2XFxcIiB6LWRpcz17Y3VycmVudCA8PSAxfSBvbi1jbGljaz17dGhpcy5zZWxlY3QoY3VycmVudCAtIDEpfT48YT7kuIrkuIDpobU8L2E+PC9saT4gICAgeyNpZiB0b3RhbCAtIG1pZGRsZSA+IHNpZGUgKiAyICsgMX0gICAgICAgIHsjbGlzdCAxLi5zaWRlIGFzIGl9ICAgICAgICA8bGkgei1jcnQ9e2N1cnJlbnQgPT0gaX0gb24tY2xpY2s9e3RoaXMuc2VsZWN0KGkpfT48YT57aX08L2E+PC9saT4gICAgICAgIHsvbGlzdH0gICAgICAgIHsjaWYgX3N0YXJ0ID4gc2lkZSArIDF9PGxpPjxzcGFuPi4uLjwvc3Bhbj48L2xpPnsvaWZ9ICAgICAgICB7I2xpc3QgX3N0YXJ0Li5fZW5kIGFzIGl9ICAgICAgICA8bGkgei1jcnQ9e2N1cnJlbnQgPT0gaX0gb24tY2xpY2s9e3RoaXMuc2VsZWN0KGkpfT48YT57aX08L2E+PC9saT4gICAgICAgIHsvbGlzdH0gICAgICAgIHsjaWYgX2VuZCA8IHRvdGFsIC0gc2lkZX08bGk+PHNwYW4+Li4uPC9zcGFuPjwvbGk+ey9pZn0gICAgICAgIHsjbGlzdCAodG90YWwgLSBzaWRlICsgMSkuLnRvdGFsIGFzIGl9ICAgICAgICA8bGkgei1jcnQ9e2N1cnJlbnQgPT0gaX0gb24tY2xpY2s9e3RoaXMuc2VsZWN0KGkpfT48YT57aX08L2E+PC9saT4gICAgICAgIHsvbGlzdH0gICAgeyNlbHNlfSAgICAgICAgeyNsaXN0IDEuLnRvdGFsIGFzIGl9ICAgICAgICA8bGkgei1jcnQ9e2N1cnJlbnQgPT0gaX0gb24tY2xpY2s9e3RoaXMuc2VsZWN0KGkpfT48YT57aX08L2E+PC9saT4gICAgICAgIHsvbGlzdH0gICAgey9pZn0gICAgPGxpIGNsYXNzPVxcXCJwYWdlcl9uZXh0XFxcIiB6LWRpcz17Y3VycmVudCA+PSB0b3RhbH0gb24tY2xpY2s9e3RoaXMuc2VsZWN0KGN1cnJlbnQgKyAxKX0+PGE+5LiL5LiA6aG1PC9hPjwvbGk+PC91bD5cIiIsIi8qKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogUGFnZXIgICAgIOWIhumhtVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2Jhc2UvY29tcG9uZW50LmpzJyk7XHJcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vcGFnZXIuaHRtbCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2Jhc2UvdXRpbC5qcycpO1xyXG5cclxuLyoqXHJcbiAqIOS9v+eUqFxyXG4gKiA8cGFnZXIgdG90YWw9e01hdGguY2VpbCh0b3RhbCAvIGxpbWl0KX0gY3VycmVudD17Y3VycmVudH0gPjwvcGFnZXI+XHJcbiAqIOWcqOS9v+eUqOeahOe7hOS7tuS4reebkeWQrGN1cnJlbnTnmoTlj5jljJbvvIxcclxuICogPHBhZ2VyIHRvdGFsPTExIG1pZGRsZT0zIHNpZGU9MSBjdXJyZW50PTYgLz5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBQYWdlclxyXG4gKiBAZXh0ZW5kIENvbXBvbmVudFxyXG4gKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgICAgICAgICAgICAgICAgICAgICA9ICDnu5HlrprlsZ7mgKdcclxuICogQHBhcmFtIHtudW1iZXI9MX0gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmN1cnJlbnQgICAgICAgICAgICA8PT4g5b2T5YmN6aG1XHJcbiAqIEBwYXJhbSB7dG90YWw9MTF9ICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50b3RhbCAgICAgICAgICAgICAgID0+IOaAu+mhteaVsFxyXG4gKiBAcGFyYW0ge3N0cmluZz0nY2VudGVyJ30gICAgICAgICBvcHRpb25zLmRhdGEucG9zaXRpb24gICAgICAgICAgICA9PiDliIbpobXnmoTkvY3nva7vvIzlj6/pgInlj4LmlbDvvJpgY2VudGVyYOOAgWBsZWZ0YOOAgWByaWdodGBcclxuICogQHBhcmFtIHttaWRkbGU9NX0gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm1pZGRsZSAgICAgICAgICAgICAgPT4g5b2T6aG15pWw6L6D5aSa5pe277yM5Lit6Ze05pi+56S655qE6aG15pWwXHJcbiAqIEBwYXJhbSB7c2lkZT0yfSAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zaWRlICAgICAgICAgICAgICAgID0+IOW9k+mhteaVsOi+g+WkmuaXtu+8jOS4pOerr+aYvuekuueahOmhteaVsFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49ZmFsc2V9ICAgICAgICAgICBvcHRpb25zLmRhdGEucmVhZG9ubHkgICAgICAgICAgICA9PiDmmK/lkKblj6ror7tcclxuICogQHBhcmFtIHtib29sZWFuPWZhbHNlfSAgICAgICAgICAgb3B0aW9ucy5kYXRhLmRpc2FibGVkICAgICAgICAgICAgPT4g5piv5ZCm56aB55SoXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj10cnVlfSAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52aXNpYmxlICAgICAgICAgICAgID0+IOaYr+WQpuaYvuekulxyXG4gKiBAcGFyYW0ge3N0cmluZz0nJ30gICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuY2xhc3MgICAgICAgICAgICAgICA9PiDooaXlhYVjbGFzc1xyXG4gKi9cclxuXHJcbnZhciBQYWdlciA9IENvbXBvbmVudC5leHRlbmQoe1xyXG4gICAgbmFtZTogJ3BhZ2VyJyxcclxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgIC8qKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBjb25maWc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF8uZXh0ZW5kKHRoaXMuZGF0YSwge1xyXG4gICAgICAgICAgICBjdXJyZW50OiAxLFxyXG4gICAgICAgICAgICB0b3RhbDogMzUsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxyXG4gICAgICAgICAgICBtaWRkbGU6IDUsXHJcbiAgICAgICAgICAgIHNpZGU6IDIsXHJcbiAgICAgICAgICAgIF9zdGFydDogMSxcclxuICAgICAgICAgICAgX2VuZDogNVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3VwcigpO1xyXG5cclxuICAgICAgICB0aGlzLiR3YXRjaChbJ2N1cnJlbnQnLCAndG90YWwnXSwgZnVuY3Rpb24oY3VycmVudCwgdG90YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnQgPSBjdXJyZW50ID0gK2N1cnJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS50b3RhbCA9IHRvdGFsID0gK3RvdGFsO1xyXG4gICAgICAgICAgICB2YXIgc2hvdyA9IHRoaXMuZGF0YS5taWRkbGU+PjE7XHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gdGhpcy5kYXRhLnNpZGU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRhdGEuX3N0YXJ0ID0gY3VycmVudCAtIHNob3c7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5fZW5kID0gY3VycmVudCArIHNob3c7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5fc3RhcnQgPCBzaWRlICsgMSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5fc3RhcnQgPSBzaWRlICsgMTtcclxuICAgICAgICAgICAgaWYodGhpcy5kYXRhLl9lbmQgPiB0b3RhbCAtIHNpZGUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuX2VuZCA9IHRvdGFsIC0gc2lkZTtcclxuICAgICAgICAgICAgaWYoY3VycmVudCAtIHRoaXMuZGF0YS5fc3RhcnQgPCBzaG93KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLl9lbmQgKz0gdGhpcy5kYXRhLl9zdGFydCAtIGN1cnJlbnQgKyBzaG93O1xyXG4gICAgICAgICAgICBpZih0aGlzLmRhdGEuX2VuZCAtIGN1cnJlbnQgPCBzaG93KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLl9zdGFydCArPSB0aGlzLmRhdGEuX2VuZCAtIGN1cnJlbnQgLSBzaG93O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLiR3YXRjaChbJ21pZGRsZScsICdzaWRlJ10sIGZ1bmN0aW9uKG1pZGRsZSwgc2lkZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEubWlkZGxlID0gK21pZGRsZTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNpZGUgPSArc2lkZTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2VsZWN0KHBhZ2UpIOmAieaLqeafkOS4gOmhtVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBwYWdlIOmAieaLqemhtVxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgc2VsZWN0OiBmdW5jdGlvbihwYWdlKSB7XHJcbiAgICAgICAgaWYodGhpcy5kYXRhLnJlYWRvbmx5IHx8IHRoaXMuZGF0YS5kaXNhYmxlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZihwYWdlIDwgMSkgcmV0dXJuO1xyXG4gICAgICAgIGlmKHBhZ2UgPiB0aGlzLmRhdGEudG90YWwpIHJldHVybjtcclxuICAgICAgICBpZihwYWdlID09IHRoaXMuZGF0YS5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5jdXJyZW50ID0gcGFnZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGV2ZW50IHNlbGVjdCDpgInmi6nmn5DkuIDpobXml7bop6blj5FcclxuICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gc2VuZGVyIOS6i+S7tuWPkemAgeWvueixoVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjdXJyZW50IOW9k+WJjemAieaLqemhtVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuJHBhcmVudC4kZW1pdCgnc2VsZWN0UGFnZScsIHtcclxuICAgICAgICAgICAgc2VuZGVyOiB0aGlzLFxyXG4gICAgICAgICAgICBjdXJyZW50OiB0aGlzLmRhdGEuY3VycmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFnZXI7IiwibW9kdWxlLmV4cG9ydHM9XCI8ZGl2IGNsYXNzPVxcXCJtLXNjaGJhclxcXCIgcmVmPVxcXCJzZWFyY2hCYXJcXFwiPiAgICA8ZGl2IGNsYXNzPVxcXCJtLXNjaFxcXCI+ICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIuaQnOe0ouWnk+WQjVxcXCIgci1tb2RlbD17YXBwTmFtZX0gaWQ9XFxcImotc2VhcmNoTmFtZVxcXCIgb24ta2V5ZG93bj17dGhpcy5fX3NlYXJjaEJ5QXBwTmFtZSgkZXZlbnQpfSBjbGFzcz1cXFwidS1pcHRcXFwiIC8+PGJ1dHRvbiBjbGFzcz1cXFwidS1idG4tc2VhcmNoXFxcIiBvbi1jbGljaz17dGhpcy5fX3NlYXJjaEJ5QXBwTmFtZSgpfT7mkJzntKI8L2J1dHRvbj4gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcIm0tc2NoXFxcIj4gICAgICAgIDxsYWJlbD7nroDljobmnaXmupDvvJo8L2xhYmVsPiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2VhcmNoVmFsc1xcXCI+ICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJzY2hPcHRpb25zXFxcIiBhdHRyPVxcXCJyZXN1bWVGcm9tXFxcIiBvbi1jbGljaz1cXFwie3RoaXMuX19jbGlja1NlYXJjaCgkZXZlbnQsXFwncmVzdW1lRnJvbVxcJywgMCl9XFxcIj4gICAgICAgICAgICAgICAgPGxpIGRhdGEtaWQ9XFxcIlxcXCIgci1jbGFzcz1cXFwie3tzZWxlY3RlZDogIXJlc3VtZUZyb219fVxcXCI+5LiN6ZmQPC9saT4gICAgICAgICAgICAgICAgeyNsaXN0IHJlc291cmNlTGlzdCBhcyBhTGlzdH0gICAgICAgICAgICAgICAgPGxpIGRhdGEtaWQ9XFxcInthTGlzdC5pZH1cXFwiIHItY2xhc3M9XFxcInt7c2VsZWN0ZWQ6IHJlc3VtZUZyb20gPT0gYUxpc3QuaWR9fVxcXCI+e2FMaXN0Lm5hbWV9PC9saT4gICAgICAgICAgICAgICAgey9saXN0fSAgICAgICAgICAgIDwvdWw+ICAgICAgICA8L2Rpdj4gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcIm0tc2NoIHBvc2l0aW9uVHlwZVxcXCI+ICAgICAgICA8bGFiZWw+6IGM5L2N57G75Yir77yaPC9sYWJlbD4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNlYXJjaFZhbHNcXFwiPiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwic2NoT3B0aW9uc1xcXCIgYXR0cj1cXFwicG9zdFR5cGVcXFwiIG9uLWNsaWNrPXt0aGlzLl9fY2xpY2tTZWFyY2goJGV2ZW50LCBcXFwicG9zdFR5cGVcXFwiLDApfT4gICAgICAgICAgICA8bGkgZGF0YS1pZD1cXFwiXFxcIiBjbGFzcz1cXFwie3Bvc3RUeXBlPyBcXCdcXCc6XFwnc2VsZWN0ZWRcXCd9XFxcIj7kuI3pmZA8L2xpPiAgICAgICAgICAgIHsjbGlzdCBwb3N0VHlwZXMgYXMgYUxpc3R9ICAgICAgICAgICAgPGxpIGRhdGEtaWQ9e2FMaXN0LmlkfSBjbGFzcz1cXFwie3Bvc3RUeXBlID09IGFMaXN0LmlkID8gXFwnc2VsZWN0ZWRcXCc6XFwnXFwnfVxcXCI+e2FMaXN0Lm5hbWV9PC9saT4gICAgICAgICAgICB7L2xpc3R9ICAgICAgICAgICAgPC91bD4gICAgICAgIDwvZGl2PiAgICA8L2Rpdj48L2Rpdj5cIiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGh6Z2FvcXVhbmthbmcgb24gMjAxNy81LzYuXHJcbiAqL1xyXG5cclxuLy8g5L2/55So5pa55byPXHJcbi8vIOWcqOeItue7hOS7tuS4reS9v+eUqCAgPHNlYXJjaCA+XHJcbi8vdGhpcy5TZWFyY2guJG9uKCdzZWFyY2gnLCB0aGlzLl9fc2VhcmNoQnlCYXIuYmluZCh0aGlzKSk7XHJcbi8vXHJcbi8vICAgIF9fc2VhcmNoQnlCYXIgPSBmdW5jdGlvbihvYmope1xyXG4vLyAgICAgICAgdGhpcy5fX3RhYmxlLmRhdGEuY3VycmVudFBhZ2UgPSAxO1xyXG4vLyAgICAgICAgdGhpcy5fX3NlYXJjaChvYmopO1xyXG4vLyAgIH07XHJcbi8vICAgIF9fc2VhcmNoID0gZnVuY3Rpb24ob2JqKXtcclxuLy8gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuLy8gICAgICAgICAgICBfc2VhcmNoSXRlbXMgPSBzZWxmLlNlYXJjaC5kYXRhLnNlYXJjaEl0ZW1zLFxyXG4vLyAgICAgICAgICAgIF9zZWFyY2hCYXJEYXRhID0gc2VsZi5TZWFyY2guZGF0YTtcclxuLy8gICAgICAgICAgICBfc2VhcmNoSXRlbXMuY3VycmVudFBhZ2UgPSBzZWxmLl9fdGFibGUuZGF0YS5jdXJyZW50UGFnZTtcclxuLy8gICAgICAgQUpBWChwYXJhbXMsZnVuY3Rpb24oZGF0YSl7fSxmdW5jdGlvbigpe30pXHJcbi8vICAgICAgIH1cclxuLy9cclxuLy9cclxuLy9cclxuLy9cclxuLy8gIFwiR0VUIC9wdHlwZS9nZXRMaXN0LmRvXCI6IGZ1bmN0aW9uKHJlcSwgcmVzLCBuZXh0KSB7XHJcbi8qICAgICAgICByZXMuc2VuZCh7XHJcbiBcImNvZGVcIjogXCIyMDBcIixcclxuIFwiZGF0YVwiOiBbe1xyXG4gaWQ6IFwiM1wiLFxyXG4gbmFtZTogXCLliY3nq69cIlxyXG4gfSwge1xyXG4gaWQ6IFwiNFwiLFxyXG4gbmFtZTogXCLlvIDlj5FcIlxyXG4gfV0sXHJcbiBcIm1zZ1wiOiBudWxsXHJcbiB9KTtcclxuIH0sXHJcblxyXG4gXCJHRVQgL2NvbW1vbi9vcHRpb25zL3Jlc3VtZWZyb20uZG9cIjogZnVuY3Rpb24ocmVxLCByZXMsIG5leHQpIHtcclxuIHJlcy5zZW5kKHtcclxuIFwiY29kZVwiOiBcIjIwMFwiLFxyXG4gXCJkYXRhXCI6IFt7XHJcbiBcImNvZGVcIjogXCJyZXN1bWVmcm9tXCIsXHJcbiBcImlkXCI6IFwiMzBcIixcclxuIFwibmFtZVwiOiBcIueMjuiBmOe9kVwiLFxyXG4gXCJhY3RpdmVcIjogbnVsbCxcclxuIFwicGFyZW50SWRcIjogXCIzXCJcclxuIH0sIHtcclxuIFwiY29kZVwiOiBcInJlc3VtZWZyb21cIixcclxuIFwiaWRcIjogXCIzMVwiLFxyXG4gXCJuYW1lXCI6IFwi5YmN56iL5peg5b+nXCIsXHJcbiBcImFjdGl2ZVwiOiBudWxsLFxyXG4gXCJwYXJlbnRJZFwiOiBcIjNcIlxyXG4gfV0sXHJcbiBcIm1zZ1wiOiBcIjNcIlxyXG4gfSk7XHJcbiB9LCovXHJcblxyXG4vL3Rlc3RcclxuLypleHBvcnRzLl9fbG9hZFBvc1R5cGVzID0gZnVuY3Rpb24ocGFyYW1zLGNhbGxiYWNrLGVycmJhY2spe1xyXG5cclxuIGFqYXgucmVxdWVzdCh7XHJcbiB1cmw6Jy9wdHlwZS9nZXRMaXN0LmRvJyxcclxuIG1ldGhvZDonR0VUJyxcclxuIGRhdGE6cGFyYW1zLFxyXG4gc3VjY2VzczpjYWxsYmFjayxcclxuIGVycm9yOmVycmJhY2tcclxuXHJcbiB9KVxyXG4gfVxyXG5cclxuIC8vdGVzdFxyXG4gZXhwb3J0cy5fX2xvYWRSZXN1bWVGcm9tID0gZnVuY3Rpb24ocGFyYW1zLGNhbGxiYWNrLGVycmJhY2spe1xyXG5cclxuIGFqYXgucmVxdWVzdCh7XHJcbiB1cmw6Jy9jb21tb24vb3B0aW9ucy9yZXN1bWVmcm9tLmRvJyxcclxuIG1ldGhvZDonR0VUJyxcclxuIGRhdGE6cGFyYW1zLFxyXG4gc3VjY2VzczpjYWxsYmFjayxcclxuIGVycm9yOmVycmJhY2tcclxuXHJcbiB9KVxyXG4gfVxyXG5cclxuICovXHJcblxyXG5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2Jhc2UvY29tcG9uZW50LmpzJyk7XHJcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vc2VhcmNoLmh0bWwnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9iYXNlL3V0aWwuanMnKTtcclxudmFyIFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XHJcblxyXG52YXIgU2VhcmNoID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICBuYW1lOidzZWFyY2gnLFxyXG4gICAgY29uZmlnOiBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICBfLmV4dGVuZChkYXRhLHtcclxuICAgICAgICAgICAgc2VhcmNoUXVlcnk6e1xyXG4gICAgICAgICAgICAgICAgXCJwb3N0U3RhdHVzXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcImFwcE5hbWVcIjpcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJwb3N0VHlwZVwiOlwiXCIsXHJcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRQYWdlXCI6MSxcclxuICAgICAgICAgICAgICAgIFwicmVzdW1lRnJvbVwiOlwiXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXBwTmFtZTpcIlwiLFxyXG4gICAgICAgICAgICByZXN1bWVGcm9tOlwiXCIsXHJcbiAgICAgICAgICAgIHBvc3RUeXBlMTpcIlwiLFxyXG4gICAgICAgICAgICBzdWJQb3N0VHlwZTpcIlwiLFxyXG4gICAgICAgICAgICBzdWJzdWJQb3N0VHlwZTpcIlwiLFxyXG4gICAgICAgICAgICByZXNvdXJjZUxpc3Q6W10sXHJcbiAgICAgICAgICAgIHNlYXJjaEl0ZW1zOntcclxuICAgICAgICAgICAgICAgIGludGVyZXN0ZWQ6dGhpcy5kYXRhLmludGVyZXN0ZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGluaXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5fX2xvYWRSZXN1bWVGcm9tKCk7XHJcbiAgICAgICAgdGhpcy5fX2xvYWRQb3NUeXBlcygtMSwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9fc2VhcmNoQnlBcHBOYW1lOiBmdW5jdGlvbihldmVudCl7XHJcblxyXG4gICAgICAgIGlmKChldmVudCAmJiBldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIGV2ZW50LndoaWNoID09IDEzKSB8fCAhZXZlbnQpe1xyXG4gICAgICAgICAgICB2YXIgX2RhdGEgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAgICAgICAgICBfc2VhcmNoSXRlbXMgPSBfZGF0YS5zZWFyY2hJdGVtcztcclxuICAgICAgICAgICAgX3NlYXJjaEl0ZW1zLmFwcE5hbWUgPSBfZGF0YS5hcHBOYW1lLnRyaW0oKTtcclxuICAgICAgICAgICAgdGhpcy5fX3NlYXJjaChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9fY2xpY2tTZWFyY2g6IGZ1bmN0aW9uKCRldmVudCwgX2F0dHIsIF9pbmRleCl7XHJcbiAgICAgICAgdmFyIF9kYXRhID0gdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICBfc2VhcmNoSXRlbXMgPSBfZGF0YS5zZWFyY2hJdGVtcyxcclxuICAgICAgICAgICAgX3RhcmdldCA9ICRldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgIF9pZCA9IF90YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKSxcclxuICAgICAgICAgICAgX2RhdGFBdHRyID0gX3RhcmdldC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcImF0dHJcIik7XHJcblxyXG4gICAgICAgIF9kYXRhW19kYXRhQXR0cl0gPSBfaWQ7XHJcblxyXG4gICAgICAgIF9zZWFyY2hJdGVtc1tfYXR0cl0gPSBfZGF0YVtfYXR0cl07XHJcbiAgICAgICAgdGhpcy5fX3NlYXJjaChudWxsKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIOaQnOe0olxyXG4gICAgICogb2JqOuS8oOmAkuS4uuS6huWMuuWIhuiBjOS9jeexu+WIq+aYr+WQpumcgOimgeabtOaNolxyXG4gICAgICovXHJcbiAgICBfX3NlYXJjaDogZnVuY3Rpb24ob2JqKXtcclxuICAgICAgICB0aGlzLiRlbWl0KCdzZWFyY2gnLG9iaik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIOiOt+WPlueugOWOhuadpea6kOWIl+ihqFxyXG4gICAgX19sb2FkUmVzdW1lRnJvbTogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICByZXNvdXJjZUxpc3QgPSBzZWxmLmRhdGEucmVzb3VyY2VMaXN0IHx8IFtdLFxyXG4gICAgICAgICAgICBoYXNTdWIgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBTZXJ2aWNlLl9fbG9hZFJlc3VtZUZyb20oe1xyXG4gICAgICAgIC8vICAgICBpZDogLTFcclxuICAgICAgICAvLyB9LGZ1bmN0aW9uKGRhdGEsanNvbil7XHJcbiAgICAgICAgLy8gICAgIHNlbGYuZGF0YS5yZXNvdXJjZUxpc3QgPSBqc29uLmRhdGE7XHJcbiAgICAgICAgLy8gfSxmdW5jdGlvbigpe30pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyDojrflj5bogYzkvY3liJfooahcclxuICAgIF9fbG9hZFBvc1R5cGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBzZGF0YSA9IHNlbGYuZGF0YTtcclxuXHJcbiAgICAgICAgLy8gU2VydmljZS5fX2xvYWRQb3NUeXBlcyh7XHJcbiAgICAgICAgLy8gICAgIGlkOiAwXHJcbiAgICAgICAgLy8gfSxmdW5jdGlvbihkYXRhLGpzb24pe1xyXG4gICAgICAgIC8vICAgICBzZGF0YS5wb3N0VHlwZSA9ICcnO1xyXG4gICAgICAgIC8vICAgICBzZGF0YS5wb3N0VHlwZXMgPSBqc29uLmRhdGE7XHJcbiAgICAgICAgLy8gICAgIHNlbGYuJHVwZGF0ZSgpO1xyXG4gICAgICAgIC8vIH0sZnVuY3Rpb24oKXt9KTtcclxuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZWFyY2g7IiwibW9kdWxlLmV4cG9ydHM9XCI8ZGl2IGNsYXNzPVxcXCJtLWFkbWluXFxcIj4gICAgPGRpdiBjbGFzcz1cXFwiYWRtLWhlYWRlciBmLXByXFxcIj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImhlYWRlci1sZWZ0XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaGVhZGVyLXRpdGxlXFxcIj7njI7lpLTlhazlj7g8L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImhlYWRlci1udW1cXFwiPuato+WcqOWQr+eUqDxhPjIzPC9hPuWutjwvc3Bhbj4gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyLXJpZ2h0XFxcIiA+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmlnaHQtc2VhcmNoXFxcIj4gICAgICAgICAgICAgICAgPGlucHV0IHBsYWNlaG9sZGVyPVxcXCLovpPlhaXnjI7lpLTlhazlj7jlkI3np7BcXFwiIGNsYXNzPVxcXCJzZWFyY2gtaW5wXFxcIj4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNlYXJjaC1idG5cXFwiPuaQnOe0ojwvc3Bhbj4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNlYXJjaC1pY29uXFxcIj48L3NwYW4+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJpZ2h0LWFkZEh1bnRlclxcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJhZGRIdW50ZXItaWNvblxcXCI+PC9zcGFuPiAgICAgICAgICAgICAgICDmlrDlop7njI7lpLQgICAgICAgICAgICA8L3NwYW4+ICAgICAgICA8L2Rpdj4gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImFkbS10aGVhZFxcXCI+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxNFxcXCI+54yO5aS05YWs5Y+4PC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgc3BhbjEyNC1hY3RpdmVcXFwiPuWFqOmDqOeKtuaAgTxzcGFuIGNsYXNzPVxcXCJhcnJvd0Rvd25cXFwiPjwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3RhdHVzLWZyYW1lXFxcIj4gICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCI+5YWo6YOo54q25oCBIDxhPjI2PC9hPjwvbGFiZWw+PGJyPiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIj7lkK/nlKjkuK0gPGE+MjY8L2E+PC9sYWJlbD48YnI+ICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiPuW3suWBnOeUqCA8YT4yNjwvYT48L2xhYmVsPiAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgIDwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuNTEwXFxcIj7nmbvlvZXluJDlj7c8L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIyMFxcXCI+5pON5L2cPC9zcGFuPiAgICA8L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwiYWRtLWNvbnRlbnRcXFwiPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMTRcXFwiPue/sOW+tyhIdWRzb24pPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuNTEwXFxcIj48YT5hYWFAMTYzLmNvbTwvYT4gPGE+YWFhQDE2My5jb208L2E+PGkgY2xhc3M9XFxcImFycm93RG93blxcXCI+PC9pPjwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjIwXFxcIj48YSBjbGFzcz1cXFwic3Bhbi1sZWZ0IHJlZFxcXCI+5YGc55SoPC9hPiAg772cICA8YSBjbGFzcz1cXFwic3Bhbi1yaWdodCBjbGljay1yZWRcXFwiIG9uLWNsaWNrPXt0aGlzLmdvSHVudGVyRGV0YWlsKCl9PueuoeeQhjwvYT4gPC9zcGFuPiAgICA8L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwibGluZVxcXCI+PC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImFkbS1jb250ZW50XFxcIj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjE0XFxcIj7nv7DlvrcoSHVkc29uKTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMTI0IGdyZWVuXFxcIj7lkK/nlKjkuK08L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjUxMFxcXCI+PGE+YWFhQDE2My5jb208L2E+IDxhPmFhYUAxNjMuY29tPC9hPjxpIGNsYXNzPVxcXCJhcnJvd0Rvd25cXFwiPjwvaT48L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIyMFxcXCI+PGEgY2xhc3M9XFxcInNwYW4tbGVmdCByZWRcXFwiPuWBnOeUqDwvYT4gIO+9nCAgPGEgY2xhc3M9XFxcInNwYW4tcmlnaHQgY2xpY2stcmVkXFxcIiBvbi1jbGljaz17dGhpcy5nb0h1bnRlckRldGFpbCgpfT7nrqHnkIY8L2E+IDwvc3Bhbj4gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImxpbmVcXFwiPjwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJhZG0tY29udGVudFxcXCI+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxNFxcXCI+57+w5b63KEh1ZHNvbik8L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjEyNCBncmVlblxcXCI+5ZCv55So5LitPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW41MTBcXFwiPjxhPmFhYUAxNjMuY29tPC9hPiA8YT5hYWFAMTYzLmNvbTwvYT48aSBjbGFzcz1cXFwiYXJyb3dEb3duXFxcIj48L2k+PC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMjBcXFwiPjxhIGNsYXNzPVxcXCJzcGFuLWxlZnQgcmVkXFxcIj7lgZznlKg8L2E+ICDvvZwgIDxhIGNsYXNzPVxcXCJzcGFuLXJpZ2h0IGNsaWNrLXJlZFxcXCIgb24tY2xpY2s9e3RoaXMuZ29IdW50ZXJEZXRhaWwoKX0+566h55CGPC9hPiA8L3NwYW4+ICAgIDwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwiYWRtLWNvbnRlbnRcXFwiPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMTRcXFwiPue/sOW+tyhIdWRzb24pPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuNTEwXFxcIj48YT5hYWFAMTYzLmNvbTwvYT4gPGE+YWFhQDE2My5jb208L2E+PGkgY2xhc3M9XFxcImFycm93RG93blxcXCI+PC9pPjwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjIwXFxcIj48YSBjbGFzcz1cXFwic3Bhbi1sZWZ0IHJlZFxcXCI+5YGc55SoPC9hPiAg772cICA8YSBjbGFzcz1cXFwic3Bhbi1yaWdodCBjbGljay1yZWRcXFwiIG9uLWNsaWNrPXt0aGlzLmdvSHVudGVyRGV0YWlsKCl9PueuoeeQhjwvYT4gPC9zcGFuPiAgICA8L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwibGluZVxcXCI+PC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImFkbS1jb250ZW50XFxcIj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjE0XFxcIj7nv7DlvrcoSHVkc29uKTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMTI0IGdyZWVuXFxcIj7lkK/nlKjkuK08L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjUxMFxcXCI+PGE+YWFhQDE2My5jb208L2E+IDxhPmFhYUAxNjMuY29tPC9hPjxpIGNsYXNzPVxcXCJhcnJvd0Rvd25cXFwiPjwvaT48L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIyMFxcXCI+PGEgY2xhc3M9XFxcInNwYW4tbGVmdCByZWRcXFwiPuWBnOeUqDwvYT4gIO+9nCAgPGEgY2xhc3M9XFxcInNwYW4tcmlnaHQgY2xpY2stcmVkXFxcIiBvbi1jbGljaz17dGhpcy5nb0h1bnRlckRldGFpbCgpfT7nrqHnkIY8L2E+IDwvc3Bhbj4gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImxpbmVcXFwiPjwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJhZG0tY29udGVudFxcXCI+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxNFxcXCI+57+w5b63KEh1ZHNvbik8L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjEyNCBncmVlblxcXCI+5ZCv55So5LitPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW41MTBcXFwiPjxhPmFhYUAxNjMuY29tPC9hPiA8YT5hYWFAMTYzLmNvbTwvYT48aSBjbGFzcz1cXFwiYXJyb3dEb3duXFxcIj48L2k+PC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMjBcXFwiPjxhIGNsYXNzPVxcXCJzcGFuLWxlZnQgcmVkXFxcIj7lgZznlKg8L2E+ICDvvZwgIDxhIGNsYXNzPVxcXCJzcGFuLXJpZ2h0IGNsaWNrLXJlZFxcXCIgb24tY2xpY2s9e3RoaXMuZ29IdW50ZXJEZXRhaWwoKX0+566h55CGPC9hPiA8L3NwYW4+ICAgIDwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwiYWRtLWNvbnRlbnRcXFwiPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMTRcXFwiPue/sOW+tyhIdWRzb24pPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuNTEwXFxcIj48YT5hYWFAMTYzLmNvbTwvYT4gPGE+YWFhQDE2My5jb208L2E+PGkgY2xhc3M9XFxcImFycm93RG93blxcXCI+PC9pPjwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjIwXFxcIj48YSBjbGFzcz1cXFwic3Bhbi1sZWZ0IHJlZFxcXCI+5YGc55SoPC9hPiAg772cICA8YSBjbGFzcz1cXFwic3Bhbi1yaWdodCBjbGljay1yZWRcXFwiIG9uLWNsaWNrPXt0aGlzLmdvSHVudGVyRGV0YWlsKCl9PueuoeeQhjwvYT4gPC9zcGFuPiAgICA8L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwibGluZVxcXCI+PC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImFkbS1jb250ZW50XFxcIj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjE0XFxcIj7nv7DlvrcoSHVkc29uKTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMTI0IGdyZWVuXFxcIj7lkK/nlKjkuK08L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjUxMFxcXCI+PGE+YWFhQDE2My5jb208L2E+IDxhPmFhYUAxNjMuY29tPC9hPjxpIGNsYXNzPVxcXCJhcnJvd0Rvd25cXFwiPjwvaT48L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIyMFxcXCI+PGEgY2xhc3M9XFxcInNwYW4tbGVmdCByZWRcXFwiPuWBnOeUqDwvYT4gIO+9nCAgPGEgY2xhc3M9XFxcInNwYW4tcmlnaHQgY2xpY2stcmVkXFxcIiBvbi1jbGljaz17dGhpcy5nb0h1bnRlckRldGFpbCgpfT7nrqHnkIY8L2E+IDwvc3Bhbj4gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImxpbmVcXFwiPjwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJhZG0tY29udGVudFxcXCI+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxNFxcXCI+57+w5b63KEh1ZHNvbik8L3NwYW4+ICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjEyNCBncmVlblxcXCI+5ZCv55So5LitPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW41MTBcXFwiPjxhPmFhYUAxNjMuY29tPC9hPiA8YT5hYWFAMTYzLmNvbTwvYT48aSBjbGFzcz1cXFwiYXJyb3dEb3duXFxcIj48L2k+PC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMjBcXFwiPjxhIGNsYXNzPVxcXCJzcGFuLWxlZnQgcmVkXFxcIj7lgZznlKg8L2E+ICDvvZwgIDxhIGNsYXNzPVxcXCJzcGFuLXJpZ2h0IGNsaWNrLXJlZFxcXCIgb24tY2xpY2s9e3RoaXMuZ29IdW50ZXJEZXRhaWwoKX0+566h55CGPC9hPiA8L3NwYW4+ICAgIDwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwiYWRtLWNvbnRlbnRcXFwiPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMTRcXFwiPue/sOW+tyhIdWRzb24pPC9zcGFuPiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuNTEwXFxcIj48YT5hYWFAMTYzLmNvbTwvYT4gPGE+YWFhQDE2My5jb208L2E+PGkgY2xhc3M9XFxcImFycm93RG93blxcXCI+PC9pPjwvc3Bhbj4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjIwXFxcIj48YSBjbGFzcz1cXFwic3Bhbi1sZWZ0IHJlZFxcXCI+5YGc55SoPC9hPiAg772cICA8YSBjbGFzcz1cXFwic3Bhbi1yaWdodCBjbGljay1yZWRcXFwiIG9uLWNsaWNrPXt0aGlzLmdvSHVudGVyRGV0YWlsKCl9PueuoeeQhjwvYT4gPC9zcGFuPiAgICA8L2Rpdj4gICAgPGRpdiBjbGFzcz1cXFwibGluZVxcXCI+PC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImFkbS1ib3R0b21cXFwiPiAgICAgICAgPHBhZ2VyPjwvcGFnZXI+ICAgIDwvZGl2PjwvZGl2PlwiIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgaHpjaGVuZ3NodWxpIG9uIDIwMTYvMTAvMjguXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vYmFzZS9jb21wb25lbnQnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9pbmRleC5odG1sJyk7XHJcbnZhciBNb2RhbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9tb2RhbC5qcycpO1xyXG52YXIgTWFzayA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9tYXNrLmpzJyk7XHJcblxyXG52YXIgQ29va2llID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9zcmMvanMuY29va2llLmpzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vYmFzZS91dGlsLmpzJyk7XHJcbnZhciBQYWdlciA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9wYWdlci5qcycpO1xyXG5cclxudmFyIEFkbWluID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcbiAgICB0ZW1wbGF0ZTp0ZW1wbGF0ZSxcclxuICAgIGNvbmZpZygpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWinuWKoOeMjuWktFxyXG4gICAgICovXHJcbiAgICBhZGRIdW50ZXIoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWQr+eUqOeMjuWktFxyXG4gICAgICovXHJcbiAgICB1c2VIdW50ZXIoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWBnOatouS9v+eUqOeMjuWktFxyXG4gICAgICovXHJcbiAgICBzdG9wSHVudGVyKCl7XHJcbiAgICB9LFxyXG5cclxuICAgIGdvSHVudGVyRGV0YWlsKCkge1xyXG4gICAgICAgIHRoaXMuJHN0YXRlLmdvKCdhcHAuaHVudGVyRGV0YWlsJyk7XHJcbiAgICB9XHJcbn0pXHJcblxyXG5BZG1pbi5jb21wb25lbnQoJ1BhZ2VyJyxQYWdlcik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkbWluO1xyXG4iLCJtb2R1bGUuZXhwb3J0cz1cIjxkaXYgY2xhc3M9XFxcImctaGRcXFwiIHJlZj1cXFwiYXBwXFxcIj5cdDxkaXYgY2xhc3M9XFxcIm0taGRcXFwiPlx0XHQ8ZGl2IGNsYXNzPVxcXCJoZWFkZXItbG9nbyBmLWliIFxcXCI+XHRcdFx0PGEgaHJlZj1cXFwiIy9ob21lXFxcIj48aW1nIHNyYz1cXFwiLi9lbnRyeS9pbWcvaHVudGVyLnBuZ1xcXCIgYWx0PVxcXCJcXFwiIGhlaWdodD1cXFwiNDBweFxcXCI+PC9hPlx0XHQ8L2Rpdj4gICAgICAgIHsjaWYgdXNlcn1cdFx0PGRpdiBjbGFzcz1cXFwiaGVhZGVyLWNlbGxzIGYtaWIgXFxcIj5cdFx0XHQ8dWwgY2xhc3M9XFxcIm0tbmF2LXRvcCBmLWNiXFxcIj5cdFx0XHRcdHsjbGlzdCBuYXZzIGFzIHh9XHRcdFx0XHQ8bGkgY2xhc3M9XFxcImYtaWJcXFwiPlx0XHRcdFx0XHQ8YSBocmVmPVxcXCJ7eC51cmx9XFxcIiByLWNsYXNzPXt7XFwnei1jcnRcXCc6dGhpcy5pc1NlbGVjdGVkKHgubWF0Y2gpfX0gIG9uLWNsaWNrPXt0aGlzLm9uU2VsZWN0ZWQoeF9pbmRleCl9Pnt4Lm5hbWV9PC9hPlx0XHRcdFx0PC9saT5cdFx0XHRcdHsvbGlzdH1cdFx0XHQ8L3VsPlx0XHQ8L2Rpdj5cdFx0PGRpdiBjbGFzcz1cXFwibG9naW4tcmlnaHQgZi1pYiBmLWZyXFxcIj5cdFx0PGRpdiBjbGFzcz1cXFwibG9naW4tcmlnaHQtZGl2XFxcIj5cdFx0XHQ8aSBjbGFzcz1cXFwidXNlci1uYW1lXFxcIj48L2k+XHRcdFx0PHNwYW4gY2xhc3M9XFxcInVzZXJuYW1lLXNwYW5cXFwiPnt1c2VyfTwvc3Bhbj58XHRcdFx0PHNwYW4gY2xhc3M9XFxcInBvaW50ZXItc3BhblxcXCIgb24tY2xpY2s9XFxcInt0aGlzLmNoYW5nZVB3ZCgpfVxcXCI+5L+u5pS55a+G56CBPC9zcGFuPnxcdFx0XHQ8c3BhbiBjbGFzcz1cXFwicG9pbnRlci1zcGFuXFxcIiBvbi1jbGljaz1cXFwie3RoaXMubG9nb3V0KCl9XFxcIj48c3Bhbj7pgIDlh7o8L3NwYW4+PGkgY2xhc3M9XFxcInVzZXItZXhpdFxcXCI+PC9pPjwvc3Bhbj48L2Rpdj5cdFx0PC9kaXY+XHRcdHsvaWZ9XHQ8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJnLW1uYyBcXFwiIHItY2xhc3M9e3tcXCdnLW1uYy0xXFwnOnRoaXMuJHN0YXRlLmN1cnJlbnQubmFtZT09XFwnYXBwLmhvbWUuaW5kZXhcXCd9fSByZWY9dmlldz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJnLWZ0XFxcIj5cdDxkaXYgY2xhc3M9XFxcImZvb3Rlcl9saW5rc1xcXCI+XHRcdDxkaXYgY2xhc3M9XFxcImNvcHlyaWdodFxcXCI+XHRcdFx0wqkxOTk3LXtuZXdZZWFyfee9keaYk+WFrOWPuOeJiOadg+aJgOaciVx0XHQ8L2Rpdj5cdDwvZGl2PjwvZGl2PlwiIiwidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvY29tcG9uZW50Jyk7XHJcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYXBwLmh0bWwnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi9iYXNlL3V0aWwuanMnKTsgXHJcbnZhciBDb29raWUgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9zcmMvanMuY29va2llLmpzJyk7XHJcbnZhciBjYWNoZVNlcnZlciA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2UuanMnKTtcclxudmFyIEVtaXQgPSAgcmVxdWlyZSgnLi4vLi4vYmFzZS9lbWl0LmpzJyk7XHJcbnZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvY29uc3RhbnQuanMnKTtcclxuXHJcbnZhciBBcHAgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuXHR0ZW1wbGF0ZTp0ZW1wbGF0ZSxcclxuXHRjb25maWc6ZnVuY3Rpb24oKXtcclxuXHJcblx0XHRsZXQgZGF0YT10aGlzLmRhdGE7XHJcbiAgICAgICAgZGF0YS51c2VyID0gIENvb2tpZS5nZXQoJ3Bhc3Nwb3J0JykgfHwgbnVsbDsgICAgLy/nlKjmiLflkI1cclxuICAgICAgICBkYXRhLnVzZXJUeXBlPUNvb2tpZS5nZXQoJ3VzZXJUeXBlJykgfHwgbnVsbDsgIC8v55So5oi357G75Z6LXHJcbiAgICAgICAgZGF0YS5uZXdZZWFyICA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcclxuXHRcdHRoaXMuJHVwZGF0ZSgpO1xyXG5cdH0sXHJcblx0aW5pdDpmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8v5rOo5YaMbmF2U2hvd1xyXG4gICAgICAgIEVtaXQub2JzZXJ2ZXIucmVnaXN0KCduYXZTaG93JywoKT0+e3RoaXMubmF2U2hvdygpfSlcclxuXHRcdC8v5rOo5YaMbmF2QWRkXHJcbiAgICAgICAgRW1pdC5vYnNlcnZlci5yZWdpc3QoJ25hdkFkZCcsICgpPT4ge3RoaXMubmF2QWRkKCl9KVxyXG5cdFx0aWYgKHRoaXMuZGF0YS51c2VyVHlwZSl7XHJcbiAgICAgICAgICAgIHRoaXMubmF2QWRkKCk7XHJcbiAgICAgICAgfVxyXG5cdFx0dGhpcy4kdXBkYXRlKCk7XHJcblx0fSxcclxuXHJcbiAgICAvKipcclxuXHQgKiDnlKjkuo7mmL7npLrlr7zoiKrmoI9cclxuICAgICAqL1xyXG5cdG5hdkFkZDpmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0bGV0IGRhdGE9dGhpcy5kYXRhO1xyXG5cdFx0ZGF0YS51c2VyVHlwZT1Db29raWUuZ2V0KCd1c2VyVHlwZScpO1xyXG5cdFx0ZGF0YS5uYXZzPSAoZGF0YS51c2VyVHlwZT09Y29uc3RhbnQuQURNSU4/Y29uc3RhbnQuQURNSU5OQVZTOmNvbnN0YW50LlVTRVJOQVZTKTtcclxuICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIOeZu+W9leaIkOWKn+WQjuaYvuekuuWvvOiIqlxyXG5cdCAqIEBwYXJhbSByZXNcclxuXHQgKi9cclxuXHRuYXZTaG93OmZ1bmN0aW9uKCl7XHJcblx0XHR0aGlzLmRhdGEudXNlciA9IENvb2tpZS5nZXQoJ3Bhc3Nwb3J0Jyk7XHJcblx0XHR0aGlzLiR1cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuICAgIC8qKlxyXG5cdCAqIOeUqOS6juaYvuekuuiiq+mAieS4reeahOeKtuaAgVxyXG4gICAgICogQHBhcmFtIG1hdGNoICAgICAgICAg5a+86Iiq5qCP55qEbWF0Y2jlgLxcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgIOi/lOWbnuW9k+WJjei3r+eUseeahG1hdGNo5YC8XHJcbiAgICAgKi9cclxuXHRpc1NlbGVjdGVkOmZ1bmN0aW9uKG1hdGNoKXtcclxuXHJcblx0XHR2YXIgaXNNYXRjaCA9IG5ldyBSZWdFeHAobWF0Y2gpO1xyXG5cdFx0cmV0dXJuIGlzTWF0Y2gudGVzdCh0aGlzLiRzdGF0ZS5jdXJyZW50Lm5hbWUpXHJcblx0fSxcclxuXHJcbiAgICAvKipcclxuXHQgKlxyXG4gICAgICogQHBhcmFtIGluZGV4IOebruWJjeiiq+mAieS4reeahOe0ouW8lVxyXG4gICAgICovXHJcblx0b25TZWxlY3RlZDogZnVuY3Rpb24oaW5kZXgpe1xyXG5cclxuXHRcdHRoaXMuZGF0YS5jdXJyZW50SW5kZXggPSBpbmRleDtcclxuXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICog5b+Y6K6w5a+G56CB6Lez6L2sXHJcblx0ICovXHJcblx0Y2hhbmdlUHdkOmZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0dGhpcy4kc3RhdGUubmF2KCcvY2hhbmdlcHdkJyk7XHJcblx0fSxcclxuXHJcbiAgICAvKipcclxuXHQgKiDnmbvlh7rmk43kvZxcclxuICAgICAqL1xyXG5cdGxvZ291dDpmdW5jdGlvbigpe1xyXG5cdFx0Y2FjaGVTZXJ2ZXIubG9nb3V0KGZ1bmN0aW9uKGRhdGEscmVzdWx0KXtcclxuXHRcdFx0Q29va2llLnJlbW92ZSgncGFzc3BvcnQnKTtcclxuICAgICAgICAgICAgQ29va2llLnJlbW92ZSgndXNlclR5cGUnKTtcclxuXHRcdFx0dGhpcy4kc3RhdGUubmF2KCcvbG9naW4nKTtcclxuXHRcdFx0bG9jYXRpb24ucmVsb2FkKHRydWUpO1xyXG5cdFx0fS5iaW5kKHRoaXMpLGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kc3RhdGUubmF2KCcvbG9naW4nKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcblx0fVxyXG5cclxufSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXBwOyIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwibS1kZXRhaWxcXFwiPiAgICA8ZGl2IGNsYXNzPVxcXCJkZXRhaWwgZi1jYlxcXCI+ICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcIj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwb3NpdGlvbi1uYW1lXFxcIj4gICAgICAgICAgICAgICAge2RldGFpbC5wb3NpdGlvbk5hbWV9ICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyaWFuZ2xlXFxcIj48L2Rpdj4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zaXRpb24taXRlbVxcXCI+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5vcm1hbFxcXCI+6IGM5L2N57G75YirPGJyPjxhIGNsYXNzPVxcXCJiZ0ZvbnRcXFwiPntkZXRhaWwucG9zaXRpb25UeXBlTmFtZX08L2E+PC9zcGFuPjxhIGNsYXNzPVxcXCJsaW5lXFxcIj48L2E+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5vcm1hbFxcXCI+5bel5L2c5Zyw54K5PGJyPjxhIGNsYXNzPVxcXCJiZ0ZvbnRcXFwiPntkZXRhaWwud29ya1BsYWNlTmFtZX08L2E+PC9zcGFuPjxhIGNsYXNzPVxcXCJsaW5lXFxcIj48L2E+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5vcm1hbFxcXCI+5bel5L2c5bm06ZmQPGJyPjxhIGNsYXNzPVxcXCJiZ0ZvbnRcXFwiPntkZXRhaWwud29ya1llYXJzTmFtZX08L2E+PC9zcGFuPjxhIGNsYXNzPVxcXCJsaW5lXFxcIj48L2E+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5vcm1hbFxcXCI+5pyA5L2O5a2m5Y6GPGJyPjxhIGNsYXNzPVxcXCJiZ0ZvbnRcXFwiPntkZXRhaWwudG9wRGVncmVlTmFtZX08L2E+PC9zcGFuPjxhIGNsYXNzPVxcXCJsaW5lXFxcIj48L2E+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5vcm1hbFxcXCI+5oub6IGY5Lq65pWwPGJyPjxhIGNsYXNzPVxcXCJiZ0ZvbnRcXFwiPntkZXRhaWwuaGlyZU51bX08L2E+PC9zcGFuPjxhIGNsYXNzPVxcXCJsaW5lXFxcIj48L2E+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5vcm1hbFxcXCI+5pqC5a6a57qn5YirJm5ic3A7ICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGYtcHJcXFwiIG9uLW1vdXNlb3Zlcj17dGhpcy5zaG93SWNvbih0cnVlKX0gb24tbW91c2VvdXQ9e3RoaXMuc2hvd0ljb24oZmFzbGUpfT4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImljb24tY29udGVudFxcXCIgci1oaWRlPXshc2hvd30+ICAgICAgICAgICAgICAgICAgICAgICAg5LuF5L2c5o6o6I2Q5Y+C6ICD77yM5LiO5YCZ6YCJ5Lq65pyA57uIb2ZmZXLlrprnuqfml6DlhbMgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICA8L2k+PGJyPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiYmdGb250XFxcIj57ZGV0YWlsLmxldmVsfTwvYT4gICAgICAgICAgICA8L3NwYW4+PGEgY2xhc3M9XFxcImxpbmVcXFwiPjwvYT4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGFzdFxcXCI+SFLmhI/lkJE8YnI+PGEgY2xhc3M9XFxcImJnRm9udFxcXCIgPntkZXRhaWwuSFJXaWxsfTwvYT48L3NwYW4+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBvc2l0aW9uLWRldGFpbFxcXCI+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGV0YWlsLWRlY1xcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJkZWMtaGVhZGVyXFxcIj7lspfkvY3mj4/ov7A8L3NwYW4+ICAgICAgICAgICAgICAgIDxwIHItaHRtbD17ZGV0YWlsLnBvc2l0aW9uRHNjfT4gICAgICAgICAgICAgICAgPC9wPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRldGFpbC1yZXFcXFwiPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVxLWhlYWRlclxcXCI+5bKX5L2N6KaB5rGCPC9zcGFuPiAgICAgICAgICAgICAgICA8cCByLWh0bWw9e2RldGFpbC5wb3NpdGlvblJlcX0+ICAgICAgICAgICAgICAgIDwvcD4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkZWF0aWwtZm9vdGVyIFxcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYnV0dG9uXFxcIiBvbi1jbGljaz17dGhpcy5zdWJtaXQoKX0+ICAgICAgICAgICAgICAgICAgICAgICAg5oiR6KaB5o6o6I2QICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvb3Rlci1tYWlsIC5mLWNiXFxcIj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtYWlsLXRpdGxlXFxcIj7mi5vogZjotJ/otKPkuro6PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1haWwtcGVyc29uXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICB7I2xpc3QgZGV0YWlsLnBvc3Rpb25Vc2VyTmFtZUxpc3QgYXMgaXRlbX0gICAgICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW0ubmFtZX0gfCB7aXRlbS5lbWFpbH08YnI+ICAgICAgICAgICAgICAgICAgICAgICAgey9saXN0fSAgICAgICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICA8L2Rpdj48L2Rpdj5cIiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGh6Z2FvcXVhbmthbmcgb24gMjAxNy81LzEuXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vYmFzZS9jb21wb25lbnQnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9pbmRleC5odG1sJyk7XHJcbnZhciBjYWNoZVNlcnZpY2UgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlLmpzJyk7XHJcblxyXG52YXIgRGV0YWlsID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcbiAgICB0ZW1wbGF0ZTp0ZW1wbGF0ZSxcclxuXHJcblxyXG5cclxuICAgIGNvbmZpZygpIHtcclxuICAgICAgICB0aGlzLmRhdGEuc2hvdz1mYWxzZTsgIC8v5Zu+5qCH6buY6K6k5LiN5pi+56S6XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQoKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvL+iOt+WPlmlkXHJcbiAgICBlbnRlcihvcHRpb24pe1xyXG4gICAgICAgbGV0IGlkPXRoaXMuZGF0YS5pZD1vcHRpb24ucGFyYW0uaWQ7XHJcbiAgICAgICB0aGlzLl9fZ2V0UG9zaXRpb25EZXRhaWwoaWQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeCueWHu+aIkeimgeaOqOiNkOaMiemSrlxyXG4gICAgICovXHJcbiAgICBzdWJtaXQoKSB7XHJcbiAgICAgICAgbGV0IGlkPXRoaXMuZGF0YS5pZDtcclxuICAgICAgICB0aGlzLiRzdGF0ZS5nbygnYXBwLnVwbG9hZCcse3BhcmFtOntpZDppZH19KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBob3ZlcuaXtiDlsZXnpLpcclxuICAgICAqL1xyXG4gICAgc2hvd0ljb24oYm9vbCl7XHJcbiAgICAgICAgdGhpcy5kYXRhLnNob3c9Ym9vbDtcclxuICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bor6bmg4XpobVcclxuICAgICAqIEBwYXJhbSBpZCDogYzkvY3nvJblj7dcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9fZ2V0UG9zaXRpb25EZXRhaWwoaWQpe1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bogYzkvY3or6bnu4bkv6Hmga87XHJcbiAgICAgICAgICogQHBhcmFtIOiBjOS9jee8luWPt1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhY2hlU2VydmljZS5nZXRQb3NpdGlvbkRldGFpbChpZCxyZXN1bHQ9PntcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmRldGFpbD1yZXN1bHQ7XHJcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGV0YWlsOyIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwiaHVudGVyXFxcIj4gICAg6L+Z5piv5o6o6I2Q6aG16Z2iPC9kaXY+XCIiLCJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vYmFzZS9jb21wb25lbnQnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9pbmRleC5odG1sJyk7XHJcbnZhciBDb29raWUgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtY29va2llL3NyYy9qcy5jb29raWUuanMnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi9iYXNlL3V0aWwuanMnKTtcclxudmFyIGNhY2hlU2VydmljZSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2UuanMnKTtcclxuXHJcbnZhciBIZWFkaHVudGVyID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcbiAgICB0ZW1wbGF0ZTp0ZW1wbGF0ZSxcclxuICAgIGNvbmZpZzpmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuICAgIGluaXQ6ZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH1cclxuXHJcbn0pXHJcblxyXG5tb2R1bGUuZXhwb3J0cz1IZWFkaHVudGVyOyIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwibS1ob21lXFxcIj4gICAgPGRpdiBjbGFzcz1cXFwiaG9tZVxcXCIgPiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaG9tZS1zZWFyY2hcXFwiID4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzZWFyY2gtbGluZVxcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzZWFyY2gtaWNvblxcXCI+PC9zcGFuPiAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcInNlYXJjaC1pbnB1dFxcXCIgci1tb2RlbD17c2VhcmNoVmFsdWV9IHBsYWNlaG9sZGVyPVxcXCLor7fovpPlhaXogYzkvY3lhbPplK7or41cXFwiLz4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2VhcmNoLWJ1dHRvblxcXCIgIG9uLWNsaWNrPXt0aGlzLnNlYXJjaEJ1dHRvbigpfT7mkJzntKI8L3NwYW4+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImhvbWUtaGVhZGVyXFxcIj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzZWxlY3Qtb3B0aW9uc1xcXCI+ICAgICAgICAgICAgICAgIDxzcGFuPuW3peS9nOWcsOeCue+8mjwvc3Bhbj4gICAgICAgICAgICAgICAgeyNpZiB3b3JrUGxhY2VMaXN0fSAgICAgICAgICAgICAgICAgICAgeyNsaXN0IHdvcmtQbGFjZUxpc3QgYXMgaXRlbX0gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBvbi1jbGljaz17dGhpcy5jbGlja09wdGlvbihcXCd3b3JrUGxhY2VMaXN0RmxhZ1xcJyxpdGVtX2luZGV4KX0gY2xhc3M9e2ZsYWdzLndvcmtQbGFjZUxpc3RGbGFnW2l0ZW1faW5kZXhdPT10cnVlP1xcJ2xpdmVcXCc6XFwnXFwnfT57d29ya1BsYWNlTGlzdEZsYWdbaXRlbV9pbmRleF09PXRydWU/XFwnbGl2ZVxcJzpcXCdcXCd9e2l0ZW0ubmFtZX08L3NwYW4+ICAgICAgICAgICAgICAgICAgICB7L2xpc3R9ICAgICAgICAgICAgICAgIHsvaWZ9ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2VsZWN0LW9wdGlvbnNcXFwiPiAgICAgICAgICAgICAgICA8c3Bhbj7lt6XkvZzlubTpmZDvvJo8L3NwYW4+ICAgICAgICAgICAgICAgIHsjaWYgd29ya1BsYWNlTGlzdH0gICAgICAgICAgICAgICAgICAgIHsjbGlzdCB3b3JrWWVhcnNMaXN0IGFzIGl0ZW19ICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gb24tY2xpY2s9e3RoaXMuY2xpY2tPcHRpb24oXFwnd29ya1llYXJzTGlzdEZsYWdcXCcsaXRlbV9pbmRleCl9IGNsYXNzPXtmbGFncy53b3JrWWVhcnNMaXN0RmxhZ1tpdGVtX2luZGV4XT09dHJ1ZT9cXCdsaXZlXFwnOlxcJ1xcJ30+e2l0ZW0ubmFtZX08L3NwYW4+ICAgICAgICAgICAgICAgICAgICB7L2xpc3R9ICAgICAgICAgICAgICAgIHsvaWZ9ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2VsZWN0LW9wdGlvbnMgc3BlY2lhbFxcXCI+ICAgICAgICAgICAgICAgIDxzcGFuPuiBjOS9jeexu+WIq++8mjwvc3Bhbj4gICAgICAgICAgICAgICAgeyNpZiB3b3JrUGxhY2VMaXN0fSAgICAgICAgICAgICAgICAgICAgeyNsaXN0IHBvc2l0aW9uVHlwZUxpc3QgYXMgaXRlbX0gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBvbi1jbGljaz17dGhpcy5jbGlja09wdGlvbihcXCdwb3NpdGlvblR5cGVMaXN0RmxhZ1xcJyxpdGVtX2luZGV4KX0gY2xhc3M9e2ZsYWdzLnBvc2l0aW9uVHlwZUxpc3RGbGFnW2l0ZW1faW5kZXhdPT10cnVlP1xcJ2xpdmVcXCc6XFwnXFwnfT57aXRlbS5uYW1lfTwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIHsvbGlzdH0gICAgICAgICAgICAgICAgey9pZn0gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyLXNlbGVjdFxcXCI+ICAgICAgICAgICAgPHNwYW4+PGkgY2xhc3M9XFxcImpvYlxcXCI+PC9pPiDmi5vogZjotJ/otKPkurogICAgICAgICAgICAgICAgPHNlbGVjdCByLW1vZGVsPXtxdWVyeU9iai5wb3N0aW9uVXNlcklkfT4gICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uID7or7fpgInmi6k8L29wdGlvbj4gICAgICAgICAgICAgICAgICAgIHsjbGlzdCBockxpc3QgYXMgaXRlbX0gICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtpdGVtLmlkfT57aXRlbS5uYW1lfTwvb3B0aW9uPiAgICAgICAgICAgICAgICAgICAgey9saXN0fSAgICAgICAgICAgICAgICA8L3NlbGVjdD4gICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgPHNwYW4+PGkgY2xhc3M9XFxcImhvdXNlc1xcXCI+PC9pPiDogYzkvY3miYDlnKjpg6jpl6ggICAgICAgICAgICAgICAgPHNlbGVjdCByLW1vZGVsPXtxdWVyeU9iai5wb3NpdGlvbkRlcElkfT4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gPuivt+mAieaLqTwvb3B0aW9uPiAgICAgICAgICAgICAgICAgICAgeyNsaXN0IGRlcGFydG1lbnRMaXN0IGFzIGl0ZW19ICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17aXRlbS5pZH0+e2l0ZW0ubmFtZX08L29wdGlvbj4gICAgICAgICAgICAgICAgICAgIHsvbGlzdH0gICAgICAgICAgICAgICAgPC9zZWxlY3Q+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgIDxzcGFuPjxpIGNsYXNzPVxcXCJ0aW1lXFxcIj48L2k+IOiBjOS9jeeKtuaAgSAgICAgICAgICAgICAgICA8c2VsZWN0IHItbW9kZWw9e3F1ZXJ5T2JqLnBvc2l0aW9uTmFtZX0+ICAgICAgICAgICAgICAgICAgICA8b3B0aW9uID7or7fpgInmi6k8L29wdGlvbj4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9MD4g5Y+R5biD5LitPC9vcHRpb24+ICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPTE+IOemgeeUqOS4rTwvb3B0aW9uPiAgICAgICAgICAgICAgICA8L3NlbGVjdD4gICAgICAgICAgICA8L3NwYW4+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImhvbWUtY29udGVudFxcXCIgPiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImgtYy1oZWFkZXJcXFwiPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmlyc3Qtc3BhblxcXCI+6IGM5L2N5ZCN56ewPC9zcGFuPiAgICAgICAgICAgICAgICA8c3Bhbj7ogYzkvY3nirbmgIE8L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuPuiBjOS9jeexu+WIqzwvc3Bhbj4gICAgICAgICAgICAgICAgPHNwYW4+5bel5L2c5Zyw54K5PC9zcGFuPiAgICAgICAgICAgICAgICA8c3Bhbj7lt6XkvZzlubTpmZA8L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuPuacgOS9juWtpuWOhjwvc3Bhbj4gICAgICAgICAgICAgICAgPHNwYW4+5oub6IGY5Lq65pWwPC9zcGFuPiAgICAgICAgICAgICAgICA8c3Bhbj7mm7TmlrDml6XmnJ88L3NwYW4+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgeyNpZiBwb3NpdGlvbkxpc3R9ICAgICAgICAgICAgICAgIHsjbGlzdCBwb3NpdGlvbkxpc3QgYXMgaXRlbX0gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImgtYy1wb3NpdGlvbiBmLXByIHtpdGVtLnBvc2l0aW9uU3RhdHVzPT0wP1xcJ1xcJzpcXCdncmF5XFwnfVxcXCI+ICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImZpcnN0LXNwYW5cXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPXtcXFwiIy9kZXRhaWw/aWQ9XFxcIitpdGVtLmR9IHRhcmdldD1cXFwiX2JsYW5rXFxcIj57aXRlbS5wb3NpdGlvbk5hbWV9PC9hPiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ge2l0ZW0ucG9zaXRpb25TdGF0dXM9PTA/XFwnbGl2ZVxcJzpcXCdcXCd9PntpdGVtLnBvc2l0aW9uU3RhdHVzPT0wP1xcJ+WPkeW4g+S4rVxcJzpcXCflt7LmmoLlgZxcXCd9PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLnBvc2l0aW9uVHlwZU5hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLndvcmtQbGFjZU5hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLndvcmtZZWFyc05hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLnRvcERlZ3JlZU5hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLmhpcmVOdW19PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPntpdGVtLnVwZGF0ZURhdGV9PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5wb3NpdGlvblN0YXR1cz09MX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcImljb24gYXJyb3dEb3duXFxcIj48L2E+ICAgICAgICAgICAgICAgICAgICAgICAgeyNlbHNlfSAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiaWNvbiB7YXJyb3dTdGF0dXNbaXRlbV9pbmRleF09PXRydWU/XFwnYXJyb3dVcFxcJzpcXCdhcnJvd0Rvd25cXCd9XFxcIiBvbi1jbGljaz17dGhpcy5zZXRBcnJvdyhpdGVtX2luZGV4KX0+PC9hPiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9ICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgIDxkaXYgIHItaGlkZT17IWFycm93U3RhdHVzW2l0ZW1faW5kZXhdfSBjbGFzcz1cXFwiaC1jLWRlYXRpbFxcXCI+ICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGV0YWlsLWRlY1xcXCI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZGVjLWhlYWRlclxcXCI+5bKXIOS9jSDmj48g6L+wPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgci1odG1sPXtpdGVtLnBvc2l0aW9uRHNjfT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkZXRhaWwtcmVxXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZXEtaGVhZGVyXFxcIj7lspcg5L2NIOimgSDmsYI8L3NwYW4+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCByLWh0bWw9e2l0ZW0ucG9zaXRpb25SZXF9PiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRlYXRpbC1mb290ZXJcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYnV0dG9uXFxcIiBvbi1jbGljaz17dGhpcy5yZWNvbW1lbmQoaXRlbS5pZCl9PiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg5oiR6KaB5o6o6I2QICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9vdGVyLW1haWwgLmYtY2JcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1haWwtdGl0bGVcXFwiPuaLm+iBmOi0n+i0o+S6ujo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibWFpbC1wZXJzb25cXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjbGlzdCBpdGVtLnBvc3Rpb25Vc2VyTmFtZUxpc3QgYXMgaXRlbX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW0ubmFtZX0gfCB7aXRlbS5lbWFpbH08YnI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9saXN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICB7L2xpc3R9ICAgICAgICAgICAgey9pZn0gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaG9tZS1wYWdlXFxcIj4gICAgICAgICAgICB7I2lmIHBhZ2UudG90YWxQYWdlfSAgICAgICAgICAgIDxwYWdlciB0b3RhbD17cGFnZS50b3RhbFBhZ2V9IGN1cnJlbnQ9e3F1ZXJ5T2JqLmN1cnJlbnRQYWdlfSA+PC9wYWdlcj4gICAgICAgICAgICB7L2lmfSAgICAgICAgPC9kaXY+ICAgIDwvZGl2PjwvZGl2PlwiIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgaHpjaGVuZ3NodWxpIG9uIDIwMTYvMTAvMjguXHJcbiAqL1xyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vYmFzZS9jb21wb25lbnQnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9pbmRleC5odG1sJyk7XHJcbnZhciBDb29raWUgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtY29va2llL3NyYy9qcy5jb29raWUuanMnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi9iYXNlL3V0aWwuanMnKTtcclxudmFyIGNhY2hlU2VydmljZSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2UuanMnKTtcclxudmFyIFBhZ2VyID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL3BhZ2VyLmpzJyk7XHJcbnZhciBTZWFyY2ggPSByZXF1aXJlKCcuLi8uLi9jb21tb24vc2VhcmNoLmpzJyk7XHJcblxyXG5cclxudmFyIEhvbWUgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgIHRlbXBsYXRlOnRlbXBsYXRlLFxyXG5cclxuICAgIGNvbmZpZygpIHtcclxuICAgICAgICB0aGlzLmRhdGEucXVlcnlPYmo9e307ICAgICAgICAgICAgIC8v5Yid5aeL5p+l6K+i5p2h5Lu2XHJcbiAgICAgICAgdGhpcy5kYXRhLmFycm93U3RhdHVzPVtdOyAgICAgICAgICAvL+aOp+WItueureWktOaYvuekuuS4iuS4i1xyXG4gICAgICAgIHRoaXMuZGF0YS5mbGFncz17XHJcbiAgICAgICAgICAgIHdvcmtQbGFjZUxpc3RGbGFnOlt0cnVlXSwgICAgICAvL+m7mOiupOmAieS4reS4jemZkFxyXG4gICAgICAgICAgICB3b3JrWWVhcnNMaXN0RmxhZzpbdHJ1ZV0sICAgICAgLy/pu5jorqTpgInkuK3ml6Dlt6XkvZznu4/pqoxcclxuICAgICAgICAgICAgcG9zaXRpb25UeXBlTGlzdEZsYWc6W3RydWVdICAgIC8v6buY6K6k6YCJ5Lit6IGM5L2N57G75YirXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNlbGVjdFBhZ2UoKTsgICAgICAgICAgICAgICAgIC8v55uR5ZCsIOWtkOe7hOS7tnBhZ2XliIfmjaLnmoTkuovku7ZcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgaWYoIUNvb2tpZS5nZXQoJ3Bhc3Nwb3J0Jykpe1xyXG4gICAgICAgICAgICBsb2NhdGlvbi5ocmVmPScjL2xvZ2luJztcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9fc2VsZWN0T3B0aW9ucygpO1xyXG5cclxuICAgICAgICB0aGlzLl9fcXVlcnlQb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi3r+eUsei/m+WFpeaXtuWAmemSqeWtkOWHveaVsFxyXG4gICAgICogQHBhcmFtIG9wdGlvblxyXG4gICAgICovXHJcbiAgICBlbnRlcihvcHRpb24pIHtcclxuICAgICAgICAgdGhpcy51cGRhdGUob3B0aW9uKVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAq5Y+v5Lul55uR5ZCs5YiwdXJs5Y+Y5YyWXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShvcHRpb24pIHtcclxuICAgICAgICBjb25zdCBwYWdlPW9wdGlvbi5wYXJhbS5wYWdlO1xyXG4gICAgICAgIHRoaXMuZGF0YS5xdWVyeU9iai5jdXJyZW50UGFnZT1wYWdlIHx8IDE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55uR5ZCscGFnZXLnu4Tku7bnmoTpobXmlbDlj5jljJZcclxuICAgICAqL1xyXG4gICAgc2VsZWN0UGFnZSgpIHtcclxuICAgICAgICB0aGlzLiRvbignc2VsZWN0UGFnZScsKG9iaik9PntcclxuICAgICAgICAgICAgbGV0IHBhZ2U9b2JqLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzdGF0ZS5nbygnYXBwLmhvbWUnLHtwYXJhbTp7cGFnZTpwYWdlfX0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6IGM5L2N5YiX6KGoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfX3F1ZXJ5UG9zaXRpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAq55uR5ZCs77yacXVlcnlPYmo66L6T5YWl5p+l6K+i5p2h5Lu25a+56LGhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IGRhdGE9dGhpcy5kYXRhO1xyXG4gICAgICAgIHRoaXMuJHdhdGNoKCdxdWVyeU9iaicsKG5ld1Ysb2xkVikgPT57XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICog6I635b6X6IGM5L2N5YiX6KGoXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSDmn6Xor6LmnaHku7blr7nosaFcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNhY2hlU2VydmljZS5wb3NpdGlvbkxpc3QobmV3ViwgKHJlc3VsdCkgPT57XHJcbiAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uTGlzdD1yZXN1bHQucG9zaXRpb25MaXN0O1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wYWdlPXJlc3VsdC5wYWdlO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5ockxpc3Q9cmVzdWx0LmhyTGlzdDtcclxuICAgICAgICAgICAgICAgIGRhdGEuZGVwYXJ0bWVudExpc3Q9cmVzdWx0LmRlcGFydG1lbnRMaXN0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSx0cnVlKVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluafpeivoueahOmAiemhuSDlnLDngrkg5bel5L2c57uP6aqMIOiBjOS9jeexu+WIq1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX19zZWxlY3RPcHRpb25zKCkge1xyXG4gICAgICAgIGxldCBkYXRhPXRoaXMuZGF0YTtcclxuICAgICAgICBjYWNoZVNlcnZpY2Uuc2VsZWN0T3B0aW9ucyhyZXN1bHQ9PntcclxuICAgICAgICAgICAgZGF0YS53b3JrUGxhY2VMaXN0PXJlc3VsdC53b3JrUGxhY2VMaXN0O1xyXG4gICAgICAgICAgICBkYXRhLndvcmtZZWFyc0xpc3Q9cmVzdWx0LndvcmtZZWFyc0xpc3Q7XHJcbiAgICAgICAgICAgIGRhdGEucG9zaXRpb25UeXBlTGlzdD1yZXN1bHQucG9zaXRpb25UeXBlTGlzdDtcclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog54K55Ye7566t5aS05o6n5Yi2566t5aS055qE5pi+56S654q25oCBXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIOesrOWHoOS4queureWktFxyXG4gICAgICovXHJcbiAgICBzZXRBcnJvdyhpbmRleCkge1xyXG4gICAgICAgIGxldCBhcnJvd1N0YXR1cz10aGlzLmRhdGEuYXJyb3dTdGF0dXM7XHJcbiAgICAgICAgYXJyb3dTdGF0dXNbaW5kZXhdPSFhcnJvd1N0YXR1c1tpbmRleF07XHJcbiAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog54K55Ye75oiR6KaB5o6o6I2Q5oyJ6ZKuXHJcbiAgICAgKi9cclxuICAgIHJlY29tbWVuZChpZCkge1xyXG4gICAgICAgIHRoaXMuJHN0YXRlLmdvKCdhcHAudXBsb2FkJyx7cGFyYW06e2lkOmlkfX0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKio9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICog6YCJ6aG55oyJ6ZKuICDngrnlh7vlh7rnjrDnuqLoibLog4zmma9cclxuICAgICAqIEBwYXJhbSBvcHRpb24g57G75YirXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIOeCueWHu+eahOWTquS4gOS4qumAiemhuVxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqL1xyXG4gICAgY2xpY2tPcHRpb24ob3B0aW9uLGluZGV4KSB7XHJcblxyXG4gICAgICAgIGxldCBmbGFncz10aGlzLmRhdGEuZmxhZ3MsXHJcbiAgICAgICAgICAgIHF1ZXJ5T2JqPXRoaXMuZGF0YS5xdWVyeU9iaixcclxuICAgICAgICAgICAgbGlzdD1vcHRpb24ucmVwbGFjZSgnRmxhZycsJycpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBv77yIbu+8iSDml7bpl7TlpI3mnYLluqZcclxuICAgICAgICAgKiDlnKjpppbpobXngrnlh7sg5bel5L2c5Zyw54K5IOW3peS9nOW5tOmZkCDogYzkvY3nsbvliKsg5Lit55qE6YCJ6aG55YiH5o2i5pe26YCJ6aG554q25oCB5Lul5Y+K54q25oCB5pS55Y+Y5Y+R5Ye66K+35rGCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGZsYWdzKXtcclxuICAgICAgICAgICAgaWYob3B0aW9uPT1rZXkpe1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wO2k8dGhpcy5kYXRhW2xpc3RdLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW29wdGlvbl1baV09ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmbGFnc1tvcHRpb25dW2luZGV4XT10cnVlO1xyXG4gICAgICAgICAgICAgICAgcXVlcnlPYmpbbGlzdF09aW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeCueWHu+aQnOe0ouaMiemSrlxyXG4gICAgICovXHJcbiAgICBzZWFyY2hCdXR0b24oKSB7XHJcbiAgICAgICAgbGV0IGRhdGE9dGhpcy5kYXRhO1xyXG4gICAgICAgIGRhdGEucXVlcnlPYmoucG9zaXRpb25OYW1lPWRhdGEuc2VhcmNoVmFsdWU7XHJcbiAgICB9XHJcblxyXG59KVxyXG5Ib21lLmNvbXBvbmVudCgnUGFnZXInLFBhZ2VyKTtcclxuSG9tZS5jb21wb25lbnQoJ1NlYXJjaCcsU2VhcmNoKTtcclxubW9kdWxlLmV4cG9ydHMgPSBIb21lO1xyXG4iLCJtb2R1bGUuZXhwb3J0cz1cIjxkaXYgY2xhc3M9XFxcIm0taHVudGVyRGV0YWlsXFxcIj4gICAgPGRpdiBjbGFzcz1cXFwiaHVudGVyLW1haW5cXFwiPiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWFpbi1oZWFkZXIgZi1wclxcXCI+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJhY2tcXFwiIG9uLWNsaWNrPXt0aGlzLmdvQmFjaygpfT4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJhY2tJY29uXFxcIj48L3NwYW4+ICAgICAgICAgICAgICAgIOi/lOWbniAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaHVudGVyLW5hbWVcXFwiPiAgICAgICAgICAgICAgICDnv7DlvrcoSHVkc29uKSAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaHVudGVyLW51bVxcXCI+ICAgICAgICAgICAgICAgIOWFseaciSA8YSBjbGFzcz1cXFwicmVkXFxcIj41PC9hPiDkuKrluJDlj7fmraPlnKjlkK/nlKggICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJpZ2h0LWFkZEh1bnRlclxcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJhZGRIdW50ZXItaWNvblxcXCI+PC9zcGFuPiAgICAgICAgICAgICAgICDmlrDlop7otKblj7cgICAgICAgICAgICA8L3NwYW4+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRoZWFkXFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+5biQ5Y+35aeT5ZCNPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj7nmbvlvZXpgq7nrrE8L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgc3BhbjEyNC1hY3RpdmVcXFwiPuWFqOmDqOeKtuaAgSAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3RhdHVzLWZyYW1lXFxcIj4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiPuWFqOmDqOeKtuaAgSA8YT4yNjwvYT48L2xhYmVsPjxicj4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiPuWQr+eUqOS4rSA8YT4yNjwvYT48L2xhYmVsPjxicj4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiPuW3suWBnOeUqCA8YT4yNjwvYT48L2xhYmVsPiAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzU2XFxcIj7luJDlj7fmk43kvZw8L3NwYW4+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1jb250ZW50XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjIxOVxcXCI+546L5bCP54yOPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMzY5XFxcIj53YW5nbGllMTYzMTYzQDE2My5jb208L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMjQgZ3JlZW5cXFwiPuWQr+eUqOS4rTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjM1NiBcXFwiPiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xpY2stcmVkXFxcIj7lgZznlKg8L2E+ICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5lXFxcIj48L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImh1bnRlci1ib3R0b21cXFwiPiAgICAgICAgICAgIDxwYWdlcj48L3BhZ2VyPiAgICAgICAgPC9kaXY+ICAgIDwvZGl2PjwvZGl2PlwiIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgaHpnYW9xdWFua2FuZyBvbiAyMDE3LzUvMTIuXHJcbiAqL1xyXG5cclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvY29tcG9uZW50Jyk7XHJcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaW5kZXguaHRtbCcpO1xyXG52YXIgY2FjaGVTZXJ2aWNlID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZS5qcycpO1xyXG52YXIgUGFnZXIgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcGFnZXIuanMnKTtcclxuXHJcbnZhciBodW50ZXJEZXRhaWwgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgIHRlbXBsYXRlOnRlbXBsYXRlLFxyXG4gICAgY29uZmlnKCkge1xyXG5cclxuICAgIH0sXHJcbiAgICBpbml0KCkge1xyXG5cclxuICAgIH0sXHJcbiAgICBnb0JhY2soKSB7XHJcbiAgICAgICAgdGhpcy4kc3RhdGUuZ28oJ2FwcC5hZG1pbicpO1xyXG4gICAgfVxyXG5cclxufSlcclxuXHJcbmh1bnRlckRldGFpbC5jb21wb25lbnQoJ1BhZ2VyJyxQYWdlcik7XHJcbm1vZHVsZS5leHBvcnRzPWh1bnRlckRldGFpbDsiLCJtb2R1bGUuZXhwb3J0cz1cIjxkaXYgY2xhc3M9XFxcIm0tbG9naW5cXFwiIG9uLWVudGVyPXt0aGlzLnN1Ym1pdCgpfT4gICAgPGRpdiBjbGFzcz1cXFwibG9naW5cXFwiPiAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9naW4taGVhZGVyXFxcIj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZXNldC1wd2RcXFwiPjxzcGFuIGNsYXNzPVxcXCJsb2dpbi1oZWFkZXItc3BhbjJcXFwiPuS/ruaUueWvhueggTwvc3Bhbj48L2Rpdj4gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1sb2dpblxcXCI+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1yb3dcXFwiPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXB3ZFxcXCI+PC9pPiAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBwbGFjZWhvbGRlcj1cXFwi6K+36L6T5YWl5pen5a+G56CBXFxcIiBuYW1lPVxcJ3Bhc3Nwb3J0XFwnIHItbW9kZWw9XFxcIntmb3JtRGF0YS5wYXNzd29yZH1cXFwiLz4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvd1xcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1wd2RcXFwiPjwvaT4gICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCLor7fovpPlhaXmlrDlr4bnoIFcXFwiIG5hbWU9XFxcIm5ld1B3ZFxcXCIgci1tb2RlbD1cXFwie2Zvcm1EYXRhLm5ld1B3ZH1cXFwiIG9uLWZvY3VzPVxcXCJ7dGhpcy5wd2RGb2N1cygpfVxcXCIgb24tYmx1cj1cXFwie3RoaXMucHdkQmx1cigpfVxcXCIvPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tcm93XFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvblxcXCI+ICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1wd2RcXFwiPjwvaT4gICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgcGxhY2Vob2xkZXI9XFxcIuivt+ehruiupOaWsOWvhueggVxcXCIgbmFtZT1cXFwibmV3UHdkQWdhaW5cXFwiIHItbW9kZWw9XFxcIntmb3JtRGF0YS5uZXdQd2RBZ2Fpbn1cXFwiLz4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbi10aXBcXFwiID4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcJ2xvZ2luLWVyci10aXBcXCcgci1oaWRlPVxcXCJ7ZXJySW5mbyA9PSBcXCdcXCd9XFxcIj57ZXJySW5mb308L2xhYmVsPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tcm93IGZvcm0tcm93LWJ1dHRvblxcXCI+ICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcJ3tidG5GbGFnP1xcXCJidXR0b24gYnRuLWFjdGl2ZVxcXCI6XFxcImJ1dHRvbiBidG4tZGlzYWJsZVxcXCJ9XFwnIHZhbHVlPVxcXCLkv67mlLnlr4bnoIFcXFwiIG9uLWNsaWNrPXt0aGlzLnN1Ym1pdCgpfS8+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHdkLWNoZWNrLWluZm8gcHdkLWNoZWNrLWluZm8tY2hhbmdlXFxcIiByLWhpZGU9XFxcInshcHdkVG90YWxTdGF0dXN9XFxcIj4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHdkLWNoZWNrLWRldGFpbFxcXCI+ICAgICAgICAgICAgICAgICAgICA8cD48c3BhbiBjbGFzcz1cXCd7cHdkU3RhdHVzLmxlbmd0aD9cXFwicHdkLWNoZWNrLWljb24tcmlnaHRcXFwiOlxcXCJwd2QtY2hlY2staWNvbi13cm9uZ1xcXCJ9XFwnPjwvc3Bhbj7plb/luqbkuLo2LTE25Liq5a2X56ymPC9wPiAgICAgICAgICAgICAgICAgICAgPHA+PHNwYW4gY2xhc3M9XFwne3B3ZFN0YXR1cy5zcGFjZT9cXFwicHdkLWNoZWNrLWljb24tcmlnaHRcXFwiOlxcXCJwd2QtY2hlY2staWNvbi13cm9uZ1xcXCJ9XFwnPjwvc3Bhbj7kuI3og73ljIXlkKvnqbrmoLw8L3A+ICAgICAgICAgICAgICAgICAgICA8cD48c3BhbiBjbGFzcz1cXCd7cHdkU3RhdHVzLm51bWJlcj9cXFwicHdkLWNoZWNrLWljb24tcmlnaHRcXFwiOlxcXCJwd2QtY2hlY2staWNvbi13cm9uZ1xcXCJ9XFwnPjwvc3Bhbj7kuI3og73mmK855L2N5Lul5LiL57qv5pWw5a2XPC9wPiAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcInB3ZC1jaGVjay1pbmZvLWFycm93LWJpZ1xcXCI+PC9pPiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwicHdkLWNoZWNrLWluZm8tYXJyb3ctc21hbGxcXFwiPjwvaT4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICA8L2Rpdj48L2Rpdj5cIiIsIi8qXHJcbiogQ3JlYXRlIGdhb2NodWFua2FuZ1xyXG4qICovXHJcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi9iYXNlL2NvbXBvbmVudCcpO1xyXG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2NoYW5nZVB3ZC5odG1sJyk7XHJcbnZhciBjYWNoZVNlcnZpY2UgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlLmpzJyk7XHJcbnZhciBDb29raWUgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtY29va2llL3NyYy9qcy5jb29raWUuanMnKVxyXG52YXIgTWFzayA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9tYXNrLmpzJyk7XHJcbnZhciBOb3RpZnkgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vbm90aWZ5LmpzJyk7XHJcblxyXG52YXIgQ2hhbmdlUHdkID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcbiAgICB0ZW1wbGF0ZTp0ZW1wbGF0ZSxcclxuXHJcbiAgICBpbml0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5kYXRhLmZvcm1EYXRhID0ge307XHJcbiAgICAgICAgdGhpcy5kYXRhLmVyckluZm8gPSAnJztcclxuICAgICAgICB0aGlzLmRhdGEuYnRuRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGF0YS5hbGxGbGFnID0ge1xyXG4gICAgICAgICAgICBvbGRQd2RGbGFnOmZhbHNlLFxyXG4gICAgICAgICAgICBuZXdQd2RGbGFnOmZhbHNlLFxyXG4gICAgICAgICAgICBuZXdQd2RBZ2FpbkZsYWc6ZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZGF0YS5wd2RTdGF0dXMgPSB7XHJcbiAgICAgICAgICAgIGxlbmd0aDpmYWxzZSxcclxuICAgICAgICAgICAgc3BhY2U6ZmFsc2UsXHJcbiAgICAgICAgICAgIG51bWJlcjpmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZighQ29va2llLmdldCgncGFzc3BvcnQnKSl7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWY9JyMvbG9naW4nO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX193YXRjaEFsbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOebkeWQrOi+k+WFpeahhueahOWPmOWMllxyXG4gICAgICovXHJcbiAgICBfX3dhdGNoQWxsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy/lvZPph43mlrDovpPlhaXnmbvlvZXlkI3ml7Yg5Y+W5raI6ZSZ6K+v5L+h5oGvXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHdhdGNoKCdmb3JtRGF0YS5wYXNzd29yZCcsZnVuY3Rpb24obmV3VixvbGRWKXtcclxuICAgICAgICAgICAgaWYobmV3ViAmJiBuZXdWICE9ICcnICYmIG5ld1YudG9TdHJpbmcoKS50cmltKCkhPScnKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5lcnJJbmZvID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuYWxsRmxhZy5vbGRQd2RGbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuYWxsRmxhZy5vbGRQd2RGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5fX3NldEJ0bigpO1xyXG4gICAgICAgICAgICBzZWxmLiR1cGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2Zvcm1EYXRhLm5ld1B3ZCcsZnVuY3Rpb24obmV3VixvbGRWKXtcclxuICAgICAgICAgICAgaWYobmV3ViAmJiBuZXdWICE9ICcnICYmIG5ld1YudG9TdHJpbmcoKS50cmltKCkhPScnKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5lcnJJbmZvID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuYWxsRmxhZy5uZXdQd2RGbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tQd2RTdHJlbmd0aChuZXdWKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuYWxsRmxhZy5uZXdQd2RGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5fX3NldEJ0bigpO1xyXG4gICAgICAgICAgICBzZWxmLiR1cGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2Zvcm1EYXRhLm5ld1B3ZEFnYWluJyxmdW5jdGlvbihuZXdWLG9sZFYpe1xyXG5cclxuICAgICAgICAgICAgaWYobmV3ViAmJiBuZXdWICE9ICcnICYmIG5ld1YudG9TdHJpbmcoKS50cmltKCkhPScnKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5lcnJJbmZvID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuYWxsRmxhZy5uZXdQd2RBZ2FpbkZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5hbGxGbGFnLm5ld1B3ZEFnYWluRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuX19zZXRCdG4oKTtcclxuICAgICAgICAgICAgc2VsZi4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIOWvhueggeW8uuW6puWIpOWumlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY2hlY2tQd2RTdHJlbmd0aDpmdW5jdGlvbih2YWwpe1xyXG4gICAgICAgIGlmKHZhbC5sZW5ndGg8NiB8fCB2YWwubGVuZ3RoPjE2KXtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnB3ZFN0YXR1cy5sZW5ndGggPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHdkU3RhdHVzLmxlbmd0aCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih2YWwuaW5kZXhPZignICcpID49IDApe1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHdkU3RhdHVzLnNwYWNlID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnB3ZFN0YXR1cy5zcGFjZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZigvXlswLTldezEsOX0kLy50ZXN0KHZhbCkpe1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHdkU3RhdHVzLm51bWJlciA9IGZhbHNlO1xyXG5cclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wd2RTdGF0dXMubnVtYmVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflvpfnhKbngrnml7bop6blj5HnmoTkuovku7ZcclxuICAgICAqL1xyXG4gICAgcHdkRm9jdXM6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmRhdGEucHdkVG90YWxTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgfSxcclxuICAgIHB3ZEJsdXI6ZnVuY3Rpb24oKXtcclxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gdGhpcy5kYXRhLnB3ZFN0YXR1cyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5wd2RTdGF0dXNbaXRlbV0gPT0gZmFsc2Upe1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGEucHdkVG90YWxTdGF0dXMgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICAvL+aOp+WItuaMiemSrueahOaYvuekuuS4jumakOiXj1xyXG4gICAgX19zZXRCdG46ZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpdGVtIGluIHRoaXMuZGF0YS5hbGxGbGFnICl7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmRhdGEuYWxsRmxhZ1tpdGVtXSA9PSBmYWxzZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYnRuRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLmRhdGEucHdkVG90YWxTdGF0dXMgPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5idG5GbGFnID0gdHJ1ZVxyXG5cclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5o+Q5Lqk6KGo5Y2VXHJcbiAgICAgKi9cclxuICAgIHN1Ym1pdDpmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB2YXIgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gc2VsZi5kYXRhLmFsbEZsYWcpe1xyXG4gICAgICAgICAgICBpZihzZWxmLmRhdGEuYWxsRmxhZ1tpdGVtXSA9PSBmYWxzZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc2VsZi5kYXRhLmZvcm1EYXRhLm5ld1B3ZCAhPT0gc2VsZi5kYXRhLmZvcm1EYXRhLm5ld1B3ZEFnYWluKXtcclxuICAgICAgICAgICAgc2VsZi5kYXRhLmVyckluZm8gPSAn5paw5a+G56CB6L6T5YWl5LiN5LiA6Ie0JztcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXBsb2FkRGF0YSA9IHNlbGYuZGF0YS5mb3JtRGF0YTtcclxuXHJcbiAgICAgICAgZGVsZXRlIHVwbG9hZERhdGEubmV3UHdkQWdhaW47XHJcbiAgICAgICAgdmFyIG1hc2sgPSBuZXcgTWFzaygpLiRpbmplY3QoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgY2FjaGVTZXJ2aWNlLmNoYW5nZVB3ZCh1cGxvYWREYXRhLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIE5vdGlmeS5zdWNjZXNzKCfkv67mlLnlr4bnoIHmiJDlip/vvIzmraPlnKjot7Povax+Jyk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcclxuICAgICAgICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgbWFzay5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi4kc3RhdGUubmF2KCcvaG9tZScpO1xyXG4gICAgICAgICAgICB9LDEwMDApO1xyXG5cclxuICAgICAgICB9LGZ1bmN0aW9uKGVycixlcnJSZXN1bHQpe1xyXG4gICAgICAgICAgICBtYXNrLmNsb3NlKCk7XHJcblxyXG4gICAgICAgICAgICBzZWxmLmRhdGEuZXJySW5mbyA9IGVyclJlc3VsdC5tc2c7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5mb3JtRGF0YS5wYXNzd29yZCA9Jyc7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5mb3JtRGF0YS5uZXdQd2QgPSAnJztcclxuICAgICAgICAgICAgc2VsZi5kYXRhLmZvcm1EYXRhLm5ld1B3ZEFnYWluID0gJyc7XHJcblxyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpdGVtIGluIHNlbGYuZGF0YS5hbGxGbGFnICl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuYWxsRmxhZ1tpdGVtXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLiR1cGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlUHdkOyIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwibS1sb2dpblxcXCIgb24tZW50ZXI9XFxcInt0aGlzLnN1Ym1pdCgkZXZlbnQpfVxcXCI+PGRpdiBjbGFzcz1cXFwibG9naW5cXFwiPiAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbi1oZWFkZXJcXFwiPiAgICAgICAgPGRpdj48c3BhbiBjbGFzcz1cXFwibG9naW4taGVhZGVyLXNwYW4yXFxcIj7nvZHmmJPnjI7lpLTns7vnu588L3NwYW4+PC9kaXY+ICAgIDwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWxvZ2luXFxcIj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tcm93IFxcXCI+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb25cXFwiPiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZW1haWxcXFwiPjwvaT4gICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCLor7fovpPlhaXpgq7nrrFcXFwiIG5hbWU9XFwnZW1haWxcXCcgci1tb2RlbD1cXFwie2Zvcm1EYXRhLmVtYWlsfVxcXCIgci1hdXRvZm9jdXMvPiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvdyBcXFwiPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXB3ZFxcXCI+PC9pPiAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCLor7fovpPlhaXlr4bnoIFcXFwiIG5hbWU9XFxcInBhc3N3b3JkXFxcIiByLW1vZGVsPVxcXCJ7Zm9ybURhdGEucGFzc3dvcmR9XFxcIi8+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvZGUtYWRqdXN0XFxcIj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tcm93IGZvcm0tcm93LWNvZGUgXFxcIj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvblxcXCI+ICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS10b2tlblxcXCI+PC9pPiAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICA8aW5wdXQgIGNsYXNzPVxcXCJzaG9ydElucFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIuivt+i+k+WFpemqjOivgeeggVxcXCIgbmFtZT1cXFwiY29kZVxcXCIgci1tb2RlbD1cXFwie2Zvcm1EYXRhLnZhbGlkYXRlQ29kZX1cXFwiLz4gICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCIvc3lzL2dldFZlcmlmeUNvZGUuZG9cXFwiIGNsYXNzPVxcXCJsb2dpbi1jb2RlXFxcIiBvbi1jbGljaz1cXFwie3RoaXMudXBkYXRlVmFsaWF0aW9uQ29kZSgpfVxcXCIgcmVmPXZhbGlhdGlvbkltZy8+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luLXRpcFxcXCIgPiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImYtY2JcXFwiPiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXCdsb2dpbi1lcnItdGlwIGVycm9yXFwnIHItaGlkZT1cXFwie2VyckluZm8gPT0gXFwnMVxcJ31cXFwiPntlcnJJbmZvfTwvbGFiZWw+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZi1jYlxcXCI+ICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibG9naW4tcmVtZW1iZXItdGlwXFxcIj48aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGNsYXNzPVxcXCJyZW1cXFwiIHItbW9kZWw9XFxcIntyZW1QYXNzd29yZH1cXFwiPuiusOS9j+WvhueggTwvbGFiZWw+ICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibG9naW4tcmVzZXQtdGlwXFxcIj48YSBvbi1jbGljaz1cXFwie3RoaXMuY2hhbmdlVG9SZXNldCgpfVxcXCI+5b+Y6K6w5a+G56CBPzwvYT48L2xhYmVsPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvdyBmb3JtLXJvdy1idXR0b25cXFwiID4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXCcge2J0bkZsYWc/XFxcImJ1dHRvbiBidG4tYWN0aXZlXFxcIjpcXFwiYnV0dG9uIGJ0bi1kaXNhYmxlXFxcIn1cXCcgdmFsdWU9XFxcIueZuyAgIOW9lVxcXCIgICBvbi1jbGljaz17dGhpcy5zdWJtaXQoKX0vPiAgICAgICAgPC9kaXY+ICAgIDwvZGl2PjwvZGl2PjwvZGl2PlwiIiwiXHJcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi9iYXNlL2NvbXBvbmVudCcpO1xyXG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2luZGV4Lmh0bWwnKTtcclxudmFyIGNhY2hlU2VydmljZSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2UuanMnKTtcclxudmFyIE5vdGlmeSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9ub3RpZnknKTtcclxudmFyIE1hc2sgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vbWFzay5qcycpO1xyXG52YXIgQ29va2llcyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy1jb29raWUvc3JjL2pzLmNvb2tpZS5qcycpXHJcbnZhciBFbWl0ID0gIHJlcXVpcmUoJy4uLy4uL2Jhc2UvZW1pdC5qcycpO1xyXG5cclxudmFyIExvZ2luID0gQ29tcG9uZW50LmV4dGVuZCh7XHJcbiAgICB0ZW1wbGF0ZTp0ZW1wbGF0ZSxcclxuICAgIGluaXQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmRhdGEucmVtUGFzc3dvcmQ9dHJ1ZTsgIC8v6K6w5L2P5a+G56CB5qGGXHJcbiAgICAgICAgdGhpcy5kYXRhLmZvcm1EYXRhID0ge307XHJcbiAgICAgICAgdGhpcy5kYXRhLmVyckluZm8gPSAnJztcclxuICAgICAgICB0aGlzLmRhdGEuYnRuRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGF0YS5hbGxGbGFnID0ge1xyXG4gICAgICAgICAgICBlbWFpbEZsYWc6ZmFsc2UsXHJcbiAgICAgICAgICAgIC8vIGlkRmxhZzpmYWxzZSxcclxuICAgICAgICAgICAgcHdkRmxhZzpmYWxzZSxcclxuICAgICAgICAgICAgY29kZUZsYWc6ZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX193YXRjaEFsbCgpO1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOebkeWQrOi+k+WFpeahhueahOWPmOWMllxyXG4gICAgICovXHJcbiAgICBfX3dhdGNoQWxsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy/lvZPph43mlrDovpPlhaXnmbvlvZXlkI3ml7Yg5Y+W5raI6ZSZ6K+v5L+h5oGvXHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2Zvcm1EYXRhLmVtYWlsfGVzY2FwZScsZnVuY3Rpb24obmV3VixvbGRWKXtcclxuICAgICAgICAgICAgaWYobmV3ViAhPSAnJyAmJiBuZXdWLnRyaW0oKSAhPScnKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5lcnJJbmZvID0gJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWxsRmxhZy5lbWFpbEZsYWcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hbGxGbGFnLmVtYWlsRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX19zZXRCdG4oKTtcclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2Zvcm1EYXRhLnBhc3N3b3JkfGVzY2FwZScsZnVuY3Rpb24obmV3VixvbGRWKXtcclxuICAgICAgICAgICAgaWYobmV3ViAhPSAnJyYmIG5ld1YudHJpbSgpICE9Jycpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmVyckluZm8gPSAnJztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hbGxGbGFnLnB3ZEZsYWcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWxsRmxhZy5wd2RGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fX3NldEJ0bigpO1xyXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuJHdhdGNoKCdmb3JtRGF0YS52YWxpZGF0ZUNvZGV8ZXNjYXBlJyxmdW5jdGlvbihuZXdWLG9sZFYpe1xyXG4gICAgICAgICAgICBpZihuZXdWICE9ICcnJiYgbmV3Vi50cmltKCkgIT0nJyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZXJySW5mbyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmFsbEZsYWcuY29kZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hbGxGbGFnLmNvZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fX3NldEJ0bigpO1xyXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcblxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrDpqozor4HnoIFcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVmFsaWF0aW9uQ29kZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB0aGlzLiRyZWZzLnZhbGlhdGlvbkltZy5zcmMgPSAnIC9zeXMvZ2V0VmVyaWZ5Q29kZS5kbz90aW1lc3RhbXA9JyArIHRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy/mjqfliLbmjInpkq7nmoTmmL7npLrkuI7pmpDol49cclxuICAgIF9fc2V0QnRuOmZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaXRlbSBpbiB0aGlzLmRhdGEuYWxsRmxhZyApe1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5kYXRhLmFsbEZsYWdbaXRlbV0gPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmJ0bkZsYWcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5idG5GbGFnID0gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOW/mOiusOWvhueggVxyXG4gICAgICovXHJcbiAgICBjaGFuZ2VUb1Jlc2V0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy4kc3RhdGUubmF2KCcvcmVzZXRwd2QnKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5o+Q5Lqk6KGo5Y2VXHJcbiAgICAgKi9cclxuICAgIHN1Ym1pdDpmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZm9yKHZhciBpdGVtIGluIHNlbGYuZGF0YS5hbGxGbGFnKXtcclxuICAgICAgICAgICAgaWYoc2VsZi5kYXRhLmFsbEZsYWdbaXRlbV0gPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWFzayA9IG5ldyBNYXNrKCkuJGluamVjdChkb2N1bWVudC5ib2R5KTtcclxuICAgICAgICBjYWNoZVNlcnZpY2UubG9naW4odGhpcy5kYXRhLmZvcm1EYXRhLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICBOb3RpZnkuc3VjY2Vzcygn55m75b2V5oiQ5YqfIOato+WcqOi3s+i9rH5+Jyk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcclxuICAgICAgICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgbWFzay5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgZGF0YS51c2VyVHlwZT09MT9zZWxmLiRzdGF0ZS5uYXYoJy9hZG1pbicpOnNlbGYuJHN0YXRlLm5hdignL2hvbWUnKTtcclxuICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgICAgIENvb2tpZXMuc2V0KCdwYXNzcG9ydCcsIGRhdGEuY29tcGFueU5hbWUpO1xyXG4gICAgICAgICAgICBDb29raWVzLnNldCgndXNlclR5cGUnLGRhdGEudXNlclR5cGUpO1xyXG4gICAgICAgICAgICBpZihzZWxmLmRhdGEucmVtUGFzc3dvcmQpe1xyXG4gICAgICAgICAgICAgICAgQ29va2llcy5zZXQoJ3Bhc3Nwb3J0JyxkYXRhLmNvbXBhbnlOYW1lLCB7ZXhwaXJlczogNX0pO1xyXG4gICAgICAgICAgICAgICAgQ29va2llcy5zZXQoJ3VzZXJUeXBlJyxkYXRhLnVzZXJUeXBlLHtleHBpcmVzOiA1fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRW1pdC5vYnNlcnZlci5maXJlKCduYXZBZGQnKTtcclxuICAgICAgICAgICAgRW1pdC5vYnNlcnZlci5maXJlKCduYXZTaG93JyxkYXRhLmNvbXBhbnlOYW1lKTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyRGF0YSwgZXJyUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIG1hc2suY2xvc2UoKTtcclxuICAgICAgICAgICAgaWYgKGVyclJlc3VsdCYmZXJyUmVzdWx0LmNvZGUgPT0gMzAyKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuZXJySW5mbyA9ICflsJ3or5XmrKHmlbDov4flpJrvvIzor7fnqI3lkI7lho3or5UnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5kYXRhLmVyckluZm8gPSBlcnJSZXN1bHQubXNnO1xyXG4gICAgICAgICAgICBpZihzZWxmLmRhdGEuZXJySW5mbyA9PSAn6aqM6K+B56CB6ZSZ6K+v77yBJyl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuZm9ybURhdGEudmFsaWRhdGVDb2RlID0gJydcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5hbGxGbGFnLmNvZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuZm9ybURhdGEuZW1haWwgPSAnJztcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5mb3JtRGF0YS5wYXNzd29yZCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhLmZvcm1EYXRhLnZhbGlkYXRlQ29kZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaXRlbSBpbiBzZWxmLmRhdGEuYWxsRmxhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5hbGxGbGFnW2l0ZW1dID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi51cGRhdGVWYWxpYXRpb25Db2RlKCk7XHJcbiAgICAgICAgICAgIHNlbGYuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2dpbjsiLCJtb2R1bGUuZXhwb3J0cz1cIjxkaXYgY2xhc3M9XFxcIm0tbG9naW5cXFwiPiAgICB7I2lmIGN1cnJlbnRTdGF0dXMgPT0gMX0gICAgPGRpdiBjbGFzcz1cXFwibG9naW5cXFwiIG9uLWVudGVyPXt0aGlzLnN1Ym1pdDEoKX0+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbi1oZWFkZXJcXFwiPiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlc2V0LXB3ZFxcXCI+PHNwYW4gY2xhc3M9XFxcImxvZ2luLWhlYWRlci1zcGFuMlxcXCI+6YeN572u5a+G56CBPC9zcGFuPjwvZGl2PiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWxvZ2luXFxcIj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvd1xcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1uYW1lXFxcIj48L2k+ICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCLor7fovpPlhaXpgq7nrrFcXFwiIG5hbWU9XFwnZW1haWxcXCcgci1tb2RlbD1cXFwie2Zvcm1EYXRhLmVtYWlsfVxcXCIvPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luLXRpcFxcXCIgPiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFwnbG9naW4tZXJyLXRpcFxcJyByLWhpZGU9XFxcIntlcnJJbmZvID09IFxcJ1xcJ31cXFwiPntlcnJJbmZvfTwvbGFiZWw+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1yb3cgZm9ybS1yb3ctYnV0dG9uXFxcIj4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFwne2ZpcnN0QnRuRmxhZz9cXFwiYnV0dG9uIGJ0bi1hY3RpdmVcXFwiOlxcXCJidXR0b24gYnRuLWRpc2FibGVcXFwifVxcJyB2YWx1ZT1cXFwi5Y+R6YCB6YeN572u5a+G56CB6YKu5Lu2XFxcIiBvbi1jbGljaz17dGhpcy5zdWJtaXQxKCl9Lz4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICA8L2Rpdj4gICAgeyNlbHNlaWYgY3VycmVudFN0YXR1cyA9PSAyfSAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbiByZXNldC1pbmZvXFxcIj4gICAgICAgIDxwIGNsYXNzPVxcXCJyZXNldC1pbmZvLXRpdGxlXFxcIj7lj5HpgIHmiJDlip/vvIE8L3A+ICAgICAgICA8cD7lt7Llj5HpgIHpgq7ku7boh7Mge2VtYWlsfSwg6K+355m75b2V6YKu566x6YeN572u5a+G56CB44CC6K+l6YKu5Lu255qE5pyJ5pWI5pyf5Li6MjTlsI/ml7bjgII8L3A+ICAgICAgICA8cD7or6Xpgq7nrrHmmK/mgqjlupTogZjml7bmj5DkvpvnmoTpgq7nrrHvvIzoi6Xpgq7nrrHmnInor6/vvIzor7fogZTns7tIUuS/ruaUueOAgjwvcD4gICAgICAgIDxwPuayoeacieaUtuWIsOmHjee9rumCruS7tu+8n+eCueatpCA8YSBvbi1jbGljaz1cXFwie3RoaXMuc3VibWl0MSgpfVxcXCI+6YeN5paw5Y+R6YCBPC9hPjwvcD4gICAgPC9kaXY+ICAgIHsjZWxzZWlmIGN1cnJlbnRTdGF0dXMgPT0gM30gICAgPGRpdiBjbGFzcz1cXFwibG9naW5cXFwiIG9uLWVudGVyPXt0aGlzLnN1Ym1pdDIoKX0+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbi1oZWFkZXJcXFwiPiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlc2V0LXB3ZFxcXCI+PHNwYW4gY2xhc3M9XFxcImxvZ2luLWhlYWRlci1zcGFuMlxcXCI+6YeN572u5a+G56CBPC9zcGFuPjwvZGl2PiAgICAgICAgPC9kaXY+ICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWxvZ2luXFxcIj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvd1xcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1wd2RcXFwiPjwvaT4gICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCLor7fovpPlhaXmlrDlr4bnoIFcXFwiIG5hbWU9XFwnbmV3UHdkXFwnIHItbW9kZWw9XFxcIntmb3JtRGF0YS5uZXdQd2R9XFxcIiBvbi1mb2N1cz1cXFwie3RoaXMucHdkRm9jdXMoKX1cXFwiIG9uLWJsdXI9XFxcInt0aGlzLnB3ZEJsdXIoKX1cXFwiLz4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvd1xcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1wd2RcXFwiPjwvaT4gICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCLor7fnoa7orqTmlrDlr4bnoIFcXFwiIG5hbWU9XFxcIm5ld1B3ZEFnYWluXFxcIiByLW1vZGVsPVxcXCJ7Zm9ybURhdGEubmV3UHdkQWdhaW59XFxcIi8+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9naW4tdGlwXFxcIiA+ICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXCdsb2dpbi1lcnItdGlwXFwnIHItaGlkZT1cXFwie2VyckluZm8gPT0gXFwnXFwnfVxcXCI+e2VyckluZm99PC9sYWJlbD4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXJvdyBmb3JtLXJvdy1idXR0b25cXFwiPiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXCd7c2Vjb25kQnRuRmxhZz9cXFwiYnV0dG9uIGJ0bi1hY3RpdmVcXFwiOlxcXCJidXR0b24gYnRuLWRpc2FibGVcXFwifVxcJyB2YWx1ZT1cXFwi6YeN572u5a+G56CBXFxcIiBvbi1jbGljaz17dGhpcy5zdWJtaXQyKCl9Lz4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwd2QtY2hlY2staW5mbyBwd2QtY2hlY2staW5mby1yZXNldFxcXCIgci1oaWRlPVxcXCJ7IXB3ZFRvdGFsU3RhdHVzfVxcXCI+ICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB3ZC1jaGVjay1kZXRhaWxcXFwiPiAgICAgICAgICAgICAgICAgICAgPHA+PHNwYW4gY2xhc3M9XFwne3B3ZFN0YXR1cy5sZW5ndGg/XFxcInB3ZC1jaGVjay1pY29uLXJpZ2h0XFxcIjpcXFwicHdkLWNoZWNrLWljb24td3JvbmdcXFwifVxcJz48L3NwYW4+6ZW/5bqm5Li6Ni0xNuS4quWtl+espjwvcD4gICAgICAgICAgICAgICAgICAgIDxwPjxzcGFuIGNsYXNzPVxcJ3twd2RTdGF0dXMuc3BhY2U/XFxcInB3ZC1jaGVjay1pY29uLXJpZ2h0XFxcIjpcXFwicHdkLWNoZWNrLWljb24td3JvbmdcXFwifVxcJz48L3NwYW4+5LiN6IO95YyF5ZCr56m65qC8PC9wPiAgICAgICAgICAgICAgICAgICAgPHA+PHNwYW4gY2xhc3M9XFwne3B3ZFN0YXR1cy5udW1iZXI/XFxcInB3ZC1jaGVjay1pY29uLXJpZ2h0XFxcIjpcXFwicHdkLWNoZWNrLWljb24td3JvbmdcXFwifVxcJz48L3NwYW4+5LiN6IO95pivOeS9jeS7peS4i+e6r+aVsOWtlzwvcD4gICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJwd2QtY2hlY2staW5mby1hcnJvdy1iaWdcXFwiPjwvaT4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcInB3ZC1jaGVjay1pbmZvLWFycm93LXNtYWxsXFxcIj48L2k+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICA8L2Rpdj4gICAgPC9kaXY+ICAgIHsjZWxzZWlmIGN1cnJlbnRTdGF0dXMgPT0gNH0gICAgPGRpdiBjbGFzcz1cXFwibG9naW4gcmVzZXQtaW5mb1xcXCI+ICAgICAgICA8cCBjbGFzcz1cXFwicmVzZXQtaW5mby10aXRsZVxcXCI+6ZO+5o6l5omT5byA5aSx6LSl77yBPC9wPiAgICAgICAgPHA+6ZO+5o6l5LiN5q2j56GuLOaYr+WQpuW3sue7j+i/h+acn+S6hj/ph43mlrDnlLPor7flkKc8L3A+ICAgIDwvZGl2PiAgICB7I2Vsc2VpZiBjdXJyZW50U3RhdHVzID09IDV9ICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luIHJlc2V0LWluZm9cXFwiPiAgICAgICAgPHAgY2xhc3M9XFxcInJlc2V0LWluZm8tdGl0bGVcXFwiPumTvuaOpeaJk+W8gOWksei0pe+8gTwvcD4gICAgICAgIDxwPumTvuaOpeW3sue7j+i/h+acnyzor7fph43mlrDnlLPor7fmib7lm57lr4bnoIE8L3A+ICAgIDwvZGl2PiAgICB7I2Vsc2VpZiBjdXJyZW50U3RhdHVzID09IDZ9ICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luIHJlc2V0LWluZm9cXFwiPiAgICAgICAgPHAgY2xhc3M9XFxcInJlc2V0LWluZm8tdGl0bGVcXFwiPumTvuaOpeaJk+W8gOWksei0pe+8gTwvcD4gICAgICAgIDxwPumTvuaOpemUmeivryzml6Dms5Xmib7liLDljLnphY3nlKjmiLcs6K+36YeN5paw55Sz6K+35om+5Zue5a+G56CBPC9wPiAgICA8L2Rpdj4gICAgeyNlbHNlaWYgY3VycmVudFN0YXR1cyA9PSA3fSAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbiByZXNldC1pbmZvXFxcIj4gICAgICAgIDxwIGNsYXNzPVxcXCJyZXNldC1pbmZvLXRpdGxlXFxcIj7pk77mjqXmiZPlvIDlpLHotKXvvIE8L3A+ICAgICAgICA8cD7pk77mjqXkuI3lrozmlbQs6K+36YeN5paw55Sf5oiQPC9wPiAgICA8L2Rpdj4gICAgey9pZn08L2Rpdj5cIiIsIlxyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vYmFzZS9jb21wb25lbnQnKTtcclxudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9yZXNldFB3ZC5odG1sJyk7XHJcbnZhciBjYWNoZVNlcnZpY2UgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlLmpzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vYmFzZS91dGlsLmpzJyk7XHJcbnZhciBNYXNrID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL21hc2suanMnKTtcclxudmFyIE5vdGlmeSA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9ub3RpZnkuanMnKTtcclxuXHJcbnZhciBSZXNldFB3ZCA9IENvbXBvbmVudC5leHRlbmQoe1xyXG4gICAgdGVtcGxhdGU6dGVtcGxhdGUsXHJcblxyXG4gICAgaW5pdDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuZGF0YS5mb3JtRGF0YSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZGF0YS5lcnJJbmZvID0gJyc7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmRhdGEuZmlyc3RBbGxGbGFnID0ge1xyXG4gICAgICAgICAgICBlbWFpbEZsYWc6ZmFsc2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEuc2Vjb25kQWxsRmxhZyA9IHtcclxuICAgICAgICAgICAgbmV3UHdkRmxhZzpmYWxzZSxcclxuICAgICAgICAgICAgbmV3UHdkQWdhaW5GbGFnOmZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kYXRhLnB3ZFN0YXR1cyA9IHtcclxuICAgICAgICAgICAgbGVuZ3RoOmZhbHNlLFxyXG4gICAgICAgICAgICBzcGFjZTpmYWxzZSxcclxuICAgICAgICAgICAgbnVtYmVyOmZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX19nZXRDdXJyZW50U3RhdHVzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX193YXRjaEFsbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluW9k+WJjemhtemdoueKtuaAgVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX19nZXRDdXJyZW50U3RhdHVzOmZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gXy5nZXRQYXJhbXMod2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgICAgIGlmKCFfLmlzRW1wdHlPYmplY3QocGFyYW1zKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5jdXJyZW50U3RhdHVzID0gcGFyYW1zLnN0YXR1cztcclxuICAgICAgICAgICAgaWYodGhpcy5kYXRhLmN1cnJlbnRTdGF0dXMgPT0gMyl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuc2Vjb25kQnRuRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc2VsZi4kdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmN1cnJlbnRTdGF0dXMgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlyc3RCdG5GbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnm5HlkKzovpPlhaXmoYbnmoTlj5jljJZcclxuICAgICAqL1xyXG4gICAgX193YXRjaEFsbDpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8v5b2T6YeN5paw6L6T5YWl55m75b2V5ZCN5pe2IOWPlua2iOmUmeivr+S/oeaBr1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLiR3YXRjaCgnZm9ybURhdGEuZW1haWwnLGZ1bmN0aW9uKG5ld1Ysb2xkVil7XHJcbiAgICAgICAgICAgIGlmKG5ld1YgIT0gJycgJiYgbmV3Vi50cmltKCkhPScnKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5lcnJJbmZvID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEuZmlyc3RBbGxGbGFnLmVtYWlsRmxhZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5maXJzdEFsbEZsYWcuZW1haWxGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5fX3NldEJ0bignZmlyc3RBbGxGbGFnJywnZmlyc3RCdG5GbGFnJyk7XHJcbiAgICAgICAgICAgIHNlbGYuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLiR3YXRjaCgnZm9ybURhdGEubmV3UHdkJyxmdW5jdGlvbihuZXdWLG9sZFYpe1xyXG4gICAgICAgICAgICBpZihuZXdWICE9ICcnICYmIG5ld1YudHJpbSgpIT0nJykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhLmVyckluZm8gPSAnJztcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnLm5ld1B3ZEZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jaGVja1B3ZFN0cmVuZ3RoKG5ld1YpO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnLm5ld1B3ZEZsYWcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5fX3NldEJ0bignc2Vjb25kQWxsRmxhZycsJ3NlY29uZEJ0bkZsYWcnKTtcclxuICAgICAgICAgICAgc2VsZi4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuJHdhdGNoKCdmb3JtRGF0YS5uZXdQd2RBZ2FpbicsZnVuY3Rpb24obmV3VixvbGRWKXtcclxuICAgICAgICAgICAgaWYobmV3Vj09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYobmV3ViAhPSAnJyAmJiBuZXdWLnRyaW0oKSE9Jycpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhLmVyckluZm8gPSAnJztcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnLm5ld1B3ZEFnYWluRmxhZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnLm5ld1B3ZEFnYWluRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuX19zZXRCdG4oJ3NlY29uZEFsbEZsYWcnLCdzZWNvbmRCdG5GbGFnJyk7XHJcbiAgICAgICAgICAgIHNlbGYuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a+G56CB5by65bqm5Yik5a6aXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjaGVja1B3ZFN0cmVuZ3RoOmZ1bmN0aW9uKHZhbCl7XHJcbiAgICAgICAgaWYodmFsLmxlbmd0aDw2IHx8IHZhbC5sZW5ndGg+MTYpe1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHdkU3RhdHVzLmxlbmd0aCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wd2RTdGF0dXMubGVuZ3RoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHZhbC5pbmRleE9mKCcgJykgPj0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wd2RTdGF0dXMuc3BhY2UgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucHdkU3RhdHVzLnNwYWNlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKC9eWzAtOV17MSw5fSQvLnRlc3QodmFsKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wd2RTdGF0dXMubnVtYmVyID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnB3ZFN0YXR1cy5udW1iZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIOiOt+W+l+eEpueCueaXtuinpuWPkeeahOS6i+S7tlxyXG4gICAgICovXHJcbiAgICBwd2RGb2N1czpmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEucHdkVG90YWxTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgfSxcclxuICAgIHB3ZEJsdXI6ZnVuY3Rpb24oKXtcclxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gdGhpcy5kYXRhLnB3ZFN0YXR1cyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5wd2RTdGF0dXNbaXRlbV0gPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YS5wd2RUb3RhbFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvL+aOp+WItuaMiemSrueahOaYvuekuuS4jumakOiXj1xyXG4gICAgX19zZXRCdG46ZnVuY3Rpb24oZmxhZyxidG4pe1xyXG5cclxuXHJcbiAgICAgICAgZm9yKHZhciBpdGVtIGluIHRoaXMuZGF0YVtmbGFnXSApe1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5kYXRhW2ZsYWddW2l0ZW1dID09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtidG5dID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZmxhZyA9PSAnc2Vjb25kQWxsRmxhZycpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmRhdGEucHdkVG90YWxTdGF0dXMgPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YVtidG5dID0gdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWPkemAgemHjee9ruWvhueggemCruS7tuaXtuaPkOS6pOihqOWNlVxyXG4gICAgICovXHJcbiAgICBzdWJtaXQxOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyICBzZWxmID0gdGhpcztcclxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gc2VsZi5kYXRhLmZpcnN0QWxsRmxhZyApe1xyXG4gICAgICAgICAgICBpZihzZWxmLmRhdGEuZmlyc3RBbGxGbGFnW2l0ZW1dID09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWFzayA9IG5ldyBNYXNrKCkuJGluamVjdChkb2N1bWVudC5ib2R5KTtcclxuICAgICAgICBjYWNoZVNlcnZpY2Uuc2VuZFJlc2V0UHdkRW1haWwodGhpcy5kYXRhLmZvcm1EYXRhLGZ1bmN0aW9uKGRhdGEscmVzdWx0KXtcclxuICAgICAgICAgICAgbWFzay5jbG9zZSgpO1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEuZW1haWwgPSBkYXRhO1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEuY3VycmVudFN0YXR1cyA9IDI7XHJcbiAgICAgICAgICAgIHNlbGYuJHVwZGF0ZSgpO1xyXG5cclxuICAgICAgICB9LGZ1bmN0aW9uKGVycixlcnJSZXN1bHQpe1xyXG5cclxuICAgICAgICAgICAgbWFzay5jbG9zZSgpO1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEuZXJySW5mbyA9IGVyclJlc3VsdC5tc2c7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5mb3JtRGF0YS5lbWFpbCA9Jyc7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5maXJzdEFsbEZsYWdbJ2VtYWlsRmxhZyddID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9fc2V0QnRuKCdmaXJzdEFsbEZsYWcnLCdmaXJzdEJ0bkZsYWcnKTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDph43nva7lr4bnoIHlj5HpgIHor7fmsYJcclxuICAgICAqL1xyXG4gICAgc3VibWl0MjpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciAgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZm9yKHZhciBpdGVtIGluIHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnICl7XHJcbiAgICAgICAgICAgIGlmKHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnW2l0ZW1dID09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gc2VsZi5kYXRhLnB3ZFN0YXR1cyl7XHJcbiAgICAgICAgICAgIGlmKHNlbGYuZGF0YS5wd2RTdGF0dXNbaXRlbV0gPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNlbGYuZGF0YS5mb3JtRGF0YS5uZXdQd2QgIT09IHNlbGYuZGF0YS5mb3JtRGF0YS5uZXdQd2RBZ2Fpbil7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5lcnJJbmZvID0gJ+aWsOWvhueggei+k+WFpeS4jeS4gOiHtCc7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHNlbGYuZGF0YS5mb3JtRGF0YS5uZXdQd2RBZ2FpbjtcclxuICAgICAgICB2YXIgbWFzayA9IG5ldyBNYXNrKCkuJGluamVjdChkb2N1bWVudC5ib2R5KTtcclxuXHJcbiAgICAgICAgY2FjaGVTZXJ2aWNlLnJlc2V0UHdkKHRoaXMuZGF0YS5mb3JtRGF0YSxmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICAgICAgTm90aWZ5LnN1Y2Nlc3MoJ+mHjee9ruWvhueggeaIkOWKn++8jOato+WcqOi3s+i9rH4nKTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxyXG4gICAgICAgICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBtYXNrLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLiRzdGF0ZS5uYXYoJy9sb2dpbicpO1xyXG4gICAgICAgICAgICB9LDEwMDApO1xyXG5cclxuXHJcbiAgICAgICAgfSxmdW5jdGlvbihlcnIsZXJyUmVzdWx0KXtcclxuXHJcbiAgICAgICAgICAgIG1hc2suY2xvc2UoKTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5lcnJJbmZvID0gZXJyUmVzdWx0Lm1zZztcclxuICAgICAgICAgICAgc2VsZi5kYXRhLmZvcm1EYXRhLm5ld1B3ZCA9ICcnO1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEuZm9ybURhdGEubmV3UHdkQWdhaW4gPSAnJztcclxuXHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGl0ZW0gaW4gc2VsZi5kYXRhLnNlY29uZEFsbEZsYWcgKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5zZWNvbmRBbGxGbGFnW2l0ZW1dID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5fX3NldEJ0bignc2Vjb25kQWxsRmxhZycsJ3NlY29uZEJ0bkZsYWcnKTtcclxuICAgICAgICAgICAgc2VsZi4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNldFB3ZDsiLCJtb2R1bGUuZXhwb3J0cz1cIjxkaXYgY2xhc3M9XFxcIm0taG9tZVxcXCI+ICAgIDxkaXYgY2xhc3M9XFxcImhvbWVcXFwiID4gICAgICAgIDxkaXYgY2xhc3M9XFxcImhvbWUtY29udGVudCBcXFwiIHN0eWxlPVxcXCJtYXJnaW4tdG9wOiAzMHB4O1xcXCI+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaC1jLWhlYWRlclxcXCI+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmaXJzdC1zcGFuIHJlbS1maXJzdC1zcGFuXFxcIj7mjqjojZDogYzkvY08L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZW0tc3BhblxcXCI+5YCZ6YCJ5Lq65aeT5ZCNPC9zcGFuPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVtLXNwYW5cXFwiPuaOqOiNkOaXtumXtDwvc3Bhbj4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlbS1zcGFuXFxcIj7mi5vogZjotJ/otKPkuro8L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZW0tc3BhblxcXCI+5pyA5paw54q25oCBPC9zcGFuPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIHsjbGlzdCByZWNvbW1lbmRMaXN0IGFzIGl0ZW19ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaC1jLXBvc2l0aW9uIGYtcHJcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmaXJzdC1zcGFuIHJlbS1mLXNwYW5cXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPXtcXFwiIy9kZXRhaWw/aWQ9XFxcIitpdGVtLmlkfSB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+e2l0ZW0ucG9zaXRpb25OYW1lfTwvYT4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZW0tc3BhblxcXCI+ICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW0uYXBwTmFtZX0gICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVtLXNwYW5cXFwiPntpdGVtLnVwZGF0ZVRpbWVTdHJ9PC9zcGFuPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVtLXNwYW5cXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjogcmVsYXRpdmU7XFxcIj4gICAgICAgICAgICAgICAgICAgIDxhIG9uLW1vdXNlb3Zlcj17dGhpcy5zaG93SWNvbihpdGVtX2luZGV4LHRydWUpfSBvbi1tb3VzZW91dD17dGhpcy5zaG93SWNvbihpdGVtX2luZGV4LGZhc2xlKX0+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtLnBvc3Rpb25Vc2VyTmFtZX0gICAgICAgICAgICAgICAgICAgIDwvYT4gICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVtLXNwYW5cXFwiPntpdGVtLnN0YXR1c05hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZW1pbmRlci1lbWFpbFxcXCIgci1oaWRlPXshYXJyb3dTdGF0dXNbaXRlbV9pbmRleF19PntpdGVtLmVtYWlsfTwvZGl2PiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIHsvbGlzdH0gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaG9tZS1wYWdlXFxcIj4gICAgICAgICAgICB7I2lmIHBhZ2VzLnRvdGFsUGFnZX0gICAgICAgICAgICA8cGFnZXIgdG90YWw9e3BhZ2VzLnRvdGFsUGFnZX0gY3VycmVudD17cGFnZX0gPjwvcGFnZXI+ICAgICAgICAgICAgey9pZn0gICAgICAgIDwvZGl2PiAgICA8L2Rpdj48L2Rpdj5cIiIsInZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi8uLi9iYXNlL2NvbXBvbmVudCcpO1xyXG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2luZGV4Lmh0bWwnKTtcclxudmFyIENvb2tpZSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy1jb29raWUvc3JjL2pzLmNvb2tpZS5qcycpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvdXRpbC5qcycpO1xyXG52YXIgY2FjaGVTZXJ2aWNlID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZS5qcycpO1xyXG52YXIgUGFnZXIgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcGFnZXIuanMnKTtcclxuXHJcbnZhciBSZWNvbW1lbmQgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgIHRlbXBsYXRlOnRlbXBsYXRlLFxyXG5cclxuICAgIGNvbmZpZygpIHtcclxuICAgICAgICB0aGlzLmRhdGEuc2hvdz1mYWxzZTtcclxuICAgICAgICB0aGlzLmRhdGEuYXJyb3dTdGF0dXM9W107ICAgICAgICAgIC8v5o6n5Yi2ZGl25pi+56S6XHJcbiAgICAgICAgdGhpcy5kYXRhLnBhZ2U9MTsgICAgICAgICAgICAgICAgICAvL+m7mOiupOaYvuekuuesrOS4gOmhtVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdFBhZ2UoKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6Lev55Sx6L+b5YWl5pe25YCZ6ZKp5a2Q5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIGVudGVyKG9wdGlvbikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKG9wdGlvbilcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAq5Y+v5Lul55uR5ZCs5YiwdXJs5Y+Y5YyWXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShvcHRpb24pIHtcclxuICAgICAgICBsZXQgZGF0YT10aGlzLmRhdGE7XHJcbiAgICAgICAgIGRhdGEucGFnZT1vcHRpb24ucGFyYW0ucGFnZSB8fCAxO1xyXG4gICAgICAgICB0aGlzLm15UmVjb21tZW5kKGRhdGEucGFnZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55uR5ZCscGFnZXLnu4Tku7bnmoTpobXmlbDlj5jljJZcclxuICAgICAqL1xyXG4gICAgc2VsZWN0UGFnZSgpIHtcclxuICAgICAgICB0aGlzLiRvbignc2VsZWN0UGFnZScsKG9iaik9PntcclxuICAgICAgICAgICAgbGV0IHBhZ2U9b2JqLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzdGF0ZS5nbygnYXBwLnJlY29tbWVuZCcse3BhcmFtOntwYWdlOnBhZ2V9fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIGhvdmVy5pe2IOWxleekuuaPkOekuuWtl+S9k1xyXG4gICAgICovXHJcbiAgICBzaG93SWNvbihpbmRleCxib29sKSB7XHJcbiAgICAgICAgbGV0IGFycm93U3RhdHVzPXRoaXMuZGF0YS5hcnJvd1N0YXR1cztcclxuICAgICAgICBhcnJvd1N0YXR1c1tpbmRleF09Ym9vbDtcclxuICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvpfliLDmiJHnmoTmjqjojZBcclxuICAgICAqL1xyXG4gICAgbXlSZWNvbW1lbmQoY3VycmVudFBhZ2Upe1xyXG4gICAgICAgIGxldCBkYXRhPXRoaXMuZGF0YTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635b6X5oiR5o6o6I2Q55qE566A5Y6GXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2FjaGVTZXJ2aWNlLm15UmVjb21tZW5kKHtjdXJyZW50UGFnZX0sKHJlc3VsdCk9PiB7XHJcbiAgICAgICAgICAgIGRhdGEucGFnZXM9cmVzdWx0LnBhZ2U7XHJcbiAgICAgICAgICAgIGRhdGEucmVjb21tZW5kTGlzdD1yZXN1bHQubGlzdDtcclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSk7XHJcblxyXG5SZWNvbW1lbmQuY29tcG9uZW50KCdQYWdlcicsUGFnZXIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHM9UmVjb21tZW5kOyIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwidXBsb2FkXFxcIj4gICAgPGRpdiAgY2xhc3M9XFxcInVwbG9hZC1oXFxcIj4gICAgICAgIHtkZXRhaWwucG9zaXRpb25OYW1lfSAgICAgICAgPGRpdiBjbGFzcz1cXFwiaC1kZXRhaWxcXFwiPiAgICAgICAgICAgIDxzcGFuPuiBjOS9jeexu+WIq++8mjxzcGFuIGNsYXNzPVxcXCJjaGlsZFxcXCI+e2RldGFpbC5wb3NpdGlvblR5cGVOYW1lfTwvc3Bhbj48L3NwYW4+ICAgICAgICAgICAgPHNwYW4+5bel5L2c5Zyw54K577yaPHNwYW4gY2xhc3M9XFxcImNoaWxkXFxcIj57ZGV0YWlsLndvcmtQbGFjZU5hbWV9PC9zcGFuPjwvc3Bhbj4gICAgICAgICAgICA8c3Bhbj7lt6XkvZzlubTpmZDvvJo8c3BhbiBjbGFzcz1cXFwiY2hpbGRcXFwiPntkZXRhaWwud29ya1llYXJzTmFtZX08L3NwYW4+PC9zcGFuPiAgICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgICA8ZGl2IGNsYXNzPVxcXCJ1cGxvYWQtY1xcXCIgPiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYy1sZWZ0XFxcIj4gICAgICAgICAgICA8ZGl2IG9uLWNsaWNrPXt0aGlzLnN3aXRjaE1vdWRlbCh7dXBsb2FkRmlsZTpcXCd0cnVlXFwnfSl9IGNsYXNzPXt1cGxvYWRGaWxlPT09XFwndHJ1ZVxcJz9cXCdsZWZ0LXRhYi1saXZlXFwnOlxcJ2xlZnQtdGFiXFwnfT4gICAgICAgICAgICAgICAg5LiK5Lyg5paw566A5Y6GICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxpdmVcXFwiPjwvZGl2PiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxkaXYgb24tY2xpY2s9e3RoaXMuc3dpdGNoTW91ZGVsKHtzZWxlY3RGaWxlOlxcJ3RydWVcXCd9KX0gY2xhc3M9e3NlbGVjdEZpbGU9PT1cXCd0cnVlXFwnP1xcJ2xlZnQtdGFiLWxpdmVcXCc6XFwnbGVmdC10YWJcXCd9PiAgICAgICAgICAgICAgICDpgInmi6nlt7LmnInnroDljoYgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGl2ZVxcXCI+PC9kaXY+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICA8L2Rpdj4gICAgICAgIDxkaXYgY2xhc3M9XFxcImMtcmlnaHRcXFwiICByLWhpZGU9eyEodXBsb2FkRmlsZT09XFwndHJ1ZVxcJyl9PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJpZ2h0LWZyaXN0XFxcIj4gICAgICAgICAgICAgICAgPGxhYmVsPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lIFxcXCI+5aeTPHNwYW4gY2xhc3M9XFxcImJsYW5rXFxcIj48L3NwYW4+5ZCNOjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiAgci1tb2RlbD17Zm9ybTFEYXRhLmFwcE5hbWV9PiAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9XFxcIm1hcmdpbi10b3A6MzBweDsgaGVpZ2h0OiAxN3B4OyBcXFwiPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lXFxcIiA+5oCnPHNwYW4gY2xhc3M9XFxcImJsYW5rXFxcIj48L3NwYW4+5YirOjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgci1tb2RlbD17Zm9ybTFEYXRhLmdlbmRlcn0gY2xhc3M9XFxcInJhZGlvXFxcIiB2YWx1ZT1cXFwiMFxcXCIgbmFtZT1cXFwiZ2VuZGVyXFxcIj7nlLc8c3BhbiBjbGFzcz1cXFwiYmxhbmtcXFwiPjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgci1tb2RlbD17Zm9ybTFEYXRhLmdlbmRlcn0gY2xhc3M9XFxcInJhZGlvXFxcIiB2YWx1ZT1cXFwiMVxcXCIgbmFtZT1cXFwiZ2VuZGVyXFxcIj7lpbMgICAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjMwcHg7IFxcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWUgXFxcIj7miYs8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+5py6PHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuWPtzxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7noIE6PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHItbW9kZWw9e2Zvcm0xRGF0YS5tb2JpbGV9IG9uLWJsdXI9e3RoaXMuY29udHJvbChmb3JtMURhdGEubW9iaWxlLFxcJ21vYmlsZVxcJyl9PiAgICAgICAgICAgICAgICAgICAgeyNpZiBlcnJEYXRhW1xcJ21vYmlsZVxcJ109PTF9ICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+5aGr5YaZ6ZSZ6K+v77yBPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgey9pZn0gICAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjIwcHg7XFxcIj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZWRcXFwiPio8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmFtZVxcXCI+55S1IDxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7lrZA8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6YKuPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPueusTo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgci1tb2RlbD17Zm9ybTFEYXRhLmVtYWlsfSBvbi1ibHVyPXt0aGlzLmNvbnRyb2woZm9ybTFEYXRhLmVtYWlsLFxcJ2VtYWlsXFwnKX0+ICAgICAgICAgICAgICAgICAgICB7I2lmIGVyckRhdGFbXFwnZW1haWxcXCddPT0xfSAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+5aGr5YaZ6ZSZ6K+v77yBPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgey9pZn0gICAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyaWdodC1zZWNvbmRcXFwiPiAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9XFxcIm1hcmdpbi10b3A6MjdweDtcXFwiPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lXFxcIiBzdHlsZT1cXFwibGV0dGVyLXNwYWNpbmc6IDIuNXB4O1xcXCI+5Y+C5Yqg5bel5L2c5bm05pyIOjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcInNlbGVjdDFcXFwiIHItbW9kZWw9e3dvcmsuWWVhcn0+ICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj7or7fpgInmi6k8L29wdGlvbj4gICAgICAgICAgICAgICAgICAgICAgICB7I2xpc3QgeWVhcnNBcnJheSBhcyBpdGVtfSAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtpdGVtfT57aXRlbX3lubQ8L29wdGlvbj4gICAgICAgICAgICAgICAgICAgICAgICB7L2xpc3R9ICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcInNlbGVjdDJcXFwiIHItbW9kZWw9e3dvcmsuTW9udGh9PiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+6K+36YCJ5oupPC9vcHRpb24+ICAgICAgICAgICAgICAgICAgICAgICAgeyNsaXN0IG1vbnRoc0FycmF5IGFzIGl0ZW19ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e2l0ZW19PntpdGVtfeaciDwvb3B0aW9uPiAgICAgICAgICAgICAgICAgICAgICAgIHsvbGlzdH0gICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PiAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9XFxcIm1hcmdpbi10b3A6MjBweDtcXFwiPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lXFxcIj7mnIA8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6auYPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuWtpjxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7ljoY6PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwic2VsZWN0MVxcXCIgci1tb2RlbD17Zm9ybTFEYXRhLnRvcERlZ3JlZX0+ICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj7or7fpgInmi6nlrabljoY8L29wdGlvbj4gICAgICAgICAgICAgICAgICAgICAgICB7I2xpc3QgZGVncmVlIGFzIGl0ZW19ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e2l0ZW0uaWR9PntpdGVtLm5hbWV9PC9vcHRpb24+ICAgICAgICAgICAgICAgICAgICAgICAgey9saXN0fSAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+ICAgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT1cXFwibWFyZ2luLXRvcDoyMHB4O1xcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWVcXFwiID7nm648c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+5YmNPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuW3pTxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7lj7g6PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHItbW9kZWw9e2Zvcm0xRGF0YS5ub3dDb21wYW55fT4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJpY29uXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4gICAgICAgICAgICAgICAgICAgICAgICAgICAg6Iul5bey56a76IGM77yM5Y+v5aGr5YaZ5pyA6L+R5LiA5Lu95bel5L2c5oOF5Ya1ICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPC9hPiAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9XFxcIm1hcmdpbi10b3A6NDBweDtcXFwiPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lXFxcIj7nm648c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+5YmNPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuiBjDxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7kvY06PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHItbW9kZWw9e2Zvcm0xRGF0YS5ub3dQb3NpdGlvbn0+ICAgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmlnaHQtdGhpcmQgZi1jYiBmLXByXFxcIiA+ICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT1cXFwibWFyZ2luLXRvcDo0MHB4O1xcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWVcXFwiPueugDxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7ljoY8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6ZmEPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuS7tjo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8Zm9ybSAgY2xhc3M9XFwnaW5mby1mb3JtXFwnIHJlZj1cXFwiZm9ybVxcXCIgIGFjdGlvbj1cXFwiL2ZpbGUvdXBsb2FkXFxcIiBlbmN0eXBlPVxcXCJtdWx0aXBhcnQvZm9ybS1kYXRhXFxcIiBtZXRob2Q9XFxcInBvc3RcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBmaWxlbmFtZX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmLXByXFxcIiBzdHlsZT1cXFwidGV4dC1pbmRlbnQ6IDEwcHhcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZmlsZW5hbWV9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2Vsc2V9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZi1wclxcXCIgc3R5bGU9XFxcIm1hcmdpbi1sZWZ0OjEwcHg7XFxcIj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImZpbGVcXFwiIG5hbWU9XFwnZmlsZVxcJyBvbi1jaGFuZ2U9e3RoaXMuX191cGxvYWRGaWxlKCRldmVudCl9IC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVwbG9hZC1maWxlXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tdXBcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDpgInmi6kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgICAgICAgey9pZn0gICAgICAgICAgICAgICAgICAgIDwvZm9ybT4gICAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlbWluZGVyXFxcIj4gICAgICAgICAgICAgICAgICAgIOaWh+S7tumcgOWwj+S6jjIwTe+8jOWPr+S4iuS8oGRvY+OAgWRvY3jjgIFwZGbjgIFqcGfjgIFnaWbjgIFwbmfjgIFqcGVn5qC85byPICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybTFidXR0b249PVxcJ3RydWVcXCd9ICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInN1Ym1pdFxcXCIgIG9uLWNsaWNrPXt0aGlzLnN1Ym1pdEludGFiMSgpfT4gICAgICAgICAgICAgICAgICAgICAgICAgICAg5oiR6KaB5o6o6I2QICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgeyNlbHNlfSAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzdWJtaXQgZ3JheWJ1dHRvblxcXCIgIG9uLWNsaWNrPXt0aGlzLnN1Ym1pdEludGFiMSgpfT4gICAgICAgICAgICAgICAgICAgICAgICAgICAg5oiR6KaB5o6o6I2QICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgey9pZn0gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYy1yaWdodFxcXCIgICByLWhpZGU9eyEoc2VsZWN0RmlsZT09XFwndHJ1ZVxcJyl9PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJpZ2h0LWZyaXN0XFxcIj4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJmLXByXFxcIj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZWRcXFwiPio8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmFtZSBcXFwiPuiiqzxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7mjqg8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6I2QPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuS6ujo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmFtZU5vd1xcXCI+e2N1cnJlbnRSZXN1bWUuYXBwTmFtZX08L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYnV0dG9uIHNtYWxsXFxcIiBvbi1jbGljaz17dGhpcy5zZWxlY3RIYXZlRmlsZSgpfSA+ICAgICAgICAgICAgICAgICAgICAgICAg6YCJ5oup566A5Y6GICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVtaW5kZXJcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICDms6jvvJrlkIzkuIDkuKrkurrkuIDmrKHlj6rog73ooqvmjqjojZDliLDkuIDkuKrogYzkvY3vvIzoi6XlupTogZjlpLHotKXvvIzlnKjor6XlgJnpgInkurrnmoTnjI7lpLTkv53miqTmnJ/lhoXlj6/ph43mlrDmjqjojZAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjYwcHg7IGhlaWdodDogMTdweDsgXFxcIj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZWRcXFwiPio8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmFtZSBcXFwiPuaApzxzcGFuIGNsYXNzPVxcXCJibGFua1xcXCI+PC9zcGFuPuWIqzo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiA+eyNpZiBjdXJyZW50UmVzdW1lLmdlbmRlcj09MH3nlLd7I2Vsc2VpZiBjdXJyZW50UmVzdW1lLmdlbmRlcj09MX3lpbN7L2lmfTwvc3Bhbj4gICAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjMwcHg7IFxcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWUgXFxcIj7miYs8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+5py6PHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuWPtzxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7noIE6PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gPntjdXJyZW50UmVzdW1lLm1vYmlsZX08L3NwYW4+ICAgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT1cXFwibWFyZ2luLXRvcDoxMHB4OyBcXFwiPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lIFxcXCI+55S1PHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuWtkDxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7pgq48c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+566xOjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuID57Y3VycmVudFJlc3VtZS5lbWFpbH08L3NwYW4+ICAgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmlnaHQtc2Vjb25kXFxcIj4gICAgICAgICAgICAgICAgPGxhYmVsIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjIwcHg7XFxcIj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJyZWRcXFwiPio8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmFtZVxcXCIgc3R5bGU9XFxcImxldHRlci1zcGFjaW5nOiAyLjZweDtcXFwiPuWPguWKoOW3peS9nOW5tOaciDo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiA+e2N1cnJlbnRSZXN1bWUud29ya1llYXJTdHJ9PC9zcGFuPiAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICA8bGFiZWwgc3R5bGU9XFxcIm1hcmdpbi10b3A6MjBweDtcXFwiPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInJlZFxcXCI+Kjwvc3Bhbj4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJuYW1lXFxcIj7mnIA8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6auYPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuWtpjxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7ljoY6PC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gPntjdXJyZW50UmVzdW1lLmRlZ3JlZVN0cn08L3NwYW4+ICAgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT1cXFwibWFyZ2luLXRvcDoyMHB4O1xcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWVcXFwiPuebrjxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7liY08c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+5belPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuWPuDo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiA+e2N1cnJlbnRSZXN1bWUubm93Q29tcGFueX08L3NwYW4+ICAgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT1cXFwibWFyZ2luLXRvcDoyMHB4O1xcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWVcXFwiPuebrjxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7liY08c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6IGMPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuS9jTo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiA+e2N1cnJlbnRSZXN1bWUubm93UG9zaXRpb259PC9zcGFuPiAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJpZ2h0LXRoaXJkIGYtY2IgZi1wclxcXCI+ICAgICAgICAgICAgICAgIDxsYWJlbCBzdHlsZT1cXFwibWFyZ2luLXRvcDo0MHB4O1xcXCI+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicmVkXFxcIj4qPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm5hbWVcXFwiPueugDxzcGFuIGNsYXNzPVxcXCJibGFuazJcXFwiPjwvc3Bhbj7ljoY8c3BhbiBjbGFzcz1cXFwiYmxhbmsyXFxcIj48L3NwYW4+6ZmEPHNwYW4gY2xhc3M9XFxcImJsYW5rMlxcXCI+PC9zcGFuPuS7tjo8L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cXFwibWFyZ2luLWxlZnQ6IDEwcHg7XFxcIj57Y3VycmVudFJlc3VtZS5hcHBlbmRpeE5hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICB7I2lmIGN1cnJlbnRSZXN1bWUuYXBwTmFtZX0gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzdWJtaXRcXFwiIG9uLWNsaWNrPXt0aGlzLnN1Ym1pdEludGFiMigpfT4gICAgICAgICAgICAgICAgICAgICAgICDmiJHopoHmjqjojZAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgeyNlbHNlfSAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInN1Ym1pdCBncmF5YnV0dG9uXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICDmiJHopoHmjqjojZAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgey9pZn0gICAgICAgICAgICA8L2Rpdj4gICAgICAgIDwvZGl2PiAgICA8L2Rpdj48L2Rpdj5cIiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGh6Z2FvcXVhbmthbmcgb24gMjAxNy81LzMuXHJcbiAqL1xyXG5cclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvY29tcG9uZW50Jyk7XHJcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaW5kZXguaHRtbCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvdXRpbC5qcycpO1xyXG52YXIgY2FjaGVTZXJ2aWNlID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZS5qcycpO1xyXG52YXIgTm90aWZ5ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL25vdGlmeScpO1xyXG52YXIgTWFzayA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9tYXNrLmpzJyk7XHJcbnZhciBNb2RhbCA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbi9tb2RhbC5qcycpO1xyXG52YXIgbWsgPSByZXF1aXJlKCdtYXJrZWQnKTtcclxudmFyIHNlbGVjdE1vZGVsPXJlcXVpcmUoJy4vc2VsZWN0TW9kZWwuaHRtbCcpO1xyXG52YXIgUGFnZXIgPSByZXF1aXJlKCcuLi8uLi9jb21tb24vcGFnZXIuanMnKTtcclxuXHJcbnZhciBSZWNvbW1lbmQgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgIHRlbXBsYXRlOnRlbXBsYXRlLFxyXG5cclxuICAgIGNvbmZpZygpIHtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLnVwbG9hZEZpbGU9J3RydWUnOyAgICAgLy/kvr/kuo7op6PmnoTotYvlgLwgIOeUqOWtl+espuS4snRydWVcclxuICAgICAgICB0aGlzLmRhdGEuZm9ybTFEYXRhPXt9OyAgICAgICAgICAvL+S4iuS8oOaWsOeugOWOhuihqOWNleWIneWni+WAvOS4uuepulxyXG4gICAgICAgIHRoaXMuZGF0YS5mb3JtMWJ1dHRvbj0nZmFsc2UnOyAgIC8v5LiK5Lyg566A5Y6G5Lit5oiR6KaB5o6o6I2Q5oyJ6ZKuXHJcbiAgICAgICAgdGhpcy5kYXRhLndvcms9e307ICAgICAgICAgICAgICAvL+WPguWKoOW3peS9nOaXtumXtCDkuIvmi4npgInpoblcclxuICAgICAgICB0aGlzLmRhdGEuZXJyRGF0YT17fTsgICAgICAgICAgLy/liJ3lp4vplJnor6/kv6Hmga/kuLrnqbpcclxuICAgICAgICB0aGlzLmRhdGEuY3VycmVudFBhZ2U9MTsgICAgICAgLy/liJ3lp4vnrKzkuIDpobVcclxuICAgICAgICB0aGlzLmRhdGEuY3VycmVudFJlc3VtZT17fTsgICAgLy/lvZPliY3nroDljoZcclxuICAgICAgICB0aGlzLmRhdGEuZGVncmVlPXt9OyAgICAgICAgICAvL+W9k+WJjeWtpuS9jVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMuZ2V0WWVhcnNBbmRNb250aCgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tUYWIxKCk7XHJcbiAgICAgICAgdGhpcy5kZWdyZWUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW50ZXIob3B0aW9uKSB7XHJcbiAgICAgICAgbGV0IGlkID1vcHRpb24ucGFyYW0uaWQ7XHJcbiAgICAgICAgdGhpcy5fX2dldFBvc2l0aW9uRGV0YWlsKGlkKTtcclxuICAgICAgICB0aGlzLmRhdGEuZm9ybTFEYXRhLmlkPWlkOyAgIC8v6I635Y+W6IGM5L2NaWRcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliIfmjaLpgInpobnljaFcclxuICAgICAqIEBwYXJhbSB1cGxvYWRGaWxlICAg5LiK5Lyg5paw566A5Y6G6YCJ6aG55Y2h5o6n5Yi2XHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0RmlsZSAgIOmAieaLqeS7peacieeugOWOhumAiemhueWNoeaOp+WItlxyXG4gICAgICovXHJcbiAgICBzd2l0Y2hNb3VkZWwoe3VwbG9hZEZpbGU9J2Zhc2xlJyxzZWxlY3RGaWxlPSdmYXNsZSd9KXtcclxuICAgICAgICBsZXQgZGF0YT10aGlzLmRhdGE7XHJcbiAgICAgICAgW2RhdGEudXBsb2FkRmlsZSxkYXRhLnNlbGVjdEZpbGVdID0gW3VwbG9hZEZpbGUsc2VsZWN0RmlsZV0gO1xyXG4gICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvpfliLDogYzkvY3kv6Hmga9cclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX19nZXRQb3NpdGlvbkRldGFpbChpZCl7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bogYzkvY3or6bnu4bkv6Hmga87XHJcbiAgICAgICAgICogQHBhcmFtIOiBjOS9jee8luWPt1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhY2hlU2VydmljZS5nZXRQb3NpdGlvbkRldGFpbChpZCxyZXN1bHQ9PntcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmRldGFpbD1yZXN1bHQ7XHJcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOS4iuS8oOaWsOeugOWOhueCueWHu+aOqOiNkOaOqOiNkFxyXG4gICAgICovXHJcbiAgICBzdWJtaXRJbnRhYjEoKSB7XHJcbiAgICAgICAgbGV0IGZvcm0xYnV0dG9uPXRoaXMuZGF0YS5mb3JtMWJ1dHRvbixcclxuICAgICAgICAgICAgZm9ybTFEYXRhPXRoaXMuZGF0YS5mb3JtMURhdGE7XHJcbiAgICAgICAgZm9ybTFidXR0b249PSd0cnVlJz90aGlzLnJlY29tbWVuZFVwbG9hZChmb3JtMURhdGEpOltdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeCueWHu+aIkeimgeaOqOiNkCDkuIrkvKDnroDljoZcclxuICAgICAqIEBwYXJhbSBmb3JtMURhdGFcclxuICAgICAqL1xyXG4gICAgcmVjb21tZW5kVXBsb2FkKGZvcm0xRGF0YSkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDlh7rnjrDlvLnnqpdcclxuICAgICAgICAgKi9cclxuICAgICAgICBuZXcgTW9kYWwoe1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+aPkOekuicsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VGVtcGxhdGU6IG1rKCc8cCBjbGFzcz1cImNhcmQtcFwiPuehruiupOWAmemAieS6uueugOWOhuS/oeaBr+WHhuehrjxicj7mjqjojZDmiJDlip/njI7lpLTkv53miqTmnJ/kuLogNiDkuKrmnIg8L3A+JyksXHJcbiAgICAgICAgICAgICAgICBva0J1dHRvbjogJ+ehruiupCcsXHJcbiAgICAgICAgICAgICAgICBjYW5jZWxCdXR0b246ICflj5bmtognLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6NDAwXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSkuJG9uKCdvaycsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiDngrnlh7tvayDmj5DkuqTkuIrkvKDnroDljobor7fmsYLjgIJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNhY2hlU2VydmljZS5yZWNvbW1lbmRVcGxvYWQoZm9ybTFEYXRhLChkYXRhKT0+e1xyXG4gICAgICAgICAgICAgICAgbmV3IE1vZGFsKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn6YCa55+lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFRlbXBsYXRlOiBtaygnPHAgY2xhc3M9XCJjYXJkLXBcIj7mjqjojZDmiJDlip/vvIE8L3A+JyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rQnV0dG9uOiAn56Gu6K6kJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6NDAwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0pLiRvbignb2snLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgICAgICB9LChlcnJkYXRhLGVyclJlc3VsdCk9PntcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbXNnPWVyclJlc3VsdC5tc2c7XHJcbiAgICAgICAgICAgICAgICAvLyBtc2cgICDlnKhlcnJSZXN1bHTph4zpnaJcclxuICAgICAgICAgICAgICAgIG5ldyBNb2RhbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+aOqOiNkOWksei0pScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogbWsoJzxwIGNsYXNzPVwiY2FyZC1wXCI+Jyttc2crJzwvcD4nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2tCdXR0b246ICfnoa7orqQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDo0MDBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSkuJG9uKCdvaycsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpgInmi6nlt7LmnInnroDljobmjqjojZBcclxuICAgICAqL1xyXG4gICAgc3VibWl0SW50YWIyKCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50UmVzdW1lPXRoaXMuZGF0YS5jdXJyZW50UmVzdW1lO1xyXG4gICAgICAgIHRoaXMucmVjb21tZW5kVXBsb2FkKGN1cnJlbnRSZXN1bWUpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq3lj7fnoIHlkozpgq7nrrEgICAgICDvvIjlj7fnoIHlj6rlr7nplb/luqblgZrkuobliKTmlq3vvIlcclxuICAgICAqIEBwYXJhbSBvcHRpb24gICAgIOmcgOimgeWIpOaWreeahOWAvFxyXG4gICAgICogQHBhcmFtIG5hbWUgICAgICAg6ZyA6KaB5Yik5pat55qE5bGe5oCn5ZCNXHJcbiAgICAgKi9cclxuICAgIGNvbnRyb2wob3B0aW9uLG5hbWUpIHtcclxuICAgICAgIGxldCAgZXJyRGF0YT10aGlzLmRhdGEuZXJyRGF0YTtcclxuICAgICAgIGlmKG5hbWU9PSdtb2JpbGUnKXtcclxuICAgICAgICAgICBvcHRpb24ubGVuZ3RoPT0xMT9lcnJEYXRhW25hbWVdPTA6ZXJyRGF0YVtuYW1lXT0xO1xyXG4gICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgIGxldCByZWcgPSAvXihbYS16QS1aMC05Xy1dKStAKFthLXpBLVowLTlfLV0pKyguW2EtekEtWjAtOV8tXSkrLztcclxuICAgICAgICAgICByZWcudGVzdChvcHRpb24pPT10cnVlP2VyckRhdGFbbmFtZV09MDplcnJEYXRhW25hbWVdPTE7XHJcbiAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWdyZWUoKSB7XHJcbiAgICAgICAgY2FjaGVTZXJ2aWNlLmdldERlZ3JlZSgocmVzdWx0KT0+IHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmRlZ3JlZT1yZXN1bHQ7XHJcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiDpgInmi6nlt7LmnInnroDljoZcclxuICAgICAqL1xyXG4gICAgc2VsZWN0SGF2ZUZpbGUoKSB7XHJcbiAgICAgICAgbGV0IF9zZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5nZXRSZXN1bWUobnVsbCwxLGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXN1bWU9X3NlbGYuZGF0YS5yZXN1bWUsXHJcbiAgICAgICAgICAgICAgICBwYWdlPV9zZWxmLmRhdGEucGFnZTtcclxuICAgICAgICAgICAgbmV3IE1vZGFsKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+mAieaLqeW3suacieeugOWOhicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFRlbXBsYXRlOiBtayhzZWxlY3RNb2RlbCksICAgIC8vIHNlbGVjdE1vZGVsIOaooeadv1xyXG4gICAgICAgICAgICAgICAgICAgIG9rQnV0dG9uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDo4NjAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiDnjI7lpLTlvpfliLDnroDljoZcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0UmVzdW1lKGFwcE5hbWUsY3VycmVudFBhZ2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIF9zZWxmLmdldFJlc3VtZShhcHBOYW1lLGN1cnJlbnRQYWdlLCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5yZXN1bWU9X3NlbGYuZGF0YS5yZXN1bWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5wYWdlPV9zZWxmLmRhdGEucGFnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICog6K6p54i257uE5Lu26I635b6XcGFnZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9ialxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBwYWdlTm93KG9iail7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2U9b2JqLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE9dGhpcy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zZWxmLmRhdGEuY3VycmVudFBhZ2U9cGFnZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFJlc3VtZShkYXRhLmFwcE5hbWUscGFnZSlcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiDlvZPliY3nroDljoZcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcmVzdW1lKG9iail7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYuZGF0YS5jdXJyZW50UmVzdW1lPW9iajtcclxuICAgICAgICAgICAgICAgICAgICBfc2VsZi4kdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635b6X54yO5aS05bey5pyJ55qE566A5Y6GXHJcbiAgICAgKiBAcGFyYW0gYXBwTmFtZSAgICAg5pCc57Si5qGG6L6T5YWl55qE5YaF5a65XHJcbiAgICAgKiBAcGFyYW0gY3VycmVudFBhZ2Ug5b2T5YmN6aG1XHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgIGdldFJlc3VtZShhcHBOYW1lLGN1cnJlbnRQYWdlLGNhbGxiYWNrKXtcclxuXHJcbiAgICAgICAgbGV0IHNlbGVjdE9iaj17XHJcbiAgICAgICAgICAgIGFwcE5hbWU6YXBwTmFtZSB8fCBudWxsLFxyXG4gICAgICAgICAgICBjdXJyZW50UGFnZTpjdXJyZW50UGFnZSB8fCAxLFxyXG4gICAgICAgICAgICByb3dzOjZcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNhY2hlU2VydmljZS5zZWxlY3RIYXZlRmlsZShzZWxlY3RPYmosKGRhdGEpID0+e1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEucmVzdW1lPWRhdGEubGlzdDtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnBhZ2U9ZGF0YS5wYWdlO1xyXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgICAgICAgICAgY2FsbGJhY2smJmNhbGxiYWNrKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIOW+l+WIsOW3peS9nOeahOW5tOS7veaciOS7vVxyXG4gICAgICovXHJcbiAgICBnZXRZZWFyc0FuZE1vbnRoKCkge1xyXG4gICAgICAgIGxldCBkYXRlPW5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIGRhdGE9dGhpcy5kYXRhO1xyXG4gICAgICAgIGxldCB5ZWFyTm93PWRhdGUuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgICAgYXJyPVswLDEsMiwzLDQsNSw2LDcsOCw5XTtcclxuICAgICAgICAgICAgZGF0YS55ZWFyc0FycmF5PUFycmF5LmZyb20oWy4uLmFycl0sICh4KSA9PiB5ZWFyTm93IC0geCk7XHJcbiAgICAgICAgICAgIGRhdGEubW9udGhzQXJyYXk9QXJyYXkuZnJvbShbLi4uYXJyLDEwLDExXSwoeCkgPT4geCsxKTtcclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qOA6aqM6KGo5Y2VIHRhYjEg5piv5ZCm5aGr5YaZ5a6M5pW0XHJcbiAgICAgKi9cclxuICAgIGNoZWNrVGFiMSgpIHtcclxuICAgICAgICBsZXQgZm9ybTFEYXRhPXRoaXMuZGF0YS5mb3JtMURhdGEsXHJcbiAgICAgICAgICAgIGVyckRhdGE9dGhpcy5kYXRhLmVyckRhdGE7XHJcbiAgICAgICAgbGV0IEZsYWc9WydpZCcsJ2FwcE5hbWUnLCdhcHBlbmRpeElkJywnZW1haWwnLCdnZW5kZXInLCdtb2JpbGUnLCdub3dDb21wYW55Jywnbm93UG9zaXRpb24nLCd0b3BEZWdyZWUnLCd3b3JrWWVhcnNTdHInXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog55uR5ZCs6KGo5Y2VXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2Zvcm0xRGF0YScsKG5ld1YpPT57XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBGbGFnKXtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWW0ZsYWdba2V5XV09PXVuZGVmaW5lZCB8fCBuZXdWW0ZsYWdba2V5XV09PT0nJ3x8IGVyckRhdGFbRmxhZ1trZXldXT09MSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmZvcm0xYnV0dG9uPSdmYWxzZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kYXRhLmZvcm0xYnV0dG9uPSd0cnVlJztcclxuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKCk7XHJcbiAgICAgICAgfSx0cnVlKVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog55uR5ZCs5bel5L2c5bm05ZKM5pyI5Lu955qE5Y+Y5YyWXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ3dvcmsnLChuZXdWKT0+e1xyXG4gICAgICAgICAgICBpZihuZXdWLlllYXIgIT11bmRlZmluZWQgJiYgbmV3Vi5Nb250aCAhPXVuZGVmaW5lZClcclxuICAgICAgICAgICAgZm9ybTFEYXRhLndvcmtZZWFyc1N0cj1uZXdWLlllYXIrJy0wJytuZXdWLk1vbnRoKyctMDEnO1xyXG4gICAgICAgIH0sdHJ1ZSlcclxuICAgIH0sXHJcblxyXG4gICAgX191cGxvYWRGaWxlKGUpIHtcclxuICAgICAgICBsZXQgZmlsZSA9IGUudGFyZ2V0LFxyXG4gICAgICAgICAgICBmaWxlU2l6ZSA9IHRoaXMuX19nZXRGaWxlU2l6ZShmaWxlKTtcclxuXHJcblxyXG4gICAgICAgIGlmICghL1xcLihwbmd8anBnfGpwZWd8cGRmKSQvaS50ZXN0KGZpbGUudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIE5vdGlmeS53YXJuaW5nKCfmlofku7bmoLzlvI/pnZ7ms5UnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZpbGVTaXplID4gMjAgKiAxMDI0KSB7XHJcbiAgICAgICAgICAgIE5vdGlmeS53YXJuaW5nKCfpmYTku7blv4XpobvlsI/kuo4yME1iJyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiR1cGRhdGUoKTtcclxuICAgICAgICB0aGlzLl9fZmlsZVVwSGFuZGxlKCk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaWh+S7tuWkp+Wwj1xyXG4gICAgICogQHBhcmFtIGlucHV0IOS4iuS8oOaWh+S7tueahGlucHV05YWD57SgXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX19nZXRGaWxlU2l6ZShpbnB1dCkge1xyXG5cclxuICAgICAgICB2YXIgIGZpbGVTaXplID0gMDtcclxuICAgICAgICBpZiAoIWlucHV0LmZpbGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0LmZpbGVzWzBdKSB7XHJcbiAgICAgICAgICAgIGZpbGVTaXplID0gaW5wdXQuZmlsZXNbMF0uc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbGVTaXplIC8gMTAyNDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDkuLvopoHlpITnkIbkuIrkvKDnmoTlm57osINcclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX19maWxlVXBIYW5kbGUoKXtcclxuXHJcbiAgICAgICAgbGV0IHJlZnMgPSB0aGlzLiRyZWZzLFxyXG4gICAgICAgICAgICBkYXRhPXRoaXMuZGF0YTtcclxuICAgICAgICBsZXQgbWFzayA9IG5ldyBNYXNrKCkuJGluamVjdChkb2N1bWVudC5ib2R5KTtcclxuICAgICAgICB0aGlzLl9fdXBsb2FkKHJlZnNbJ2Zvcm0nXSwoanNvbik9PntcclxuICAgICAgICAgICAgbWFzay5jbG9zZSgpO1xyXG4gICAgICAgICAgICBkYXRhLmZvcm0xRGF0YS5hcHBlbmRpeElkPWpzb24uZGF0YS5pZDtcclxuICAgICAgICAgICAgZGF0YS5maWxlbmFtZT1qc29uLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgcmVmc1snZm9ybSddLmVsZW1lbnRzLmZpbGUudmFsdWU9Jyc7XHJcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5LiK5LygXHJcbiAgICAgKiBAcGFyYW0gZm9ybVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfX3VwbG9hZChmb3JtLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICBsZXQgaWZyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyksXHJcbiAgICAgICAgICAgIHJuZCA9IChNYXRoLnJhbmRvbSgpICsgJycpLnN1YnN0cigtOCksXHJcbiAgICAgICAgICAgIG5hbWUgPSAndXBsb2FkLWlmcicgKyBybmQ7XHJcbiAgICAgICAgICAgIGlmci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgICAgICBpZnIuc2V0QXR0cmlidXRlKCduYW1lJywgbmFtZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnIpO1xyXG4gICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCd0YXJnZXQnLCBuYW1lKTtcclxuXHJcbiAgICAgICAgaWZyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGlmckJvZHkgPSBpZnIuY29udGVudERvY3VtZW50LmJvZHksXHJcbiAgICAgICAgICAgICAgICBodG1sID0gaWZyQm9keS5pbm5lckhUTUwsXHJcbiAgICAgICAgICAgICAgICBqc29uO1xyXG5cclxuICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXjwuKz8+LywgJycpLnJlcGxhY2UoLzwuKz8+JC8sICcnKTtcclxuXHJcbiAgICAgICAgICAgIGpzb24gPSBldmFsKCcoJyArIGh0bWwgKyAnKScpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhqc29uKTtcclxuICAgICAgICAgICAgaWZyLnJlbW92ZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIOW7tui/n+mbtuavq+enku+8jOWGjeasoeaPkOS6pFxyXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PiB7XHJcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuUmVjb21tZW5kLmNvbXBvbmVudCgnUGFnZXInLFBhZ2VyKTtcclxubW9kdWxlLmV4cG9ydHM9UmVjb21tZW5kOyIsIm1vZHVsZS5leHBvcnRzPVwiPGRpdiBjbGFzcz1cXFwicy1tLWhlYWRlclxcXCI+ICAgIDxpbnB1dCBjbGFzcz1cXFwiaC1pbnBcXFwiICBwbGFjZWhvbGRlcj1cXFwi6K+36L6T5YWl5aeT5ZCNXFxcIiByLW1vZGVsPXthcHBOYW1lfS8+ICAgIDxzcGFuIGNsYXNzPVxcXCJoLXNlYXJjaFxcXCIgb24tY2xpY2s9e3RoaXMuZ2V0UmVzdW1lKGFwcE5hbWUsMSl9PuaQnOe0ojwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJzLW0tY29udGVudFxcXCI+ICAgIDxkaXYgY2xhc3M9XFxcImYtY2JcXFwiPiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29uLWhlYWRcXFwiPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuODUgbWFyXFxcIj7lp5PlkI08L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW44NVxcXCI+5oCn5YirPC9zcGFuPiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMTMwXFxcIj7miYvmnLrlj7fnoIE8L3NwYW4+ICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4yMDBcXFwiPueUteWtkOmCrueusTwvc3Bhbj4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3BhbjI3MFxcXCI+55uu5YmN5YWs5Y+4PC9zcGFuPiAgICAgICAgPC9kaXY+ICAgICAgICB7I2xpc3QgcmVzdW1lIGFzIGl0ZW19ICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29uLWxpIFxcXCIgb24tY2xpY2s9e3RoaXMucmVzdW1lKGl0ZW0pfT4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW44NSBtYXJcXFwiPntpdGVtLmFwcE5hbWV9PC9zcGFuPiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3Bhbjg1XFxcIj57I2lmIGl0ZW0uZ2VuZGVyPT0wfeeUt3sjZWxzZX3lpbN7L2lmfTwvc3Bhbj4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW4xMzBcXFwiPntpdGVtLm1vYmlsZX08L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjAwXFxcIj57aXRlbS5lbWFpbH08L3NwYW4+ICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFuMjcwXFxcIj57aXRlbS5ub3dDb21wYW55fTwvc3Bhbj4gICAgICAgICAgICA8L2Rpdj4gICAgICAgIHsvbGlzdH0gICAgPC9kaXY+ICAgIDxkaXYgY2xhc3M9XFxcImJsYW5rXFxcIj48L2Rpdj4gICAgPHBhZ2VyIHRvdGFsPXtwYWdlLnRvdGFsUGFnZX0gY3VycmVudD17Y3VycmVudFBhZ2V9PjwvcGFnZXI+PC9kaXY+XCIiLCJ2YXIgcmVzdGF0ZSA9IHJlcXVpcmUoJ3JlZ3VsYXItc3RhdGUnKTtcclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vYmFzZS9jb21wb25lbnQuanMnKTtcclxudmFyIENvb2tpZSAgPSByZXF1aXJlKCdqcy1jb29raWUvc3JjL2pzLmNvb2tpZS5qcycpO1xyXG5cclxuLyogQXBwICovXHJcbnZhciBBcHAgPSByZXF1aXJlKCcuL21vZHVsZS9hcHAvYXBwLmpzJyk7XHJcblxyXG52YXIgTG9naW4gPSByZXF1aXJlKCcuL21vZHVsZS9sb2dpbi9pbmRleC5qcycpO1xyXG52YXIgUmVzZXRQd2QgPSByZXF1aXJlKCcuL21vZHVsZS9sb2dpbi9yZXNldFB3ZC5qcycpO1xyXG52YXIgQ2hhbmdlUHdkID0gcmVxdWlyZSgnLi9tb2R1bGUvbG9naW4vY2hhbmdlUHdkLmpzJyk7XHJcblxyXG4vL+mmlumhtVxyXG52YXIgSG9tZSA9IHJlcXVpcmUoJy4vbW9kdWxlL2hvbWUvaW5kZXguanMnKTtcclxuXHJcbi8v6K+m5oOF6aG1XHJcbnZhciBEZXRhaWw9IHJlcXVpcmUoJy4vbW9kdWxlL2RldGFpbC9pbmRleC5qcycpO1xyXG5cclxuLy/nrqHnkIblkZjpobXpnaJcclxudmFyIEFkbWluID0gcmVxdWlyZSgnLi9tb2R1bGUvYWRtaW4vaW5kZXgnKTtcclxuXHJcbi8v566h55CG5ZGY5re75Yqg54yO5aS05biQ5Y+3XHJcbnZhciBodW50ZXJEZXRhaWwgPSByZXF1aXJlKCcuL21vZHVsZS9odW50ZXJEZXRhaWwvaW5kZXgnKTtcclxuXHJcbi8v54yO5aS05o6o6I2Q6aG1XHJcbnZhciBSZWNvbW1lbmQ9cmVxdWlyZSgnLi9tb2R1bGUvcmVjb21tZW5kJyk7XHJcblxyXG4vL+WFs+S6jueMjuWktFxyXG52YXIgSGVhZEh1bnRlcj1yZXF1aXJlKCcuL21vZHVsZS9oZWFkaHVudGVyJyk7XHJcblxyXG4vL+S4iuS8oOeugOWOhlxyXG52YXIgVXBsb2FkPXJlcXVpcmUoJy4vbW9kdWxlL3VwbG9hZCcpO1xyXG5cclxuXHJcbi8qIEFwcCAqL1xyXG52YXIgcm91dGVyID0gcmVzdGF0ZSh7dmlldzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpZXcnKSwgQ29tcG9uZW50OiBDb21wb25lbnQsIHJlYnVpbGQ6IHRydWV9KVxyXG4gICAgLm9uKCdiZWdpbicsZnVuY3Rpb24oZXZ0KXtcclxuXHJcbiAgICB9KVxyXG4gICAgLnN0YXRlKCdhcHAnLCBBcHAgLCAnJylcclxuICAgIC5vbihcIm5vdGZvdW5kXCIsZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAqIOeZu+mZhuWQjueahOaJvuS4jeWIsOeahOi3r+W+hOWumuWQkeWIsGhvbWXvvIxcclxuICAgICAgICAqIOacqueZu+W9leeahOaJvuS4jeWIsOeahOi3r+W+hOWumuWQkeWIsGxvZ2luXHJcbiAgICAgICAgKiAqL1xyXG4gICAgICAgIGlmIChDb29raWUuZ2V0KCdwYXNzcG9ydCcpKXtcclxuICAgICAgICAgICAgcm91dGVyLm5hdignL2hvbWUnKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHJvdXRlci5uYXYoJy9sb2dpbicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4vKiDnmbvlvZXpobXpnaIqL1xyXG5yb3V0ZXJcclxuICAgIC5zdGF0ZSgnYXBwLmxvZ2luJyxMb2dpbiwnbG9naW4nKVxyXG4gICAgLnN0YXRlKCdhcHAucmVzZXRQd2QnLFJlc2V0UHdkLCdyZXNldHB3ZCcpXHJcbiAgICAuc3RhdGUoJ2FwcC5jaGFuZ2VQd2QnLENoYW5nZVB3ZCwnY2hhbmdlcHdkJylcclxuXHJcbi8v6aaW6aG1ICBtb3VudDpmdW5jdGlvbiAoKVxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC5ob21lJyxIb21lLCdob21lJyk7XHJcblxyXG4vL+ivpuaDhemhtVxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC5kZXRhaWwnLERldGFpbCwnZGV0YWlsJyk7XHJcblxyXG4vL+aIkeeahOaOqOiNkFxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC5yZWNvbW1lbmQnLFJlY29tbWVuZCwncmVjb21tZW5kJyk7XHJcblxyXG4vL+S4iuS8oOeugOWOhumhtVxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC51cGxvYWQnLFVwbG9hZCwndXBsb2FkJyk7XHJcblxyXG4vL+WFs+S6jueMjuWktFxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC5oZWFkaHVudGVyJyxIZWFkSHVudGVyLCdoZWFkaHVudGVyJyk7XHJcblxyXG4vL+euoeeQhuWRmOmmlumhtVxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC5hZG1pbicsQWRtaW4sJ2FkbWluJyk7XHJcblxyXG4vL+euoeeQhuWRmOa3u+WKoOeMjuWktOi0puWPt+mhtVxyXG5yb3V0ZXIuc3RhdGUoJ2FwcC5odW50ZXJEZXRhaWwnLGh1bnRlckRldGFpbCwnaHVudGVyRGV0YWlsJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByb3V0ZXI7XHJcbiIsInZhciBhamF4ID0gcmVxdWlyZSgnLi9iYXNlL3JlcXVlc3QuanMnKTtcclxuXHJcbmV4cG9ydHMuZ2V0VG9rZW4gPSBmdW5jdGlvbihjYWxsYmFjayxlcnJiYWNrKXtcclxuXHJcbiAgICBhamF4LnJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDonL3N5cy9nZXRUb2tlbicsXHJcbiAgICAgICAgbWV0aG9kOidHRVQnLFxyXG4gICAgICAgIHN1Y2Nlc3M6Y2FsbGJhY2ssXHJcbiAgICAgICAgZXJyb3I6ZXJyYmFjayxcclxuICAgIH0pXHJcbn1cclxuXHJcbi8v55m75b2VXHJcbmV4cG9ydHMubG9naW4gPSBmdW5jdGlvbihwYXJhbXMsY2FsbGJhY2ssZXJyYmFjayl7XHJcblxyXG4gICAgYWpheC5yZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvc3lzL2dldExvZ2luJyxcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBkYXRhOiBwYXJhbXMsXHJcbiAgICAgICAgc3VjY2VzczogY2FsbGJhY2ssXHJcbiAgICAgICAgZXJyb3I6ZXJyYmFja1xyXG4gICAgICAgIC8vY29udGVudFR5cGU6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiDnmbvlh7pcclxuICogQHBhcmFtIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSBlcnJiYWNrXHJcbiAqL1xyXG5leHBvcnRzLmxvZ291dCA9IGZ1bmN0aW9uKGNhbGxiYWNrLGVycmJhY2spe1xyXG5cclxuICAgIGFqYXgucmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOicvc3lzL2xvZ291dCcsXHJcbiAgICAgICAgbWV0aG9kOidHRVQnLFxyXG4gICAgICAgIHN1Y2Nlc3M6Y2FsbGJhY2ssXHJcbiAgICAgICAgZXJyb3I6ZXJyYmFjayxcclxuICAgIH0pXHJcbn1cclxuLyoqXHJcbiAqIOiOt+WPlumqjOivgeeggVxyXG4gKiBAcGFyYW0g5oiQ5Yqf5Zue6LCD5Ye95pWwXHJcbiAqIEBwYXJhbSDplJnor6/lm57osIPlh73mlbBcclxuICovXHJcbmV4cG9ydHMuZ2V0VmVyaWZpY2F0aW9uQ29kZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLGVycmJhY2spe1xyXG5cclxuICAgIGFqYXgucmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOicvc3lzL2dldFZhbGlhdGlvbkNvZGUnLFxyXG4gICAgICAgIG1ldGhvZDonR0VUJyxcclxuICAgICAgICBzdWNjZXNzOmNhbGxiYWNrLFxyXG4gICAgICAgIGVycm9yOmVycmJhY2ssXHJcbiAgICB9KVxyXG59XHJcblxyXG4vKipcclxuICog5Y+R6YCB6YeN572u5a+G56CB6YKu5Lu2XHJcbiAqL1xyXG5leHBvcnRzLnNlbmRSZXNldFB3ZEVtYWlsID0gZnVuY3Rpb24ocGFyYW1zLGNhbGxiYWNrLGVycmJhY2spe1xyXG5cclxuICAgIGFqYXgucmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2ZvcmdvdFB3ZC9tYWlsJyxcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBkYXRhOiBwYXJhbXMsXHJcbiAgICAgICAgc3VjY2VzczogY2FsbGJhY2ssXHJcbiAgICAgICAgZXJyb3I6ZXJyYmFjayxcclxuXHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIOmHjee9ruWvhueggVxyXG4gKiBAcGFyYW0gcGFyYW1zXHJcbiAqIEBwYXJhbSBjYWxsYmFja1xyXG4gKiBAcGFyYW0gZXJyYmFja1xyXG4gKi9cclxuZXhwb3J0cy5yZXNldFB3ZCA9IGZ1bmN0aW9uKHBhcmFtcyxjYWxsYmFjayxlcnJiYWNrKXtcclxuXHJcbiAgICBhamF4LnJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDonL3N5cy9mb3Jnb3RQd2QvcmVzZXQvcmVzZXRQd2QnLFxyXG4gICAgICAgIG1ldGhvZDonUE9TVCcsXHJcbiAgICAgICAgc3VjY2VzczpjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG4gICAgICAgIGRhdGE6cGFyYW1zXHJcbiAgICB9KVxyXG59XHJcblxyXG4vKipcclxuICog5L+u5pS55a+G56CBXHJcbiAqIEBwYXJhbSBwYXJhbXNcclxuICogQHBhcmFtIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSBlcnJiYWNrXHJcbiAqL1xyXG5leHBvcnRzLmNoYW5nZVB3ZCA9IGZ1bmN0aW9uKHBhcmFtcyxjYWxsYmFjayxlcnJiYWNrKXtcclxuXHJcbiAgICBhamF4LnJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogJy9zeXMvcmVzZXRQd2QnLFxyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGRhdGE6IHBhcmFtcyxcclxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG5cclxuICAgIH0pO1xyXG59XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS3pppbpobXor7fmsYItLS0tLS0tLS0tLS1cclxuXHJcbmV4cG9ydHMuc2VsZWN0T3B0aW9ucz1mdW5jdGlvbiAoY2FsbGJhY2ssZXJyYmFjaykge1xyXG5cclxuICAgIGFqYXgucmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2luZGV4L29wdGlvbicsXHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG4gICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIOafpeivouiBjOS9jeWIl+ihqFxyXG4gKiBAcGFyYW0gcGFyYW1zICAg5p+l6K+i6ZyA6KaB55qE5Y+C5pWw77ybXHJcbiAqIEBwYXJhbSBjYWxsYmFja1xyXG4gKiBAcGFyYW0gZXJyYmFja1xyXG4gKi9cclxuZXhwb3J0cy5wb3NpdGlvbkxpc3Q9ZnVuY3Rpb24gKHBhcmFtcyxjYWxsYmFjayxlcnJiYWNrKSB7XHJcblxyXG4gICAgYWpheC5yZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaW5kZXgvcG9zaXRpb25MaXN0JyxcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBkYXRhOiBwYXJhbXMsXHJcbiAgICAgICAgc3VjY2VzczogY2FsbGJhY2ssXHJcbiAgICAgICAgZXJyb3I6ZXJyYmFjayxcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0t6K+m5oOF6aG16K+35rGCLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiDmn6Xor6LogYzkvY3or6bmg4VcclxuICogQHBhcmFtIHBhcmFtcyBpZFxyXG4gKiBAcGFyYW0gY2FsbGJhY2tcclxuICogQHBhcmFtIGVycmJhY2tcclxuICovXHJcbmV4cG9ydHMuZ2V0UG9zaXRpb25EZXRhaWw9ZnVuY3Rpb24gKHBhcmFtcyxjYWxsYmFjayxlcnJiYWNrKSB7XHJcbiAgICBhamF4LnJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogJy9wb3NpdGlvbi9kZXRhaWw/aWQ9JytwYXJhbXMsXHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLeaIkeimgeaOqOiNkOmhtS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiDngrnlh7vmiJHopoHmjqjojZBcclxuICogQHBhcmFtIHBhcmFtc1xyXG4gKiBAcGFyYW0gY2FsbGJhY2tcclxuICogQHBhcmFtIGVycmJhY2tcclxuICovXHJcbmV4cG9ydHMucmVjb21tZW5kVXBsb2FkPWZ1bmN0aW9uIChwYXJhbXMsY2FsbGJhY2ssZXJyYmFjaykge1xyXG5cclxuICAgIGFqYXgucmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL3JlY29tbWVuZC91cGxvYWQnLFxyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGRhdGE6IHBhcmFtcyxcclxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydHMuZ2V0RGVncmVlPWZ1bmN0aW9uIChjYWxsYmFjayxlcnJiYWNrKSB7XHJcblxyXG4gICAgYWpheC5yZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvb3B0aW9ucy9ieUNvZGUnLFxyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgc3VjY2VzczogY2FsbGJhY2ssXHJcbiAgICAgICAgZXJyb3I6ZXJyYmFjayxcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiDpgInmi6nlt7LmnInnroDljoZcclxuICogQHBhcmFtIHBhcmFtc1xyXG4gKiBAcGFyYW0gY2FsbGJhY2tcclxuICogQHBhcmFtIGVycmJhY2tcclxuICovXHJcbmV4cG9ydHMuc2VsZWN0SGF2ZUZpbGU9ZnVuY3Rpb24gKHBhcmFtcyxjYWxsYmFjayxlcnJiYWNrKSB7XHJcblxyXG4gICAgYWpheC5yZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvcmVzdW1lL3BpY2snLFxyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGRhdGE6IHBhcmFtcyxcclxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG4gICAgfSk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICog5oiR55qE5o6o6I2QXHJcbiAqIEBwYXJhbSBwYXJhbXNcclxuICogQHBhcmFtIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSBlcnJiYWNrXHJcbiAqL1xyXG5leHBvcnRzLm15UmVjb21tZW5kPWZ1bmN0aW9uIChwYXJhbXMsY2FsbGJhY2ssZXJyYmFjaykge1xyXG5cclxuICAgIGFqYXgucmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL3Jlc3VtZS9kZXRhaWwuZG8nLFxyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGRhdGE6IHBhcmFtcyxcclxuICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICBlcnJvcjplcnJiYWNrLFxyXG4gICAgfSk7XHJcbn1cclxuIixudWxsLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNSBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy8gQWRkIHNlbWljb2xvbiB0byBwcmV2ZW50IElJRkUgZnJvbSBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnQgdG8gY29uY2F0ZW5hdGVkIGNvZGUuXG47XG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEJyaW5ncyBhbiBlbnZpcm9ubWVudCBhcyBjbG9zZSB0byBFQ01BU2NyaXB0IDUgY29tcGxpYW5jZVxuICAgICAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gICAgICpcbiAgICAgKiBBbm5vdGF0ZWQgRVM1OiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vIChzcGVjaWZpYyBsaW5rcyBiZWxvdylcbiAgICAgKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICAgICAqIFJlcXVpcmVkIHJlYWRpbmc6IGh0dHA6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMS8xMi8wNS9leHRlbmRpbmctamF2YXNjcmlwdC1uYXRpdmVzL1xuICAgICAqL1xuXG4gICAgLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbiAgICAvLyBkZXJlZmVyZW5jZSB0aGF0IGNvc3RzIHVuaXZlcnNhbGx5LiBUaGlzIGFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8ga25vd24tZ29vZFxuICAgIC8vIGZ1bmN0aW9ucy5cbiAgICB2YXIgJEFycmF5ID0gQXJyYXk7XG4gICAgdmFyIEFycmF5UHJvdG90eXBlID0gJEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgJE9iamVjdCA9IE9iamVjdDtcbiAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuICAgIHZhciBGdW5jdGlvblByb3RvdHlwZSA9ICRGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgdmFyICRTdHJpbmcgPSBTdHJpbmc7XG4gICAgdmFyIFN0cmluZ1Byb3RvdHlwZSA9ICRTdHJpbmcucHJvdG90eXBlO1xuICAgIHZhciAkTnVtYmVyID0gTnVtYmVyO1xuICAgIHZhciBOdW1iZXJQcm90b3R5cGUgPSAkTnVtYmVyLnByb3RvdHlwZTtcbiAgICB2YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbiAgICB2YXIgYXJyYXlfc3BsaWNlID0gQXJyYXlQcm90b3R5cGUuc3BsaWNlO1xuICAgIHZhciBhcnJheV9wdXNoID0gQXJyYXlQcm90b3R5cGUucHVzaDtcbiAgICB2YXIgYXJyYXlfdW5zaGlmdCA9IEFycmF5UHJvdG90eXBlLnVuc2hpZnQ7XG4gICAgdmFyIGFycmF5X2NvbmNhdCA9IEFycmF5UHJvdG90eXBlLmNvbmNhdDtcbiAgICB2YXIgYXJyYXlfam9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG4gICAgdmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuICAgIHZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBIYXZpbmcgYSB0b1N0cmluZyBsb2NhbCB2YXJpYWJsZSBuYW1lIGJyZWFrcyBpbiBPcGVyYSBzbyB1c2UgdG9fc3RyaW5nLlxuICAgIHZhciB0b19zdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiBnbG9iYWwgU3ltYm9sICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgb25lLXZhci1kZWNsYXJhdGlvbi1wZXItbGluZSwgbm8tcmVkZWNsYXJlLCBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG4gICAgdmFyIGlzQ2FsbGFibGU7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1jYWxsYWJsZSAqLyB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZywgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzIC8sIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGbih2YWx1ZSkgeyB0cnkgeyB2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpOyB2YXIgc2luZ2xlU3RyaXBwZWQgPSBmblN0ci5yZXBsYWNlKC9cXC9cXC8uKlxcbi9nLCAnJyk7IHZhciBtdWx0aVN0cmlwcGVkID0gc2luZ2xlU3RyaXBwZWQucmVwbGFjZSgvXFwvXFwqWy5cXHNcXFNdKlxcKlxcLy9nLCAnJyk7IHZhciBzcGFjZVN0cmlwcGVkID0gbXVsdGlTdHJpcHBlZC5yZXBsYWNlKC9cXG4vbWcsICcgJykucmVwbGFjZSgvIHsyfS9nLCAnICcpOyByZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KHNwYWNlU3RyaXBwZWQpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgLyogbm90IGEgZnVuY3Rpb24gKi8gfSB9LCB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKSB7IHRyeSB7IGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfSBmblRvU3RyLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJywgaXNDYWxsYWJsZSA9IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHsgaWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH0gaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSBpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfSBpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH0gdmFyIHN0ckNsYXNzID0gdG9fc3RyaW5nLmNhbGwodmFsdWUpOyByZXR1cm4gc3RyQ2xhc3MgPT09IGZuQ2xhc3MgfHwgc3RyQ2xhc3MgPT09IGdlbkNsYXNzOyB9O1xuXG4gICAgdmFyIGlzUmVnZXg7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1yZWdleCAqLyB2YXIgcmVnZXhFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjLCB0cnlSZWdleEV4ZWMgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHsgdHJ5IHsgcmVnZXhFeGVjLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nOyBpc1JlZ2V4ID0gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5UmVnZXhFeGVjKHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gcmVnZXhDbGFzczsgfTtcbiAgICB2YXIgaXNTdHJpbmc7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1zdHJpbmcgKi8gdmFyIHN0clZhbHVlID0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLCB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHsgdHJ5IHsgc3RyVmFsdWUuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nOyBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlTdHJpbmdPYmplY3QodmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSBzdHJpbmdDbGFzczsgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG9uZS12YXItZGVjbGFyYXRpb24tcGVyLWxpbmUsIG5vLXJlZGVjbGFyZSwgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUgKi9cblxuICAgIC8qIGlubGluZWQgZnJvbSBodHRwOi8vbnBtanMuY29tL2RlZmluZS1wcm9wZXJ0aWVzICovXG4gICAgdmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSAkT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgLy8ganNjczppZ25vcmUgZGlzYWxsb3dVbnVzZWRWYXJpYWJsZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqLnggPT09IG9iajtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSgpKTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IChmdW5jdGlvbiAoaGFzKSB7XG4gICAgICAgIC8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlLCBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbiAgICAgICAgLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5O1xuICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzLmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkpO1xuXG4gICAgLy9cbiAgICAvLyBVdGlsXG4gICAgLy8gPT09PT09XG4gICAgLy9cblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCAvaGVscGVycy9pc1ByaW1pdGl2ZSAqL1xuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgKHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGUgIT09ICdmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgICB2YXIgaXNBY3R1YWxOYU4gPSAkTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzQWN0dWFsTmFOKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHg7XG4gICAgfTtcblxuICAgIHZhciBFUyA9IHtcbiAgICAgICAgLy8gRVM1IDkuNFxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvSW50ZWdlciAqL1xuICAgICAgICBUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgICAgIHZhciBuID0gK251bTtcbiAgICAgICAgICAgIGlmIChpc0FjdHVhbE5hTihuKSkge1xuICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1ByaW1pdGl2ZSAqL1xuICAgICAgICBUb1ByaW1pdGl2ZTogZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB2YWwsIHZhbHVlT2YsIHRvU3RyO1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlT2YgPSBpbnB1dC52YWx1ZU9mO1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZU9mLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdHIgPSBpbnB1dC50b1N0cmluZztcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlKHRvU3RyKSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRvU3RyLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVTNSA5LjlcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS45XG4gICAgICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9PYmplY3QgKi9cbiAgICAgICAgVG9PYmplY3Q6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJE9iamVjdChvKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvVWludDMyICovXG4gICAgICAgIFRvVWludDMyOiBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA+Pj4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gPT09PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVMtNSAxNS4zLjQuNVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbiAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgICAgIHZhciBib3VuZDtcbiAgICAgICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheV9wdXNoLmNhbGwoYm91bmRBcmdzLCAnJCcgKyBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgICAgICBib3VuZCA9ICRGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGFycmF5X2pvaW4uY2FsbChib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgICAgIHJldHVybiBib3VuZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gX1BsZWFzZSBub3RlOiBTaG9ydGN1dHMgYXJlIGRlZmluZWQgYWZ0ZXIgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBhcyB3ZVxuICAgIC8vIHVzZSBpdCBpbiBkZWZpbmluZyBzaG9ydGN1dHMuXG4gICAgdmFyIG93bnMgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgICB2YXIgdG9TdHIgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgICB2YXIgYXJyYXlTbGljZSA9IGNhbGwuYmluZChhcnJheV9zbGljZSk7XG4gICAgdmFyIGFycmF5U2xpY2VBcHBseSA9IGFwcGx5LmJpbmQoYXJyYXlfc2xpY2UpO1xuICAgIHZhciBzdHJTbGljZSA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc2xpY2UpO1xuICAgIHZhciBzdHJTcGxpdCA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc3BsaXQpO1xuICAgIHZhciBzdHJJbmRleE9mID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5pbmRleE9mKTtcbiAgICB2YXIgcHVzaENhbGwgPSBjYWxsLmJpbmQoYXJyYXlfcHVzaCk7XG4gICAgdmFyIGlzRW51bSA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xuICAgIHZhciBhcnJheVNvcnQgPSBjYWxsLmJpbmQoQXJyYXlQcm90b3R5cGUuc29ydCk7XG5cbiAgICAvL1xuICAgIC8vIEFycmF5XG4gICAgLy8gPT09PT1cbiAgICAvL1xuXG4gICAgdmFyIGlzQXJyYXkgPSAkQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xM1xuICAgIC8vIFJldHVybiBsZW4rYXJnQ291bnQuXG4gICAgLy8gW2J1Z2ZpeCwgaWVsdDhdXG4gICAgLy8gSUUgPCA4IGJ1ZzogW10udW5zaGlmdCgwKSA9PT0gdW5kZWZpbmVkIGJ1dCBzaG91bGQgYmUgXCIxXCJcbiAgICB2YXIgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnID0gW10udW5zaGlmdCgwKSAhPT0gMTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFycmF5X3Vuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sIGhhc1Vuc2hpZnRSZXR1cm5WYWx1ZUJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC4zLjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKCRBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG4gICAgLy8gVGhlIElzQ2FsbGFibGUoKSBjaGVjayBpbiB0aGUgQXJyYXkgZnVuY3Rpb25zXG4gICAgLy8gaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHN0cmljdCBjaGVjayBvbiB0aGVcbiAgICAvLyBpbnRlcm5hbCBjbGFzcyBvZiB0aGUgb2JqZWN0IHRvIHRyYXAgY2FzZXMgd2hlcmVcbiAgICAvLyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2FzIGFjdHVhbGx5IGEgcmVndWxhclxuICAgIC8vIGV4cHJlc3Npb24gbGl0ZXJhbCwgd2hpY2ggaW4gVjggYW5kXG4gICAgLy8gSmF2YVNjcmlwdENvcmUgaXMgYSB0eXBlb2YgXCJmdW5jdGlvblwiLiAgT25seSBpblxuICAgIC8vIFY4IGFyZSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMgcGVybWl0dGVkIGFzXG4gICAgLy8gcmVkdWNlIHBhcmFtZXRlcnMsIHNvIGl0IGlzIGRlc2lyYWJsZSBpbiB0aGVcbiAgICAvLyBnZW5lcmFsIGNhc2UgZm9yIHRoZSBzaGltIHRvIG1hdGNoIHRoZSBtb3JlXG4gICAgLy8gc3RyaWN0IGFuZCBjb21tb24gYmVoYXZpb3Igb2YgcmVqZWN0aW5nIHJlZ3VsYXJcbiAgICAvLyBleHByZXNzaW9ucy5cblxuICAgIC8vIEVTNSAxNS40LjQuMThcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMThcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9hcnJheS9mb3JFYWNoXG5cbiAgICAvLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuICAgIC8vIGFuZCBmYWlsdXJlIG9mIGAwIGluIGJveGVkU3RyaW5nYCAoUmhpbm8pXG4gICAgdmFyIGJveGVkU3RyaW5nID0gJE9iamVjdCgnYScpO1xuICAgIHZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxuICAgIHZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgICAgICB2YXIgdGhyZXdFeGNlcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIH0sICd4Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyZXdFeGNlcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW1ldGhvZCAmJiAhdGhyZXdFeGNlcHRpb24gJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xuICAgIH07XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5mb3JFYWNoIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTlcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTlcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L21hcFxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLm1hcCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLm1hcCkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvZmlsdGVyXG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmlsdGVyIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHZhbHVlLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZmlsdGVyKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE2XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE2XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnlcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZXZlcnkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICEodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5ldmVyeSkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xN1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xN1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbi8qLCB0aGlzQXJnICovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5zb21lIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5zb21lKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjIxXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIxXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VcbiAgICB2YXIgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG4gICAgaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZSkge1xuICAgICAgICByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlLmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSkgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4vKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoKytpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sICFyZWR1Y2VDb2VyY2VzVG9PYmplY3QpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHRcbiAgICB2YXIgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcbiAgICAgICAgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9KSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4vKiwgaW5pdGlhbCovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUsIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0KTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG4gICAgdmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCAqLykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaSA9IEVTLlRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBtYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE1XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE1XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcbiAgICB2YXIgaGFzRmlyZWZveDJMYXN0SW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmxhc3RJbmRleE9mICYmIFswLCAxXS5sYXN0SW5kZXhPZigwLCAtMykgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaSA9IG1pbihpLCBFUy5Ub0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBsZW5ndGggLSBNYXRoLmFicyhpKTtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VhcmNoRWxlbWVudCA9PT0gc2VsZltpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTJcbiAgICB2YXIgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSBbMSwgMl07XG4gICAgICAgIHZhciByZXN1bHQgPSBhLnNwbGljZSgpO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IDIgJiYgaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDA7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnIHdoZXJlIC5zcGxpY2UoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAhc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDE7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbWF4KEVTLlRvSW50ZWdlcih0aGlzLmxlbmd0aCksIDApO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWxldGVDb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwoYXJncywgdGhpcy5sZW5ndGggLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG4gICAgdmFyIHNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgICAgIC8vIFNhZmFyaSA3LzggYnJlYWtzIHdpdGggc3BhcnNlIGFycmF5cyBvZiBzaXplIDFlNSBvciBncmVhdGVyXG4gICAgICAgIHZhciBhcnIgPSBuZXcgJEFycmF5KDFlNSk7XG4gICAgICAgIC8vIG5vdGU6IHRoZSBpbmRleCBNVVNUIGJlIDggb3IgbGFyZ2VyIG9yIHRoZSB0ZXN0IHdpbGwgZmFsc2UgcGFzc1xuICAgICAgICBhcnJbOF0gPSAneCc7XG4gICAgICAgIGFyci5zcGxpY2UoMSwgMSk7XG4gICAgICAgIC8vIG5vdGU6IHRoaXMgdGVzdCBtdXN0IGJlIGRlZmluZWQgKmFmdGVyKiB0aGUgaW5kZXhPZiBzaGltXG4gICAgICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzMxM1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoJ3gnKSA9PT0gNztcbiAgICB9KCkpO1xuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgICAgICAvLyBPcGVyYSAxMi4xNSBicmVha3Mgb24gdGhpcywgbm8gaWRlYSB3aHkuXG4gICAgICAgIHZhciBuID0gMjU2O1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIGFycltuXSA9ICdhJztcbiAgICAgICAgYXJyLnNwbGljZShuICsgMSwgMCwgJ2InKTtcbiAgICAgICAgcmV0dXJuIGFycltuXSA9PT0gJ2EnO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gRVMuVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgoRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcblxuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgdmFyIGZyb207XG4gICAgICAgICAgICB3aGlsZSAoayA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoYWN0dWFsU3RhcnQgKyBrKTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBBW2tdID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB2YXIgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRvO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhLID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBtYXhLKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgPSBsZW47XG4gICAgICAgICAgICAgICAgdmFyIG1pbksgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGl0ZW1Db3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IG1pbkspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IGFjdHVhbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bdG9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gYWN0dWFsU3RhcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgT1trXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9XG4gICAgfSwgIXNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzIHx8ICFzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyk7XG5cbiAgICB2YXIgb3JpZ2luYWxKb2luID0gQXJyYXlQcm90b3R5cGUuam9pbjtcbiAgICB2YXIgaGFzU3RyaW5nSm9pbkJ1ZztcbiAgICB0cnkge1xuICAgICAgICBoYXNTdHJpbmdKb2luQnVnID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbCgnMTIzJywgJywnKSAhPT0gJzEsMiwzJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhc1N0cmluZ0pvaW5CdWcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzU3RyaW5nSm9pbkJ1Zykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgICAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwoaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNTdHJpbmdKb2luQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSm9pblVuZGVmaW5lZEJ1ZyA9IFsxLCAyXS5qb2luKHVuZGVmaW5lZCkgIT09ICcxLDInO1xuICAgIGlmIChoYXNKb2luVW5kZWZpbmVkQnVnKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcCA9IHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnID8gJywnIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbCh0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNKb2luVW5kZWZpbmVkQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgcHVzaFNoaW0gPSBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIG4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBPW24gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBPLmxlbmd0aCA9IG4gKyBpO1xuICAgICAgICByZXR1cm4gbiArIGk7XG4gICAgfTtcblxuICAgIHZhciBwdXNoSXNOb3RHZW5lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChvYmosIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgb2JqLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2Ygb2JqWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhvYmosIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5X3B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoU2hpbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSwgcHVzaElzTm90R2VuZXJpYyk7XG5cbiAgICAvLyBUaGlzIGZpeGVzIGEgdmVyeSB3ZWlyZCBidWcgaW4gT3BlcmEgMTAuNiB3aGVuIHB1c2hpbmcgYHVuZGVmaW5lZFxuICAgIHZhciBwdXNoVW5kZWZpbmVkSXNXZWlyZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyci5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgYXJyLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgYXJyWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhhcnIsIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwgeyBwdXNoOiBwdXNoU2hpbSB9LCBwdXNoVW5kZWZpbmVkSXNXZWlyZCk7XG5cbiAgICAvLyBFUzUgMTUuMi4zLjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTBcbiAgICAvLyBGaXggYm94ZWQgc3RyaW5nIGJ1Z1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2VBcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LCBzcGxpdFN0cmluZyk7XG5cbiAgICB2YXIgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQobnVsbCk7XG4gICAgICAgICAgICBbMSwgMl0uc29ydCh7fSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgdmFyIHNvcnRUaHJvd3NPblJlZ2V4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHByb2JsZW0gaW4gRmlyZWZveCA0LCBpbiB3aGljaCBgdHlwZW9mIC9hLyA9PT0gJ2Z1bmN0aW9uJ2BcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFsxLCAyXS5zb3J0KC9hLyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0oKSk7XG4gICAgdmFyIHNvcnRJZ25vcmVzVW5kZWZpbmVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXBwbGllcyBpbiBJRSA4LCBmb3Igb25lLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZUZuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmVGbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlTb3J0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNvbXBhcmVGbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29ydCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheVNvcnQodGhpcywgY29tcGFyZUZuKTtcbiAgICAgICAgfVxuICAgIH0sIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zIHx8ICFzb3J0SWdub3Jlc1VuZGVmaW5lZCB8fCAhc29ydFRocm93c09uUmVnZXgpO1xuXG4gICAgLy9cbiAgICAvLyBPYmplY3RcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1IDE1LjIuMy4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4gICAgLy8gaHR0cDovL3doYXR0aGVoZWFkc2FpZC5jb20vMjAxMC8xMC9hLXNhZmVyLW9iamVjdC1rZXlzLWNvbXBhdGliaWxpdHktaW1wbGVtZW50YXRpb25cbiAgICB2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtKHsgJ3RvU3RyaW5nJzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbiAgICB2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG4gICAgdmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbiAgICB9O1xuICAgIHZhciBibGFja2xpc3RlZEtleXMgPSB7XG4gICAgICAgICR3aW5kb3c6IHRydWUsXG4gICAgICAgICRjb25zb2xlOiB0cnVlLFxuICAgICAgICAkcGFyZW50OiB0cnVlLFxuICAgICAgICAkc2VsZjogdHJ1ZSxcbiAgICAgICAgJGZyYW1lOiB0cnVlLFxuICAgICAgICAkZnJhbWVzOiB0cnVlLFxuICAgICAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICAgICAkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuICAgICAgICAkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG4gICAgICAgICRleHRlcm5hbDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGdsb2JhbHMgd2luZG93ICovXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghYmxhY2tsaXN0ZWRLZXlzWyckJyArIGtdICYmIG93bnMod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZG9udEVudW1zID0gW1xuICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgIF07XG4gICAgdmFyIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICAvLyB0YWtlbiBkaXJlY3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvaXMtYXJndW1lbnRzL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgLy8gY2FuIGJlIHJlcGxhY2VkIHdpdGggcmVxdWlyZSgnaXMtYXJndW1lbnRzJykgaWYgd2UgZXZlciB1c2UgYSBidWlsZCBwcm9jZXNzIGluc3RlYWRcbiAgICB2YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cih2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuICAgIH07XG4gICAgdmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgICFpc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNDYWxsYWJsZSh2YWx1ZS5jYWxsZWUpO1xuICAgIH07XG4gICAgdmFyIGlzQXJndW1lbnRzID0gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuXG4gICAgZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAgICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaXNGbiA9IGlzQ2FsbGFibGUob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciBpc0FyZ3MgPSBpc0FyZ3VtZW50cyhvYmplY3QpO1xuICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuICAgICAgICAgICAgdmFyIGlzU3RyID0gaXNPYmplY3QgJiYgaXNTdHJpbmcob2JqZWN0KTtcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdCAmJiAhaXNGbiAmJiAhaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhlS2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0ZuO1xuICAgICAgICAgICAgaWYgKChpc1N0ciAmJiBoYXNTdHJpbmdFbnVtQnVnKSB8fCBpc0FyZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbCh0aGVLZXlzLCAkU3RyaW5nKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBvd25zKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHRoZUtleXMsICRTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9udEVudW0gPSBkb250RW51bXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgb3ducyhvYmplY3QsIGRvbnRFbnVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwodGhlS2V5cywgZG9udEVudW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoZUtleXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gJE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnXG4gICAgICAgIHJldHVybiAkT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG4gICAgfSgxLCAyKSk7XG4gICAgdmFyIGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ0tleXMgPSAkT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5c1swXSAhPT0gMTtcbiAgICB9KDEpKTtcbiAgICB2YXIgb3JpZ2luYWxLZXlzID0gJE9iamVjdC5rZXlzO1xuICAgIGRlZmluZVByb3BlcnRpZXMoJE9iamVjdCwge1xuICAgICAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxLZXlzKGFycmF5U2xpY2Uob2JqZWN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sICFrZXlzV29ya3NXaXRoQXJndW1lbnRzIHx8IGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcpO1xuXG4gICAgLy9cbiAgICAvLyBEYXRlXG4gICAgLy8gPT09PVxuICAgIC8vXG5cbiAgICB2YXIgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgPSBuZXcgRGF0ZSgtMzUwOTgyNzMyOTYwMDI5MikuZ2V0VVRDTW9udGgoKSAhPT0gMDtcbiAgICB2YXIgYU5lZ2F0aXZlVGVzdERhdGUgPSBuZXcgRGF0ZSgtMTUwOTg0MjI4OTYwMDI5Mik7XG4gICAgdmFyIGFQb3NpdGl2ZVRlc3REYXRlID0gbmV3IERhdGUoMTQ0OTY2MjQwMDAwMCk7XG4gICAgdmFyIGhhc1RvVVRDU3RyaW5nRm9ybWF0QnVnID0gYU5lZ2F0aXZlVGVzdERhdGUudG9VVENTdHJpbmcoKSAhPT0gJ01vbiwgMDEgSmFuIC00NTg3NSAxMTo1OTo1OSBHTVQnO1xuICAgIHZhciBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWc7XG4gICAgdmFyIGhhc1RvU3RyaW5nRm9ybWF0QnVnO1xuICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IGFOZWdhdGl2ZVRlc3REYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgaWYgKHRpbWVab25lT2Zmc2V0IDwgLTcyMCkge1xuICAgICAgICBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWcgPSBhTmVnYXRpdmVUZXN0RGF0ZS50b0RhdGVTdHJpbmcoKSAhPT0gJ1R1ZSBKYW4gMDIgLTQ1ODc1JztcbiAgICAgICAgaGFzVG9TdHJpbmdGb3JtYXRCdWcgPSAhKC9eVGh1IERlYyAxMCAyMDE1IFxcZFxcZDpcXGRcXGQ6XFxkXFxkIEdNVFstXFwrXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KGFQb3NpdGl2ZVRlc3REYXRlLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvRGF0ZVN0cmluZygpICE9PSAnTW9uIEphbiAwMSAtNDU4NzUnO1xuICAgICAgICBoYXNUb1N0cmluZ0Zvcm1hdEJ1ZyA9ICEoL15XZWQgRGVjIDA5IDIwMTUgXFxkXFxkOlxcZFxcZDpcXGRcXGQgR01UWy1cXCtdXFxkXFxkXFxkXFxkKD86IHwkKS8pLnRlc3QoYVBvc2l0aXZlVGVzdERhdGUudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsR2V0RnVsbFllYXIgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFllYXIpO1xuICAgIHZhciBvcmlnaW5hbEdldE1vbnRoID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldE1vbnRoKTtcbiAgICB2YXIgb3JpZ2luYWxHZXREYXRlID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldERhdGUpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ0Z1bGxZZWFyKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENNb250aCA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNb250aCk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDRGF0ZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENEYXRlKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENEYXkgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF5KTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENIb3VycyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENIb3Vycyk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDTWludXRlcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaW51dGVzKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENTZWNvbmRzID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ1NlY29uZHMpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ01pbGxpc2Vjb25kcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaWxsaXNlY29uZHMpO1xuICAgIHZhciBkYXlOYW1lID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbiAgICB2YXIgbW9udGhOYW1lID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuICAgIHZhciBkYXlzSW5Nb250aCA9IGZ1bmN0aW9uIGRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEdldERhdGUobmV3IERhdGUoeWVhciwgbW9udGgsIDApKTtcbiAgICB9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24gZ2V0RnVsbFllYXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG9yaWdpbmFsR2V0TW9udGgodGhpcykgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5ZWFyICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5ZWFyO1xuICAgICAgICB9LFxuICAgICAgICBnZXRNb250aDogZnVuY3Rpb24gZ2V0TW9udGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBkYXRlID0gb3JpZ2luYWxHZXREYXRlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGF5cyA9IGRheXNJbk1vbnRoKDAsIHllYXIgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRheXMgLSBkYXRlKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDRnVsbFllYXI6IGZ1bmN0aW9uIGdldFVUQ0Z1bGxZZWFyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWVhciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWVhcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDTW9udGg6IGZ1bmN0aW9uIGdldFVUQ01vbnRoKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVVENEYXRlOiBmdW5jdGlvbiBnZXRVVENEYXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXlzIC0gZGF0ZSkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1Zyk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIHRvVVRDU3RyaW5nOiBmdW5jdGlvbiB0b1VUQ1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5ID0gb3JpZ2luYWxHZXRVVENEYXkodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgaG91ciA9IG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyk7XG4gICAgICAgICAgICB2YXIgbWludXRlID0gb3JpZ2luYWxHZXRVVENNaW51dGVzKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlY29uZCA9IG9yaWdpbmFsR2V0VVRDU2Vjb25kcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyICsgJyAnICtcbiAgICAgICAgICAgICAgICAoaG91ciA8IDEwID8gJzAnICsgaG91ciA6IGhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAobWludXRlIDwgMTAgPyAnMCcgKyBtaW51dGUgOiBtaW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAoc2Vjb25kIDwgMTAgPyAnMCcgKyBzZWNvbmQgOiBzZWNvbmQpICsgJyBHTVQnO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9VVENTdHJpbmdGb3JtYXRCdWcpO1xuXG4gICAgLy8gT3BlcmEgMTIgaGFzIGAsYFxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9EYXRlU3RyaW5nOiBmdW5jdGlvbiB0b0RhdGVTdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnKTtcblxuICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgaWYgKGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvU3RyaW5nRm9ybWF0QnVnKSB7XG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB2YXIgaG91ciA9IHRoaXMuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIHZhciBtaW51dGUgPSB0aGlzLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIHZhciB0aW1lem9uZU9mZnNldCA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBob3Vyc09mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5hYnModGltZXpvbmVPZmZzZXQpIC8gNjApO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXNPZmZzZXQgPSBNYXRoLmZsb29yKE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KSAlIDYwKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnICcgK1xuICAgICAgICAgICAgICAgIG1vbnRoTmFtZVttb250aF0gKyAnICcgK1xuICAgICAgICAgICAgICAgIChkYXRlIDwgMTAgPyAnMCcgKyBkYXRlIDogZGF0ZSkgKyAnICcgK1xuICAgICAgICAgICAgICAgIHllYXIgKyAnICcgK1xuICAgICAgICAgICAgICAgIChob3VyIDwgMTAgPyAnMCcgKyBob3VyIDogaG91cikgKyAnOicgK1xuICAgICAgICAgICAgICAgIChtaW51dGUgPCAxMCA/ICcwJyArIG1pbnV0ZSA6IG1pbnV0ZSkgKyAnOicgK1xuICAgICAgICAgICAgICAgIChzZWNvbmQgPCAxMCA/ICcwJyArIHNlY29uZCA6IHNlY29uZCkgKyAnIEdNVCcgK1xuICAgICAgICAgICAgICAgICh0aW1lem9uZU9mZnNldCA+IDAgPyAnLScgOiAnKycpICtcbiAgICAgICAgICAgICAgICAoaG91cnNPZmZzZXQgPCAxMCA/ICcwJyArIGhvdXJzT2Zmc2V0IDogaG91cnNPZmZzZXQpICtcbiAgICAgICAgICAgICAgICAobWludXRlc09mZnNldCA8IDEwID8gJzAnICsgbWludXRlc09mZnNldCA6IG1pbnV0ZXNPZmZzZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS41LjQzXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQzXG4gICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3RyaW5nIHZhbHVlIHJlcHJlc2VudCB0aGUgaW5zdGFuY2UgaW4gdGltZVxuICAgIC8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4gICAgLy8gc3RyaW5nIGZvcm1hdCBkZWZpbmVkIGluIDE1LjkuMS4xNS4gQWxsIGZpZWxkcyBhcmUgcHJlc2VudCBpbiB0aGUgU3RyaW5nLlxuICAgIC8vIFRoZSB0aW1lIHpvbmUgaXMgYWx3YXlzIFVUQywgZGVub3RlZCBieSB0aGUgc3VmZml4IFouIElmIHRoZSB0aW1lIHZhbHVlIG9mXG4gICAgLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICB2YXIgbmVnYXRpdmVEYXRlID0gLTYyMTk4NzU1MjAwMDAwO1xuICAgIHZhciBuZWdhdGl2ZVllYXJTdHJpbmcgPSAnLTAwMDAwMSc7XG4gICAgdmFyIGhhc05lZ2F0aXZlRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xO1xuICAgIHZhciBoYXNTYWZhcmk1MURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZSgtMSkudG9JU09TdHJpbmcoKSAhPT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG5cbiAgICB2YXIgZ2V0VGltZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRUaW1lKTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0aGlzKSB8fCAhaXNGaW5pdGUoZ2V0VGltZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZG9wZSBQaG90b3Nob3AgcmVxdWlyZXMgdGhlIHNlY29uZCBjaGVjay5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICAgICAgeWVhciArPSBNYXRoLmZsb29yKG1vbnRoIC8gMTIpO1xuICAgICAgICAgICAgbW9udGggPSAobW9udGggJSAxMiArIDEyKSAlIDEyO1xuXG4gICAgICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbbW9udGggKyAxLCBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyksIG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyksIG9yaWdpbmFsR2V0VVRDTWludXRlcyh0aGlzKSwgb3JpZ2luYWxHZXRVVENTZWNvbmRzKHRoaXMpXTtcbiAgICAgICAgICAgIHllYXIgPSAoXG4gICAgICAgICAgICAgICAgKHllYXIgPCAwID8gJy0nIDogKHllYXIgPiA5OTk5ID8gJysnIDogJycpKSArXG4gICAgICAgICAgICAgICAgc3RyU2xpY2UoJzAwMDAwJyArIE1hdGguYWJzKHllYXIpLCAoMCA8PSB5ZWFyICYmIHllYXIgPD0gOTk5OSkgPyAtNCA6IC02KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d28gZGlnaXRzLlxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHN0clNsaWNlKCcwMCcgKyByZXN1bHRbaV0sIC0yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHllYXIgKyAnLScgKyBhcnJheVNsaWNlKHJlc3VsdCwgMCwgMikuam9pbignLScpICtcbiAgICAgICAgICAgICAgICAnVCcgKyBhcnJheVNsaWNlKHJlc3VsdCwgMikuam9pbignOicpICsgJy4nICtcbiAgICAgICAgICAgICAgICBzdHJTbGljZSgnMDAwJyArIG9yaWdpbmFsR2V0VVRDTWlsbGlzZWNvbmRzKHRoaXMpLCAtMykgKyAnWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZURhdGVCdWcgfHwgaGFzU2FmYXJpNTFEYXRlQnVnKTtcblxuICAgIC8vIEVTNSAxNS45LjUuNDRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDRcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRGF0ZSBvYmplY3QgZm9yIHVzZSBieVxuICAgIC8vIEpTT04uc3RyaW5naWZ5ICgxNS4xMi4zKS5cbiAgICB2YXIgZGF0ZVRvSlNPTklzU3VwcG9ydGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b0pTT04gJiZcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0pTT04oKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyAvLyBnZW5lcmljXG4gICAgICAgICAgICAgICAgICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgaWYgKCFkYXRlVG9KU09OSXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgdG9KU09OIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudCBrZXksIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcblxuICAgICAgICAgICAgLy8gMS4gIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCwgZ2l2aW5nIGl0IHRoZSB0aGlzXG4gICAgICAgICAgICAvLyB2YWx1ZSBhcyBpdHMgYXJndW1lbnQuXG4gICAgICAgICAgICAvLyAyLiBMZXQgdHYgYmUgRVMuVG9QcmltaXRpdmUoTywgaGludCBOdW1iZXIpLlxuICAgICAgICAgICAgdmFyIE8gPSAkT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHR2ID0gRVMuVG9QcmltaXRpdmUoTyk7XG4gICAgICAgICAgICAvLyAzLiBJZiB0diBpcyBhIE51bWJlciBhbmQgaXMgbm90IGZpbml0ZSwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR2ID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUodHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA0LiBMZXQgdG9JU08gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0dldF1dIGludGVybmFsIG1ldGhvZCBvZlxuICAgICAgICAgICAgLy8gTyB3aXRoIGFyZ3VtZW50IFwidG9JU09TdHJpbmdcIi5cbiAgICAgICAgICAgIHZhciB0b0lTTyA9IE8udG9JU09TdHJpbmc7XG4gICAgICAgICAgICAvLyA1LiBJZiBJc0NhbGxhYmxlKHRvSVNPKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRvSVNPKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvSVNPU3RyaW5nIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgICAgICAvLyAgdG9JU08gd2l0aCBPIGFzIHRoZSB0aGlzIHZhbHVlIGFuZCBhbiBlbXB0eSBhcmd1bWVudCBsaXN0LlxuICAgICAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoTyk7XG5cbiAgICAgICAgICAgIC8vIE5PVEUgMSBUaGUgYXJndW1lbnQgaXMgaWdub3JlZC5cblxuICAgICAgICAgICAgLy8gTk9URSAyIFRoZSB0b0pTT04gZnVuY3Rpb24gaXMgaW50ZW50aW9uYWxseSBnZW5lcmljOyBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVxdWlyZSB0aGF0IGl0cyB0aGlzIHZhbHVlIGJlIGEgRGF0ZSBvYmplY3QuIFRoZXJlZm9yZSwgaXQgY2FuIGJlXG4gICAgICAgICAgICAvLyB0cmFuc2ZlcnJlZCB0byBvdGhlciBraW5kcyBvZiBvYmplY3RzIGZvciB1c2UgYXMgYSBtZXRob2QuIEhvd2V2ZXIsXG4gICAgICAgICAgICAvLyBpdCBkb2VzIHJlcXVpcmUgdGhhdCBhbnkgc3VjaCBvYmplY3QgaGF2ZSBhIHRvSVNPU3RyaW5nIG1ldGhvZC4gQW5cbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBmcmVlIHRvIHVzZSB0aGUgYXJndW1lbnQga2V5IHRvIGZpbHRlciBpdHNcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWNhdGlvbi5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuMlxuICAgIC8vIGJhc2VkIG9uIHdvcmsgc2hhcmVkIGJ5IERhbmllbCBGcmllc2VuIChkYW50bWFuKVxuICAgIC8vIGh0dHA6Ly9naXN0LmdpdGh1Yi5jb20vMzAzMjQ5XG4gICAgdmFyIHN1cHBvcnRzRXh0ZW5kZWRZZWFycyA9IERhdGUucGFyc2UoJyswMzM2NTgtMDktMjdUMDE6NDY6NDAuMDAwWicpID09PSAxZTE1O1xuICAgIHZhciBhY2NlcHRzSW52YWxpZERhdGVzID0gIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMDQtMDRUMjQ6MDA6MDAuNTAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMS0zMVQyMzo1OTo1OS4wMDBaJykpIHx8ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTEyLTMxVDIzOjU5OjYwLjAwMFonKSk7XG4gICAgdmFyIGRvZXNOb3RQYXJzZVkyS05ld1llYXIgPSBpc05hTihEYXRlLnBhcnNlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG4gICAgaWYgKGRvZXNOb3RQYXJzZVkyS05ld1llYXIgfHwgYWNjZXB0c0ludmFsaWREYXRlcyB8fCAhc3VwcG9ydHNFeHRlbmRlZFllYXJzKSB7XG4gICAgICAgIC8vIFhYWCBnbG9iYWwgYXNzaWdubWVudCB3b24ndCB3b3JrIGluIGVtYmVkZGluZ3MgdGhhdCB1c2VcbiAgICAgICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgICAgIC8qIGdsb2JhbCBEYXRlOiB0cnVlICovXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgIHZhciBtYXhTYWZlVW5zaWduZWQzMkJpdCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gICAgICAgIHZhciBoYXNTYWZhcmlTaWduZWRJbnRCdWcgPSBpc0FjdHVhbE5hTihuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCAwLCBtYXhTYWZlVW5zaWduZWQzMkJpdCArIDEpLmdldFRpbWUoKSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICAgICAgRGF0ZSA9IChmdW5jdGlvbiAoTmF0aXZlRGF0ZSkge1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICAgICAgLy8gRGF0ZS5sZW5ndGggPT09IDdcbiAgICAgICAgICAgIHZhciBEYXRlU2hpbSA9IGZ1bmN0aW9uIERhdGUoWSwgTSwgRCwgaCwgbSwgcywgbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gbXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTYWZhcmlTaWduZWRJbnRCdWcgJiYgbGVuZ3RoID49IDcgJiYgbXMgPiBtYXhTYWZlVW5zaWduZWQzMkJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtc1RvU2hpZnQgLyAxZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbGVuZ3RoID09PSAxICYmICRTdHJpbmcoWSkgPT09IFkgPyAvLyBpc1N0cmluZyhZKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXhwbGljaXRseSBwYXNzIGl0IHRocm91Z2ggcGFyc2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZShEYXRlU2hpbS5wYXJzZShZKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYW51YWxseSBtYWtlIGNhbGxzIGRlcGVuZGluZyBvbiBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA3ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSwgc2Vjb25kcywgbWlsbGlzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA1ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDQgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAyID8gbmV3IE5hdGl2ZURhdGUoWSwgTSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDEgPyBuZXcgTmF0aXZlRGF0ZShZIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSA/ICtZIDogWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBOYXRpdmVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNQcmltaXRpdmUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBtaXh1cHMgd2l0aCB1bmZpeGVkIERhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoZGF0ZSwgeyBjb25zdHJ1Y3RvcjogRGF0ZVNoaW0gfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMTUuOS4xLjE1IERhdGUgVGltZSBTdHJpbmcgRm9ybWF0LlxuICAgICAgICAgICAgdmFyIGlzb0RhdGVFeHByZXNzaW9uID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgICAgICAgICAgICcoXFxcXGR7NH18WystXVxcXFxkezZ9KScgKyAvLyBmb3VyLWRpZ2l0IHllYXIgY2FwdHVyZSBvciBzaWduICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBtb250aCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/Oi0oXFxcXGR7Mn0pJyArIC8vIG9wdGlvbmFsIGRheSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgJ1QoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIG1pbnV0ZXMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIHNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OihcXFxcLlxcXFxkezEsfSkpPycgKyAvLyBtaWxsaXNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICAgICAnKCcgKyAvLyBjYXB0dXJlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICdafCcgKyAvLyBVVEMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhbLStdKScgKyAvLyBzaWduIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICcoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIG9mZnNldCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKScgK1xuICAgICAgICAgICAgICAgICcpPyk/KT8pPycgK1xuICAgICAgICAgICAgJyQnKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XTtcblxuICAgICAgICAgICAgdmFyIGRheUZyb21Nb250aCA9IGZ1bmN0aW9uIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gbW9udGggPiAxID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTY5ICsgdCkgLyA0KSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTAxICsgdCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE2MDEgKyB0KSAvIDQwMCkgK1xuICAgICAgICAgICAgICAgICAgICAzNjUgKiAoeWVhciAtIDE5NzApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b1VUQyA9IGZ1bmN0aW9uIHRvVVRDKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1zID0gdDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zIC8gbWF4U2FmZVVuc2lnbmVkMzJCaXQpICogbWF4U2FmZVVuc2lnbmVkMzJCaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgbXMgLT0gc1RvU2hpZnQgKiAxZTM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkTnVtYmVyKG5ldyBOYXRpdmVEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIHMsIG1zKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDb3B5IGFueSBjdXN0b20gbWV0aG9kcyBhIDNyZCBwYXJ0eSBsaWJyYXJ5IG1heSBoYXZlIGFkZGVkXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvd25zKE5hdGl2ZURhdGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgRGF0ZVNoaW1ba2V5XSA9IE5hdGl2ZURhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgXCJuYXRpdmVcIiBtZXRob2RzIGV4cGxpY2l0bHk7IHRoZXkgbWF5IGJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGVTaGltLCB7XG4gICAgICAgICAgICAgICAgbm93OiBOYXRpdmVEYXRlLm5vdyxcbiAgICAgICAgICAgICAgICBVVEM6IE5hdGl2ZURhdGUuVVRDXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIERhdGVTaGltLnByb3RvdHlwZSA9IE5hdGl2ZURhdGUucHJvdG90eXBlO1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogRGF0ZVNoaW1cbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBVcGdyYWRlIERhdGUucGFyc2UgdG8gaGFuZGxlIHNpbXBsaWZpZWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgICAgICAgICAgdmFyIHBhcnNlU2hpbSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlzb0RhdGVFeHByZXNzaW9uLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHllYXIgPSAkTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gJE51bWJlcihtYXRjaFsyXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSAkTnVtYmVyKG1hdGNoWzNdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgPSAkTnVtYmVyKG1hdGNoWzRdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlID0gJE51bWJlcihtYXRjaFs1XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZCA9ICROdW1iZXIobWF0Y2hbNl0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGguZmxvb3IoJE51bWJlcihtYXRjaFs3XSB8fCAwKSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aW1lIHpvbmUgaXMgbWlzc2VkLCBsb2NhbCBvZmZzZXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2FsVGltZSA9IEJvb2xlYW4obWF0Y2hbNF0gJiYgIW1hdGNoWzhdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25PZmZzZXQgPSBtYXRjaFs5XSA9PT0gJy0nID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlT2Zmc2V0ID0gJE51bWJlcihtYXRjaFsxMV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPSBtaW51dGUgPiAwIHx8IHNlY29uZCA+IDAgfHwgbWlsbGlzZWNvbmQgPiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyIDwgKGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA/IDI0IDogMjUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGUgPCA2MCAmJiBzZWNvbmQgPCA2MCAmJiBtaWxsaXNlY29uZCA8IDEwMDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMiAmJiBob3VyT2Zmc2V0IDwgMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA8IDYwICYmIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPCAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoICsgMSkgLSBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSArIGRheSkgKiAyNCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCAqIHNpZ25PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKiA2MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0ICsgbWludXRlICsgbWludXRlT2Zmc2V0ICogc2lnbk9mZnNldCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgICAgICApICogMTAwMCArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9VVEMocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtOC42NGUxNSA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDguNjRlMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVEYXRlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbSwgeyBwYXJzZTogcGFyc2VTaGltIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRGF0ZVNoaW07XG4gICAgICAgIH0oRGF0ZSkpO1xuICAgICAgICAvKiBnbG9iYWwgRGF0ZTogZmFsc2UgKi9cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuICAgIGlmICghRGF0ZS5ub3cpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBOdW1iZXJcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1LjEgMTUuNy40LjVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS43LjQuNVxuICAgIHZhciBoYXNUb0ZpeGVkQnVncyA9IE51bWJlclByb3RvdHlwZS50b0ZpeGVkICYmIChcbiAgICAgICgwLjAwMDA4KS50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gICAgICAoMC45KS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgICAgICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gICAgICAoMTAwMDAwMDAwMDAwMDAwMDEyOCkudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4gICAgKTtcblxuICAgIHZhciB0b0ZpeGVkSGVscGVycyA9IHtcbiAgICAgICAgYmFzZTogMWU3LFxuICAgICAgICBzaXplOiA2LFxuICAgICAgICBkYXRhOiBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShuLCBjKSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGMyID0gYztcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCB0b0ZpeGVkSGVscGVycy5zaXplKSB7XG4gICAgICAgICAgICAgICAgYzIgKz0gbiAqIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IGMyICUgdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgICAgICAgICAgICBjMiA9IE1hdGguZmxvb3IoYzIgLyB0b0ZpeGVkSGVscGVycy5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYyArPSB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBNYXRoLmZsb29yKGMgLyBuKTtcbiAgICAgICAgICAgICAgICBjID0gKGMgJSBuKSAqIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bVRvU3RyaW5nOiBmdW5jdGlvbiBudW1Ub1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCB0b0ZpeGVkSGVscGVycy5kYXRhW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gJFN0cmluZyh0b0ZpeGVkSGVscGVycy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gc3RyU2xpY2UoJzAwMDAwMDAnLCAwLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgICAgICBwb3c6IGZ1bmN0aW9uIHBvdyh4LCBuLCBhY2MpIHtcbiAgICAgICAgICAgIHJldHVybiAobiA9PT0gMCA/IGFjYyA6IChuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZzogZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHZhciB4MiA9IHg7XG4gICAgICAgICAgICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgICAgICAgICAgICAgIG4gKz0gMTI7XG4gICAgICAgICAgICAgICAgeDIgLz0gNDA5NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIHgyIC89IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdG9GaXhlZFNoaW0gPSBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIHZhciBmLCB4LCBzLCBtLCBlLCB6LCBqLCBrO1xuXG4gICAgICAgIC8vIFRlc3QgZm9yIE5hTiBhbmQgcm91bmQgZnJhY3Rpb25EaWdpdHMgZG93blxuICAgICAgICBmID0gJE51bWJlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgICAgIGYgPSBpc0FjdHVhbE5hTihmKSA/IDAgOiBNYXRoLmZsb29yKGYpO1xuXG4gICAgICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIudG9GaXhlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBkZWNpbWFscycpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9ICROdW1iZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGlzQWN0dWFsTmFOKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyB0b28gYmlnIG9yIHNtYWxsLCByZXR1cm4gdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgbnVtYmVyXG4gICAgICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkge1xuICAgICAgICAgICAgcmV0dXJuICRTdHJpbmcoeCk7XG4gICAgICAgIH1cblxuICAgICAgICBzID0gJyc7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICBzID0gJy0nO1xuICAgICAgICAgICAgeCA9IC14O1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9ICcwJztcblxuICAgICAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICAgICAgICAvLyAxZS0yMSA8IHggPCAxZTIxXG4gICAgICAgICAgICAvLyAtNzAgPCBsb2cyKHgpIDwgNzBcbiAgICAgICAgICAgIGUgPSB0b0ZpeGVkSGVscGVycy5sb2coeCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICAgICAgICB6ID0gKGUgPCAwID8geCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCAtZSwgMSkgOiB4IC8gdG9GaXhlZEhlbHBlcnMucG93KDIsIGUsIDEpKTtcbiAgICAgICAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDsgLy8gTWF0aC5wb3coMiwgNTIpO1xuICAgICAgICAgICAgZSA9IDUyIC0gZTtcblxuICAgICAgICAgICAgLy8gLTE4IDwgZSA8IDEyMlxuICAgICAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSh0b0ZpeGVkSGVscGVycy5wb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgaik7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDIpO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxIDw8ICgtZSksIDApO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAyLCAyICsgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGsgPD0gZikge1xuICAgICAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDAsIGYgLSBrICsgMikgKyBtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKG0sIDAsIGsgLSBmKSArICcuJyArIHN0clNsaWNlKG0sIGsgLSBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBzICsgbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHsgdG9GaXhlZDogdG9GaXhlZFNoaW0gfSwgaGFzVG9GaXhlZEJ1Z3MpO1xuXG4gICAgdmFyIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAxLjAudG9QcmVjaXNpb24odW5kZWZpbmVkKSA9PT0gJzEnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgdmFyIG9yaWdpbmFsVG9QcmVjaXNpb24gPSBOdW1iZXJQcm90b3R5cGUudG9QcmVjaXNpb247XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHtcbiAgICAgICAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwcmVjaXNpb24gPT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMpIDogb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMsIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICB9LCBoYXNUb1ByZWNpc2lvblVuZGVmaW5lZEJ1Zyk7XG5cbiAgICAvL1xuICAgIC8vIFN0cmluZ1xuICAgIC8vID09PT09PVxuICAgIC8vXG5cbiAgICAvLyBFUzUgMTUuNS40LjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbiAgICAvLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4gICAgLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbiAgICAvLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbiAgICAvLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbiAgICAvLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4gICAgLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbiAgICAvLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbiAgICAvLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4gICAgLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbiAgICAvLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbiAgICAvLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxuICAgIGlmIChcbiAgICAgICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAgICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbiAgICApIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IHR5cGVvZiAoLygpPz8vKS5leGVjKCcnKVsxXSA9PT0gJ3VuZGVmaW5lZCc7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICB2YXIgbWF4U2FmZTMyQml0SW50ID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuICAgICAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnZXgoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArIC8vIGluIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrIGFuZCBFUzZcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gbWF4U2FmZTMyQml0SW50XG4gICAgICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRMaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXhTYWZlMzJCaXRJbnQgOiBFUy5Ub1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X3B1c2guYXBwbHkob3V0cHV0LCBhcnJheVNsaWNlKG1hdGNoLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNwbGl0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBzcGxpdExpbWl0ID8gYXJyYXlTbGljZShvdXRwdXQsIDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcblxuICAgIC8vIFtidWdmaXgsIGNocm9tZV1cbiAgICAvLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuICAgIC8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuICAgIC8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbiAgICAvLyBlbGVtZW50cy5cbiAgICAvLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG4gICAgfSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzdHJfcmVwbGFjZSA9IFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlO1xuICAgIHZhciByZXBsYWNlUmVwb3J0c0dyb3Vwc0NvcnJlY3RseSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgICAgIHB1c2hDYWxsKGdyb3VwcywgZ3JvdXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3Vwcy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGdyb3Vwc1swXSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfSgpKTtcblxuICAgIGlmICghcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkpIHtcbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuICAgICAgICAgICAgdmFyIGhhc0NhcHR1cmluZ0dyb3VwcyA9IGlzUmVnZXgoc2VhcmNoVmFsdWUpICYmICgvXFwpWyo/XS8pLnRlc3Qoc2VhcmNoVmFsdWUuc291cmNlKTtcbiAgICAgICAgICAgIGlmICghaXNGbiB8fCAhaGFzQ2FwdHVyaW5nR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkUmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxMYXN0SW5kZXggPSBzZWFyY2hWYWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VhcmNoVmFsdWUuZXhlYyhtYXRjaCkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IG9yaWdpbmFsTGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuICAgIC8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4gICAgLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuICAgIC8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuICAgIC8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG4gICAgdmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xuICAgIHZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFN0YXJ0ID0gbWF4KHRoaXMubGVuZ3RoICsgc3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbCh0aGlzLCBub3JtYWxpemVkU3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNS40LjIwXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxuICAgIHZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAgICAgICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICtcbiAgICAgICAgJ1xcdTIwMjlcXHVGRUZGJztcbiAgICB2YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xuICAgIHZhciB3c1JlZ2V4Q2hhcnMgPSAnWycgKyB3cyArICddJztcbiAgICB2YXIgdHJpbUJlZ2luUmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKicpO1xuICAgIHZhciB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKiQnKTtcbiAgICB2YXIgaGFzVHJpbVdoaXRlc3BhY2VCdWcgPSBTdHJpbmdQcm90b3R5cGUudHJpbSAmJiAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdFxuICAgICAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXG4gICAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRTdHJpbmcodGhpcykucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbiAgICAgICAgfVxuICAgIH0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcbiAgICB2YXIgdHJpbSA9IGNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG4gICAgdmFyIGhhc0xhc3RJbmRleEJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiAnYWJj44GC44GEJy5sYXN0SW5kZXhPZign44GC44GEJywgMikgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgUyA9ICRTdHJpbmcodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoU3RyID0gJFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICAgICAgdmFyIG51bVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gJE51bWJlcihhcmd1bWVudHNbMV0pIDogTmFOO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGlzQWN0dWFsTmFOKG51bVBvcykgPyBJbmZpbml0eSA6IEVTLlRvSW50ZWdlcihudW1Qb3MpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWluKG1heChwb3MsIDApLCBTLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoTGVuID0gc2VhcmNoU3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBrID0gc3RhcnQgKyBzZWFyY2hMZW47XG4gICAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgICAgICBrID0gbWF4KDAsIGsgLSBzZWFyY2hMZW4pO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ckluZGV4T2Yoc3RyU2xpY2UoUywgaywgc3RhcnQgKyBzZWFyY2hMZW4pLCBzZWFyY2hTdHIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsgKyBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNMYXN0SW5kZXhCdWcpO1xuXG4gICAgdmFyIG9yaWdpbmFsTGFzdEluZGV4T2YgPSBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2Y7XG4gICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTGFzdEluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sIFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZi5sZW5ndGggIT09IDEpO1xuXG4gICAgLy8gRVMtNSAxNS4xLjIuMlxuICAgIC8qIGVzbGludC1kaXNhYmxlIHJhZGl4ICovXG4gICAgaWYgKHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMikge1xuICAgIC8qIGVzbGludC1lbmFibGUgcmFkaXggKi9cbiAgICAgICAgLyogZ2xvYmFsIHBhcnNlSW50OiB0cnVlICovXG4gICAgICAgIHBhcnNlSW50ID0gKGZ1bmN0aW9uIChvcmlnUGFyc2VJbnQpIHtcbiAgICAgICAgICAgIHZhciBoZXhSZWdleCA9IC9eW1xcLStdPzBbeFhdLztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cikpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0ZWRSYWRpeCA9ICROdW1iZXIocmFkaXgpIHx8IChoZXhSZWdleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ1BhcnNlSW50KHN0cmluZywgZGVmYXVsdGVkUmFkaXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUludCkpO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4zXG4gICAgaWYgKDEgLyBwYXJzZUZsb2F0KCctMCcpICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgLyogZ2xvYmFsIHBhcnNlRmxvYXQ6IHRydWUgKi9cbiAgICAgICAgcGFyc2VGbG9hdCA9IChmdW5jdGlvbiAob3JpZ1BhcnNlRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnUGFyc2VGbG9hdChpbnB1dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJTbGljZShpbnB1dFN0cmluZywgMCwgMSkgPT09ICctJyA/IC0wIDogcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUZsb2F0KSk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZyhuZXcgUmFuZ2VFcnJvcigndGVzdCcpKSAhPT0gJ1JhbmdlRXJyb3I6IHRlc3QnKSB7XG4gICAgICAgIHZhciBlcnJvclRvU3RyaW5nU2hpbSA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnRXJyb3InO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gJFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAkU3RyaW5nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgJzogJyArIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICAgICAgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZXJyb3JUb1N0cmluZ1NoaW07XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGVuc3VyZU5vbkVudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJyk7XG4gICAgICAgIGlmIChFcnJvci5wcm90b3R5cGUubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgICAgICAgIEVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICduYW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZygvYS9taWcpICE9PSAnL2EvZ2ltJykge1xuICAgICAgICB2YXIgcmVnZXhUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9ICcvJyArIHRoaXMuc291cmNlICsgJy8nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcgPSByZWdleFRvU3RyaW5nO1xuICAgIH1cbn0pKTtcbiIsIi8qIVxuICogSmF2YVNjcmlwdCBDb29raWUgdjIuMS40XG4gKiBodHRwczovL2dpdGh1Yi5jb20vanMtY29va2llL2pzLWNvb2tpZVxuICpcbiAqIENvcHlyaWdodCAyMDA2LCAyMDE1IEtsYXVzIEhhcnRsICYgRmFnbmVyIEJyYWNrXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHR2YXIgcmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyID0gZmFsc2U7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZmFjdG9yeSk7XG5cdFx0cmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyID0gdHJ1ZTtcblx0fVxuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdFx0cmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyID0gdHJ1ZTtcblx0fVxuXHRpZiAoIXJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlcikge1xuXHRcdHZhciBPbGRDb29raWVzID0gd2luZG93LkNvb2tpZXM7XG5cdFx0dmFyIGFwaSA9IHdpbmRvdy5Db29raWVzID0gZmFjdG9yeSgpO1xuXHRcdGFwaS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0d2luZG93LkNvb2tpZXMgPSBPbGRDb29raWVzO1xuXHRcdFx0cmV0dXJuIGFwaTtcblx0XHR9O1xuXHR9XG59KGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gZXh0ZW5kICgpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0cmVzdWx0W2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0IChjb252ZXJ0ZXIpIHtcblx0XHRmdW5jdGlvbiBhcGkgKGtleSwgdmFsdWUsIGF0dHJpYnV0ZXMpIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdyaXRlXG5cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzID0gZXh0ZW5kKHtcblx0XHRcdFx0XHRwYXRoOiAnLydcblx0XHRcdFx0fSwgYXBpLmRlZmF1bHRzLCBhdHRyaWJ1dGVzKTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIGF0dHJpYnV0ZXMuZXhwaXJlcyA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHR2YXIgZXhwaXJlcyA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdFx0ZXhwaXJlcy5zZXRNaWxsaXNlY29uZHMoZXhwaXJlcy5nZXRNaWxsaXNlY29uZHMoKSArIGF0dHJpYnV0ZXMuZXhwaXJlcyAqIDg2NGUrNSk7XG5cdFx0XHRcdFx0YXR0cmlidXRlcy5leHBpcmVzID0gZXhwaXJlcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlJ3JlIHVzaW5nIFwiZXhwaXJlc1wiIGJlY2F1c2UgXCJtYXgtYWdlXCIgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuXHRcdFx0XHRhdHRyaWJ1dGVzLmV4cGlyZXMgPSBhdHRyaWJ1dGVzLmV4cGlyZXMgPyBhdHRyaWJ1dGVzLmV4cGlyZXMudG9VVENTdHJpbmcoKSA6ICcnO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHRcdFx0XHRcdGlmICgvXltcXHtcXFtdLy50ZXN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZSkge31cblxuXHRcdFx0XHRpZiAoIWNvbnZlcnRlci53cml0ZSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWx1ZSkpXG5cdFx0XHRcdFx0XHQucmVwbGFjZSgvJSgyM3wyNHwyNnwyQnwzQXwzQ3wzRXwzRHwyRnwzRnw0MHw1Qnw1RHw1RXw2MHw3Qnw3RHw3QykvZywgZGVjb2RlVVJJQ29tcG9uZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbnZlcnRlci53cml0ZSh2YWx1ZSwga2V5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGtleSA9IGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoa2V5KSk7XG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC8lKDIzfDI0fDI2fDJCfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpO1xuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvW1xcKFxcKV0vZywgZXNjYXBlKTtcblxuXHRcdFx0XHR2YXIgc3RyaW5naWZpZWRBdHRyaWJ1dGVzID0gJyc7XG5cblx0XHRcdFx0Zm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyaW5naWZpZWRBdHRyaWJ1dGVzICs9ICc7ICcgKyBhdHRyaWJ1dGVOYW1lO1xuXHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyaW5naWZpZWRBdHRyaWJ1dGVzICs9ICc9JyArIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChkb2N1bWVudC5jb29raWUgPSBrZXkgKyAnPScgKyB2YWx1ZSArIHN0cmluZ2lmaWVkQXR0cmlidXRlcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlYWRcblxuXHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRvIHByZXZlbnQgdGhlIGZvciBsb29wIGluIHRoZSBmaXJzdCBwbGFjZSBhc3NpZ24gYW4gZW1wdHkgYXJyYXlcblx0XHRcdC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNvb2tpZXMgYXQgYWxsLiBBbHNvIHByZXZlbnRzIG9kZCByZXN1bHQgd2hlblxuXHRcdFx0Ly8gY2FsbGluZyBcImdldCgpXCJcblx0XHRcdHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llID8gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7ICcpIDogW107XG5cdFx0XHR2YXIgcmRlY29kZSA9IC8oJVswLTlBLVpdezJ9KSsvZztcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0Zm9yICg7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IGNvb2tpZXNbaV0uc3BsaXQoJz0nKTtcblx0XHRcdFx0dmFyIGNvb2tpZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJz0nKTtcblxuXHRcdFx0XHRpZiAoY29va2llLmNoYXJBdCgwKSA9PT0gJ1wiJykge1xuXHRcdFx0XHRcdGNvb2tpZSA9IGNvb2tpZS5zbGljZSgxLCAtMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFydHNbMF0ucmVwbGFjZShyZGVjb2RlLCBkZWNvZGVVUklDb21wb25lbnQpO1xuXHRcdFx0XHRcdGNvb2tpZSA9IGNvbnZlcnRlci5yZWFkID9cblx0XHRcdFx0XHRcdGNvbnZlcnRlci5yZWFkKGNvb2tpZSwgbmFtZSkgOiBjb252ZXJ0ZXIoY29va2llLCBuYW1lKSB8fFxuXHRcdFx0XHRcdFx0Y29va2llLnJlcGxhY2UocmRlY29kZSwgZGVjb2RlVVJJQ29tcG9uZW50KTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmpzb24pIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNvb2tpZSA9IEpTT04ucGFyc2UoY29va2llKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gbmFtZSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gY29va2llO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdFtuYW1lXSA9IGNvb2tpZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0YXBpLnNldCA9IGFwaTtcblx0XHRhcGkuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuIGFwaS5jYWxsKGFwaSwga2V5KTtcblx0XHR9O1xuXHRcdGFwaS5nZXRKU09OID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGFwaS5hcHBseSh7XG5cdFx0XHRcdGpzb246IHRydWVcblx0XHRcdH0sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cdFx0fTtcblx0XHRhcGkuZGVmYXVsdHMgPSB7fTtcblxuXHRcdGFwaS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRhcGkoa2V5LCAnJywgZXh0ZW5kKGF0dHJpYnV0ZXMsIHtcblx0XHRcdFx0ZXhwaXJlczogLTFcblx0XHRcdH0pKTtcblx0XHR9O1xuXG5cdFx0YXBpLndpdGhDb252ZXJ0ZXIgPSBpbml0O1xuXG5cdFx0cmV0dXJuIGFwaTtcblx0fVxuXG5cdHJldHVybiBpbml0KGZ1bmN0aW9uICgpIHt9KTtcbn0pKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE0LCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGJsb2NrID0ge1xuICBuZXdsaW5lOiAvXlxcbisvLFxuICBjb2RlOiAvXiggezR9W15cXG5dK1xcbiopKy8sXG4gIGZlbmNlczogbm9vcCxcbiAgaHI6IC9eKCAqWy0qX10pezMsfSAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLFxuICBucHRhYmxlOiBub29wLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqKD86XFxuK3wkKS8sXG4gIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsoXFxuKD8hZGVmKVteXFxuXSspKlxcbiopKy8sXG4gIGxpc3Q6IC9eKCAqKShidWxsKSBbXFxzXFxTXSs/KD86aHJ8ZGVmfFxcbnsyLH0oPyEgKSg/IVxcMWJ1bGwgKVxcbip8XFxzKiQpLyxcbiAgaHRtbDogL14gKig/OmNvbW1lbnQgKig/OlxcbnxcXHMqJCl8Y2xvc2VkICooPzpcXG57Mix9fFxccyokKXxjbG9zaW5nICooPzpcXG57Mix9fFxccyokKSkvLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICooPzpcXG4rfCQpLyxcbiAgdGFibGU6IG5vb3AsXG4gIHBhcmFncmFwaDogL14oKD86W15cXG5dK1xcbj8oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8dGFnfGRlZikpKylcXG4qLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZCtcXC4pLztcbmJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgW15cXG5dKig/Olxcbig/IVxcMWJ1bGwgKVteXFxuXSopKi87XG5ibG9jay5pdGVtID0gcmVwbGFjZShibG9jay5pdGVtLCAnZ20nKVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoKTtcblxuYmxvY2subGlzdCA9IHJlcGxhY2UoYmxvY2subGlzdClcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzpbLSpfXSAqKXszLH0oPzpcXFxcbit8JCkpJylcbiAgKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpXG4gICgpO1xuXG5ibG9jay5ibG9ja3F1b3RlID0gcmVwbGFjZShibG9jay5ibG9ja3F1b3RlKVxuICAoJ2RlZicsIGJsb2NrLmRlZilcbiAgKCk7XG5cbmJsb2NrLl90YWcgPSAnKD8hKD86J1xuICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZSdcbiAgKyAnfHZhcnxzYW1wfGtiZHxzdWJ8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvJ1xuICArICd8c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpXFxcXGIpXFxcXHcrKD8hOi98W15cXFxcd1xcXFxzQF0qQClcXFxcYic7XG5cbmJsb2NrLmh0bWwgPSByZXBsYWNlKGJsb2NrLmh0bWwpXG4gICgnY29tbWVudCcsIC88IS0tW1xcc1xcU10qPy0tPi8pXG4gICgnY2xvc2VkJywgLzwodGFnKVtcXHNcXFNdKz88XFwvXFwxPi8pXG4gICgnY2xvc2luZycsIC88dGFnKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LylcbiAgKC90YWcvZywgYmxvY2suX3RhZylcbiAgKCk7XG5cbmJsb2NrLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJ2hyJywgYmxvY2suaHIpXG4gICgnaGVhZGluZycsIGJsb2NrLmhlYWRpbmcpXG4gICgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgKCdibG9ja3F1b3RlJywgYmxvY2suYmxvY2txdW90ZSlcbiAgKCd0YWcnLCAnPCcgKyBibG9jay5fdGFnKVxuICAoJ2RlZicsIGJsb2NrLmRlZilcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSBtZXJnZSh7fSwgYmxvY2spO1xuXG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2suZ2ZtID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICBmZW5jZXM6IC9eICooYHszLH18fnszLH0pWyBcXC5dKihcXFMrKT8gKlxcbihbXFxzXFxTXSo/KVxccypcXDEgKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IC9eLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICsoW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS9cbn0pO1xuXG5ibG9jay5nZm0ucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnKD8hJywgJyg/ISdcbiAgICArIGJsb2NrLmdmbS5mZW5jZXMuc291cmNlLnJlcGxhY2UoJ1xcXFwxJywgJ1xcXFwyJykgKyAnfCdcbiAgICArIGJsb2NrLmxpc3Quc291cmNlLnJlcGxhY2UoJ1xcXFwxJywgJ1xcXFwzJykgKyAnfCcpXG4gICgpO1xuXG4vKipcbiAqIEdGTSArIFRhYmxlcyBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2sudGFibGVzID0gbWVyZ2Uoe30sIGJsb2NrLmdmbSwge1xuICBucHRhYmxlOiAvXiAqKFxcUy4qXFx8LiopXFxuICooWy06XSsgKlxcfFstfCA6XSopXFxuKCg/Oi4qXFx8LiooPzpcXG58JCkpKilcXG4qLyxcbiAgdGFibGU6IC9eICpcXHwoLispXFxuICpcXHwoICpbLTpdK1stfCA6XSopXFxuKCg/OiAqXFx8LiooPzpcXG58JCkpKilcXG4qL1xufSk7XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuXG5mdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW5zLmxpbmtzID0ge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLnJ1bGVzID0gYmxvY2subm9ybWFsO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YWJsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBibG9jay50YWJsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBibG9jay5nZm07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIEJsb2NrIFJ1bGVzXG4gKi9cblxuTGV4ZXIucnVsZXMgPSBibG9jaztcblxuLyoqXG4gKiBTdGF0aWMgTGV4IE1ldGhvZFxuICovXG5cbkxleGVyLmxleCA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xuICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbn07XG5cbi8qKlxuICogUHJlcHJvY2Vzc2luZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbihzcmMpIHtcbiAgc3JjID0gc3JjXG4gICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG4gICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKVxuICAgIC5yZXBsYWNlKC9cXHUyNDI0L2csICdcXG4nKTtcblxuICByZXR1cm4gdGhpcy50b2tlbihzcmMsIHRydWUpO1xufTtcblxuLyoqXG4gKiBMZXhpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbihzcmMsIHRvcCwgYnEpIHtcbiAgdmFyIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJylcbiAgICAsIG5leHRcbiAgICAsIGxvb3NlXG4gICAgLCBjYXBcbiAgICAsIGJ1bGxcbiAgICAsIGJcbiAgICAsIGl0ZW1cbiAgICAsIHNwYWNlXG4gICAgLCBpXG4gICAgLCBsO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBuZXdsaW5lXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubmV3bGluZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IGNhcC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgIDogY2FwXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZlbmNlcyAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmZlbmNlcy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IGNhcFszXSB8fCAnJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIG5vIGxlYWRpbmcgcGlwZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMubnB0YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXS5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxoZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMl0gPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oci5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hyJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBibG9ja3F1b3RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYmxvY2txdW90ZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9zdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG5cbiAgICAgIC8vIFBhc3MgYHRvcGAgdG8ga2VlcCB0aGUgY3VycmVudFxuICAgICAgLy8gXCJ0b3BsZXZlbFwiIHN0YXRlLiBUaGlzIGlzIGV4YWN0bHlcbiAgICAgIC8vIGhvdyBtYXJrZG93bi5wbCB3b3Jrcy5cbiAgICAgIHRoaXMudG9rZW4oY2FwLCB0b3AsIHRydWUpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpc3RcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saXN0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGJ1bGwgPSBjYXBbMl07XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9zdGFydCcsXG4gICAgICAgIG9yZGVyZWQ6IGJ1bGwubGVuZ3RoID4gMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuICAgICAgY2FwID0gY2FwWzBdLm1hdGNoKHRoaXMucnVsZXMuaXRlbSk7XG5cbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICsvLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKVxuICAgICAgICAgICAgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBiID0gYmxvY2suYnVsbGV0LmV4ZWMoY2FwW2kgKyAxXSlbMF07XG4gICAgICAgICAgaWYgKGJ1bGwgIT09IGIgJiYgIShidWxsLmxlbmd0aCA+IDEgJiYgYi5sZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgc3JjID0gY2FwLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKSArIHNyYztcbiAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGxvb3NlXG4gICAgICAgICAgICA/ICdsb29zZV9pdGVtX3N0YXJ0J1xuICAgICAgICAgICAgOiAnbGlzdF9pdGVtX3N0YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICB0aGlzLnRva2VuKGl0ZW0sIGZhbHNlLCBicSk7XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2xpc3RfaXRlbV9lbmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3RfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGh0bWxcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5odG1sLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICdwYXJhZ3JhcGgnXG4gICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgIHByZTogIXRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWZcbiAgICBpZiAoKCFicSAmJiB0b3ApICYmIChjYXAgPSB0aGlzLnJ1bGVzLmRlZi5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMubGlua3NbY2FwWzFdLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMudGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvKD86ICpcXHwgKik/XFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV1cbiAgICAgICAgICAucmVwbGFjZSgvXiAqXFx8ICp8ICpcXHwgKiQvZywgJycpXG4gICAgICAgICAgLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnBhcmFncmFwaC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIC8vIFRvcC1sZXZlbCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZS5cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFtcXFxcYCp7fVxcW1xcXSgpIytcXC0uIV8+XSkvLFxuICBhdXRvbGluazogL148KFteID5dKyhAfDpcXC8pW14gPl0rKT4vLFxuICB1cmw6IG5vb3AsXG4gIHRhZzogL148IS0tW1xcc1xcU10qPy0tPnxePFxcLz9cXHcrKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LyxcbiAgbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFwoaHJlZlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsoKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV0pKilcXF0vLFxuICBzdHJvbmc6IC9eX18oW1xcc1xcU10rPylfXyg/IV8pfF5cXCpcXCooW1xcc1xcU10rPylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXFxiXygoPzpbXl9dfF9fKSs/KV9cXGJ8XlxcKigoPzpcXCpcXCp8W1xcc1xcU10pKz8pXFwqKD8hXFwqKS8sXG4gIGNvZGU6IC9eKGArKVxccyooW1xcc1xcU10qP1teYF0pXFxzKlxcMSg/IWApLyxcbiAgYnI6IC9eIHsyLH1cXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3AsXG4gIHRleHQ6IC9eW1xcc1xcU10rPyg/PVtcXFxcPCFcXFtfKmBdfCB7Mix9XFxufCQpL1xufTtcblxuaW5saW5lLl9pbnNpZGUgPSAvKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV18XFxdKD89W15cXFtdKlxcXSkpKi87XG5pbmxpbmUuX2hyZWYgPSAvXFxzKjw/KFtcXHNcXFNdKj8pPj8oPzpcXHMrWydcIl0oW1xcc1xcU10qPylbJ1wiXSk/XFxzKi87XG5cbmlubGluZS5saW5rID0gcmVwbGFjZShpbmxpbmUubGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCdocmVmJywgaW5saW5lLl9ocmVmKVxuICAoKTtcblxuaW5saW5lLnJlZmxpbmsgPSByZXBsYWNlKGlubGluZS5yZWZsaW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUubm9ybWFsID0gbWVyZ2Uoe30sIGlubGluZSk7XG5cbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUucGVkYW50aWMgPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBzdHJvbmc6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKXxeXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKikvXG59KTtcblxuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuZ2ZtID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgZXNjYXBlOiByZXBsYWNlKGlubGluZS5lc2NhcGUpKCddKScsICd+fF0pJykoKSxcbiAgdXJsOiAvXihodHRwcz86XFwvXFwvW15cXHM8XStbXjwuLDo7XCInKVxcXVxcc10pLyxcbiAgZGVsOiAvXn5+KD89XFxTKShbXFxzXFxTXSo/XFxTKX5+LyxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUudGV4dClcbiAgICAoJ118JywgJ35dfCcpXG4gICAgKCd8JywgJ3xodHRwcz86Ly98JylcbiAgICAoKVxufSk7XG5cbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0gbWVyZ2Uoe30sIGlubGluZS5nZm0sIHtcbiAgYnI6IHJlcGxhY2UoaW5saW5lLmJyKSgnezIsfScsICcqJykoKSxcbiAgdGV4dDogcmVwbGFjZShpbmxpbmUuZ2ZtLnRleHQpKCd7Mix9JywgJyonKSgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUgTGV4ZXIgJiBDb21waWxlclxuICovXG5cbmZ1bmN0aW9uIElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLmxpbmtzID0gbGlua3M7XG4gIHRoaXMucnVsZXMgPSBpbmxpbmUubm9ybWFsO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmICghdGhpcy5saW5rcykge1xuICAgIHRocm93IG5ld1xuICAgICAgRXJyb3IoJ1Rva2VucyBhcnJheSByZXF1aXJlcyBhIGBsaW5rc2AgcHJvcGVydHkuJyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmJyZWFrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5nZm07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBpbmxpbmUucGVkYW50aWM7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgSW5saW5lIFJ1bGVzXG4gKi9cblxuSW5saW5lTGV4ZXIucnVsZXMgPSBpbmxpbmU7XG5cbi8qKlxuICogU3RhdGljIExleGluZy9Db21waWxpbmcgTWV0aG9kXG4gKi9cblxuSW5saW5lTGV4ZXIub3V0cHV0ID0gZnVuY3Rpb24oc3JjLCBsaW5rcywgb3B0aW9ucykge1xuICB2YXIgaW5saW5lID0gbmV3IElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIGlubGluZS5vdXRwdXQoc3JjKTtcbn07XG5cbi8qKlxuICogTGV4aW5nL0NvbXBpbGluZ1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbihzcmMpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsaW5rXG4gICAgLCB0ZXh0XG4gICAgLCBocmVmXG4gICAgLCBjYXA7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIGVzY2FwZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVzY2FwZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gY2FwWzFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYXV0b2xpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5hdXRvbGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGNhcFsxXS5jaGFyQXQoNikgPT09ICc6J1xuICAgICAgICAgID8gdGhpcy5tYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICA6IHRoaXMubWFuZ2xlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0aGlzLm1hbmdsZSgnbWFpbHRvOicpICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKCF0aGlzLmluTGluayAmJiAoY2FwID0gdGhpcy5ydWxlcy51cmwuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRhZy5leGVjKHNyYykpIHtcbiAgICAgIGlmICghdGhpcy5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSlcbiAgICAgICAgICA6IGVzY2FwZShjYXBbMF0pXG4gICAgICAgIDogY2FwWzBdXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5yZWZsaW5rLmV4ZWMoc3JjKSlcbiAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSB0aGlzLmxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmsgfHwgIWxpbmsuaHJlZikge1xuICAgICAgICBvdXQgKz0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgc3JjID0gY2FwWzBdLnN1YnN0cmluZygxKSArIHNyYztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwgbGluayk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc3Ryb25nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuc3Ryb25nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnN0cm9uZyh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBlbVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVtLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmVtKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGVzcGFuKGVzY2FwZShjYXBbMl0sIHRydWUpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYnIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYnIoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlbCAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmRlbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5kZWwodGhpcy5vdXRwdXQoY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50ZXh0KGVzY2FwZSh0aGlzLnNtYXJ0eXBhbnRzKGNhcFswXSkpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgTGlua1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXRMaW5rID0gZnVuY3Rpb24oY2FwLCBsaW5rKSB7XG4gIHZhciBocmVmID0gZXNjYXBlKGxpbmsuaHJlZilcbiAgICAsIHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG5cbiAgcmV0dXJuIGNhcFswXS5jaGFyQXQoMCkgIT09ICchJ1xuICAgID8gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIHRpdGxlLCB0aGlzLm91dHB1dChjYXBbMV0pKVxuICAgIDogdGhpcy5yZW5kZXJlci5pbWFnZShocmVmLCB0aXRsZSwgZXNjYXBlKGNhcFsxXSkpO1xufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzKSByZXR1cm4gdGV4dDtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAvLyBlbi1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTMnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMubWFuZ2xlKSByZXR1cm4gdGV4dDtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsID0gdGV4dC5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBjaDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uKGNvZGUsIGxhbmcsIGVzY2FwZWQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBvdXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFsYW5nKSB7XG4gICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgKyAnXFxuPC9jb2RlPjwvcHJlPic7XG4gIH1cblxuICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeFxuICAgICsgZXNjYXBlKGxhbmcsIHRydWUpXG4gICAgKyAnXCI+J1xuICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICsgJ1xcbjwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gaHRtbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odGV4dCwgbGV2ZWwsIHJhdykge1xuICByZXR1cm4gJzxoJ1xuICAgICsgbGV2ZWxcbiAgICArICcgaWQ9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4XG4gICAgKyByYXcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXlxcd10rL2csICctJylcbiAgICArICdcIj4nXG4gICAgKyB0ZXh0XG4gICAgKyAnPC9oJ1xuICAgICsgbGV2ZWxcbiAgICArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ociA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oYm9keSwgb3JkZXJlZCkge1xuICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgcmV0dXJuICc8JyArIHR5cGUgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdGl0ZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5wYXJhZ3JhcGggPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbihoZWFkZXIsIGJvZHkpIHtcbiAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICsgJzx0aGVhZD5cXG4nXG4gICAgKyBoZWFkZXJcbiAgICArICc8L3RoZWFkPlxcbidcbiAgICArICc8dGJvZHk+XFxuJ1xuICAgICsgYm9keVxuICAgICsgJzwvdGJvZHk+XFxuJ1xuICAgICsgJzwvdGFibGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZXJvdyA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlY2VsbCA9IGZ1bmN0aW9uKGNvbnRlbnQsIGZsYWdzKSB7XG4gIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gIHZhciB0YWcgPSBmbGFncy5hbGlnblxuICAgID8gJzwnICsgdHlwZSArICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyBmbGFncy5hbGlnbiArICdcIj4nXG4gICAgOiAnPCcgKyB0eXBlICsgJz4nO1xuICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuUmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2Rlc3BhbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5iciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAucmVwbGFjZSgvW15cXHc6XS9nLCAnJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbiAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGhyZWYgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICB2YXIgb3V0ID0gJzxpbWcgc3JjPVwiJyArIGhyZWYgKyAnXCIgYWx0PVwiJyArIHRleHQgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQ7XG59O1xuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2VuID0gbnVsbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbn1cblxuLyoqXG4gKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gKi9cblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zLCByZW5kZXJlcikge1xuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zLCByZW5kZXJlcik7XG4gIHJldHVybiBwYXJzZXIucGFyc2Uoc3JjKTtcbn07XG5cbi8qKlxuICogUGFyc2UgTG9vcFxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzcmMpIHtcbiAgdGhpcy5pbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIoc3JjLmxpbmtzLCB0aGlzLm9wdGlvbnMsIHRoaXMucmVuZGVyZXIpO1xuICB0aGlzLnRva2VucyA9IHNyYy5yZXZlcnNlKCk7XG5cbiAgdmFyIG91dCA9ICcnO1xuICB3aGlsZSAodGhpcy5uZXh0KCkpIHtcbiAgICBvdXQgKz0gdGhpcy50b2soKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW4gPSB0aGlzLnRva2Vucy5wb3AoKTtcbn07XG5cbi8qKlxuICogUHJldmlldyBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSB8fCAwO1xufTtcblxuLyoqXG4gKiBQYXJzZSBUZXh0IFRva2Vuc1xuICovXG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBib2R5ID0gdGhpcy50b2tlbi50ZXh0O1xuXG4gIHdoaWxlICh0aGlzLnBlZWsoKS50eXBlID09PSAndGV4dCcpIHtcbiAgICBib2R5ICs9ICdcXG4nICsgdGhpcy5uZXh0KCkudGV4dDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmlubGluZS5vdXRwdXQoYm9keSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIEN1cnJlbnQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnRvayA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMudG9rZW4udHlwZSkge1xuICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjYXNlICdocic6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgfVxuICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSxcbiAgICAgICAgdGhpcy50b2tlbi5kZXB0aCxcbiAgICAgICAgdGhpcy50b2tlbi50ZXh0KTtcbiAgICB9XG4gICAgY2FzZSAnY29kZSc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvZGUodGhpcy50b2tlbi50ZXh0LFxuICAgICAgICB0aGlzLnRva2VuLmxhbmcsXG4gICAgICAgIHRoaXMudG9rZW4uZXNjYXBlZCk7XG4gICAgfVxuICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgdmFyIGhlYWRlciA9ICcnXG4gICAgICAgICwgYm9keSA9ICcnXG4gICAgICAgICwgaVxuICAgICAgICAsIHJvd1xuICAgICAgICAsIGNlbGxcbiAgICAgICAgLCBmbGFnc1xuICAgICAgICAsIGo7XG5cbiAgICAgIC8vIGhlYWRlclxuICAgICAgY2VsbCA9ICcnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZsYWdzID0geyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH07XG4gICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4uaGVhZGVyW2ldKSxcbiAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdyA9IHRoaXMudG9rZW4uY2VsbHNbaV07XG5cbiAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dChyb3dbal0pLFxuICAgICAgICAgICAgeyBoZWFkZXI6IGZhbHNlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltqXSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2Jsb2NrcXVvdGVfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2Jsb2NrcXVvdGVfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3Rfc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnXG4gICAgICAgICwgb3JkZXJlZCA9IHRoaXMudG9rZW4ub3JkZXJlZDtcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2tlbi50eXBlID09PSAndGV4dCdcbiAgICAgICAgICA/IHRoaXMucGFyc2VUZXh0KClcbiAgICAgICAgICA6IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsb29zZV9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdodG1sJzoge1xuICAgICAgdmFyIGh0bWwgPSAhdGhpcy50b2tlbi5wcmUgJiYgIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICA/IHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpXG4gICAgICAgIDogdGhpcy50b2tlbi50ZXh0O1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHRtbChodG1sKTtcbiAgICB9XG4gICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSAndGV4dCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlVGV4dCgpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgcmV0dXJuIGh0bWxcbiAgICAucmVwbGFjZSghZW5jb2RlID8gLyYoPyEjP1xcdys7KS9nIDogLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuXHQvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXMgXG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9nLCBmdW5jdGlvbihfLCBuKSB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2U7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGYobmFtZSwgdmFsKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvKF58W15cXFtdKVxcXi9nLCAnJDEnKTtcbiAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5ub29wLmV4ZWMgPSBub29wO1xuXG5mdW5jdGlvbiBtZXJnZShvYmopIHtcbiAgdmFyIGkgPSAxXG4gICAgLCB0YXJnZXRcbiAgICAsIGtleTtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrIHx8IHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcblxuICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0XG4gICAgICAsIHRva2Vuc1xuICAgICAgLCBwZW5kaW5nXG4gICAgICAsIGkgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgfVxuXG4gICAgcGVuZGluZyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cblxuICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgcmV0dXJuIGVyclxuICAgICAgICA/IGNhbGxiYWNrKGVycilcbiAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgIH07XG5cbiAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgIGlmICghcGVuZGluZykgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZvciAoOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24oZXJyLCBjb2RlKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICBpZiAoY29kZSA9PSBudWxsIHx8IGNvZGUgPT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAtLXBlbmRpbmcgfHwgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKHRva2Vuc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdCkgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKExleGVyLmxleChzcmMsIG9wdCksIG9wdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWQuJztcbiAgICBpZiAoKG9wdCB8fCBtYXJrZWQuZGVmYXVsdHMpLnNpbGVudCkge1xuICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmRlZmF1bHRzID0ge1xuICBnZm06IHRydWUsXG4gIHRhYmxlczogdHJ1ZSxcbiAgYnJlYWtzOiBmYWxzZSxcbiAgcGVkYW50aWM6IGZhbHNlLFxuICBzYW5pdGl6ZTogZmFsc2UsXG4gIHNhbml0aXplcjogbnVsbCxcbiAgbWFuZ2xlOiB0cnVlLFxuICBzbWFydExpc3RzOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbiAgaGlnaGxpZ2h0OiBudWxsLFxuICBsYW5nUHJlZml4OiAnbGFuZy0nLFxuICBzbWFydHlwYW50czogZmFsc2UsXG4gIGhlYWRlclByZWZpeDogJycsXG4gIHJlbmRlcmVyOiBuZXcgUmVuZGVyZXIsXG4gIHhodG1sOiBmYWxzZVxufTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IFBhcnNlci5wYXJzZTtcblxubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5cbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xuXG5tYXJrZWQuSW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlcjtcbm1hcmtlZC5pbmxpbmVMZXhlciA9IElubGluZUxleGVyLm91dHB1dDtcblxubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbWFya2VkO1xufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFya2VkOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMubWFya2VkID0gbWFya2VkO1xufVxuXG59KS5jYWxsKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpO1xufSgpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5dFlYSnJaV1F2YkdsaUwyMWhjbXRsWkM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUl2S2lwY2JpQXFJRzFoY210bFpDQXRJR0VnYldGeWEyUnZkMjRnY0dGeWMyVnlYRzRnS2lCRGIzQjVjbWxuYUhRZ0tHTXBJREl3TVRFdE1qQXhOQ3dnUTJoeWFYTjBiM0JvWlhJZ1NtVm1abkpsZVM0Z0tFMUpWQ0JNYVdObGJuTmxaQ2xjYmlBcUlHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOWphR3BxTDIxaGNtdGxaRnh1SUNvdlhHNWNianNvWm5WdVkzUnBiMjRvS1NCN1hHNWNiaThxS2x4dUlDb2dRbXh2WTJzdFRHVjJaV3dnUjNKaGJXMWhjbHh1SUNvdlhHNWNiblpoY2lCaWJHOWpheUE5SUh0Y2JpQWdibVYzYkdsdVpUb2dMMTVjWEc0ckx5eGNiaUFnWTI5a1pUb2dMMTRvSUhzMGZWdGVYRnh1WFN0Y1hHNHFLU3N2TEZ4dUlDQm1aVzVqWlhNNklHNXZiM0FzWEc0Z0lHaHlPaUF2WGlnZ0tsc3RLbDlkS1hzekxIMGdLaWcvT2x4Y2JpdDhKQ2t2TEZ4dUlDQm9aV0ZrYVc1bk9pQXZYaUFxS0NON01TdzJmU2tnS2loYlhseGNibDByUHlrZ0tpTXFJQ29vUHpwY1hHNHJmQ1FwTHl4Y2JpQWdibkIwWVdKc1pUb2dibTl2Y0N4Y2JpQWdiR2hsWVdScGJtYzZJQzllS0Z0ZVhGeHVYU3NwWEZ4dUlDb29QWHd0S1hzeUxIMGdLaWcvT2x4Y2JpdDhKQ2t2TEZ4dUlDQmliRzlqYTNGMWIzUmxPaUF2WGlnZ0tqNWJYbHhjYmwwcktGeGNiaWcvSVdSbFppbGJYbHhjYmwwcktTcGNYRzRxS1NzdkxGeHVJQ0JzYVhOME9pQXZYaWdnS2lrb1luVnNiQ2tnVzF4Y2MxeGNVMTByUHlnL09taHlmR1JsWm54Y1hHNTdNaXg5S0Q4aElDa29QeUZjWERGaWRXeHNJQ2xjWEc0cWZGeGNjeW9rS1M4c1hHNGdJR2gwYld3NklDOWVJQ29vUHpwamIyMXRaVzUwSUNvb1B6cGNYRzU4WEZ4ektpUXBmR05zYjNObFpDQXFLRDg2WEZ4dWV6SXNmWHhjWEhNcUpDbDhZMnh2YzJsdVp5QXFLRDg2WEZ4dWV6SXNmWHhjWEhNcUpDa3BMeXhjYmlBZ1pHVm1PaUF2WGlBcVhGeGJLRnRlWEZ4ZFhTc3BYRnhkT2lBcVBEOG9XMTVjWEhNK1hTc3BQajhvUHpvZ0sxdGNJaWhkS0Z0ZVhGeHVYU3NwVzF3aUtWMHBQeUFxS0Q4NlhGeHVLM3drS1M4c1hHNGdJSFJoWW14bE9pQnViMjl3TEZ4dUlDQndZWEpoWjNKaGNHZzZJQzllS0NnL09sdGVYRnh1WFN0Y1hHNC9LRDhoYUhKOGFHVmhaR2x1WjN4c2FHVmhaR2x1WjN4aWJHOWphM0YxYjNSbGZIUmhaM3hrWldZcEtTc3BYRnh1S2k4c1hHNGdJSFJsZUhRNklDOWVXMTVjWEc1ZEt5OWNibjA3WEc1Y2JtSnNiMk5yTG1KMWJHeGxkQ0E5SUM4b1B6cGJLaXN0WFh4Y1hHUXJYRnd1S1M4N1hHNWliRzlqYXk1cGRHVnRJRDBnTDE0b0lDb3BLR0oxYkd3cElGdGVYRnh1WFNvb1B6cGNYRzRvUHlGY1hERmlkV3hzSUNsYlhseGNibDBxS1Nvdk8xeHVZbXh2WTJzdWFYUmxiU0E5SUhKbGNHeGhZMlVvWW14dlkyc3VhWFJsYlN3Z0oyZHRKeWxjYmlBZ0tDOWlkV3hzTDJjc0lHSnNiMk5yTG1KMWJHeGxkQ2xjYmlBZ0tDazdYRzVjYm1Kc2IyTnJMbXhwYzNRZ1BTQnlaWEJzWVdObEtHSnNiMk5yTG14cGMzUXBYRzRnSUNndlluVnNiQzluTENCaWJHOWpheTVpZFd4c1pYUXBYRzRnSUNnbmFISW5MQ0FuWEZ4Y1hHNHJLRDg5WEZ4Y1hERS9LRDg2V3kwcVgxMGdLaWw3TXl4OUtEODZYRnhjWEc0cmZDUXBLU2NwWEc0Z0lDZ25aR1ZtSnl3Z0oxeGNYRnh1S3lnL1BTY2dLeUJpYkc5amF5NWtaV1l1YzI5MWNtTmxJQ3NnSnlrbktWeHVJQ0FvS1R0Y2JseHVZbXh2WTJzdVlteHZZMnR4ZFc5MFpTQTlJSEpsY0d4aFkyVW9ZbXh2WTJzdVlteHZZMnR4ZFc5MFpTbGNiaUFnS0Nka1pXWW5MQ0JpYkc5amF5NWtaV1lwWEc0Z0lDZ3BPMXh1WEc1aWJHOWpheTVmZEdGbklEMGdKeWcvSVNnL09pZGNiaUFnS3lBbllYeGxiWHh6ZEhKdmJtZDhjMjFoYkd4OGMzeGphWFJsZkhGOFpHWnVmR0ZpWW5KOFpHRjBZWHgwYVcxbGZHTnZaR1VuWEc0Z0lDc2dKM3gyWVhKOGMyRnRjSHhyWW1SOGMzVmlmSE4xY0h4cGZHSjhkWHh0WVhKcmZISjFZbmw4Y25SOGNuQjhZbVJwZkdKa2J5ZGNiaUFnS3lBbmZITndZVzU4WW5KOGQySnlmR2x1YzN4a1pXeDhhVzFuS1Z4Y1hGeGlLVnhjWEZ4M0t5Zy9JVG92ZkZ0ZVhGeGNYSGRjWEZ4Y2MwQmRLa0FwWEZ4Y1hHSW5PMXh1WEc1aWJHOWpheTVvZEcxc0lEMGdjbVZ3YkdGalpTaGliRzlqYXk1b2RHMXNLVnh1SUNBb0oyTnZiVzFsYm5RbkxDQXZQQ0V0TFZ0Y1hITmNYRk5kS2o4dExUNHZLVnh1SUNBb0oyTnNiM05sWkNjc0lDODhLSFJoWnlsYlhGeHpYRnhUWFNzL1BGeGNMMXhjTVQ0dktWeHVJQ0FvSjJOc2IzTnBibWNuTENBdlBIUmhaeWcvT2x3aVcxNWNJbDBxWENKOEoxdGVKMTBxSjN4YlhpZGNJajVkS1NvL1BpOHBYRzRnSUNndmRHRm5MMmNzSUdKc2IyTnJMbDkwWVdjcFhHNGdJQ2dwTzF4dVhHNWliRzlqYXk1d1lYSmhaM0poY0dnZ1BTQnlaWEJzWVdObEtHSnNiMk5yTG5CaGNtRm5jbUZ3YUNsY2JpQWdLQ2RvY2ljc0lHSnNiMk5yTG1oeUtWeHVJQ0FvSjJobFlXUnBibWNuTENCaWJHOWpheTVvWldGa2FXNW5LVnh1SUNBb0oyeG9aV0ZrYVc1bkp5d2dZbXh2WTJzdWJHaGxZV1JwYm1jcFhHNGdJQ2duWW14dlkydHhkVzkwWlNjc0lHSnNiMk5yTG1Kc2IyTnJjWFZ2ZEdVcFhHNGdJQ2duZEdGbkp5d2dKenduSUNzZ1lteHZZMnN1WDNSaFp5bGNiaUFnS0Nka1pXWW5MQ0JpYkc5amF5NWtaV1lwWEc0Z0lDZ3BPMXh1WEc0dktpcGNiaUFxSUU1dmNtMWhiQ0JDYkc5amF5QkhjbUZ0YldGeVhHNGdLaTljYmx4dVlteHZZMnN1Ym05eWJXRnNJRDBnYldWeVoyVW9lMzBzSUdKc2IyTnJLVHRjYmx4dUx5b3FYRzRnS2lCSFJrMGdRbXh2WTJzZ1IzSmhiVzFoY2x4dUlDb3ZYRzVjYm1Kc2IyTnJMbWRtYlNBOUlHMWxjbWRsS0h0OUxDQmliRzlqYXk1dWIzSnRZV3dzSUh0Y2JpQWdabVZ1WTJWek9pQXZYaUFxS0dCN015eDlmSDU3TXl4OUtWc2dYRnd1WFNvb1hGeFRLeWsvSUNwY1hHNG9XMXhjYzF4Y1UxMHFQeWxjWEhNcVhGd3hJQ29vUHpwY1hHNHJmQ1FwTHl4Y2JpQWdjR0Z5WVdkeVlYQm9PaUF2WGk4c1hHNGdJR2hsWVdScGJtYzZJQzllSUNvb0kzc3hMRFo5S1NBcktGdGVYRnh1WFNzL0tTQXFJeW9nS2lnL09seGNiaXQ4SkNrdlhHNTlLVHRjYmx4dVlteHZZMnN1WjJadExuQmhjbUZuY21Gd2FDQTlJSEpsY0d4aFkyVW9ZbXh2WTJzdWNHRnlZV2R5WVhCb0tWeHVJQ0FvSnlnL0lTY3NJQ2NvUHlFblhHNGdJQ0FnS3lCaWJHOWpheTVuWm0wdVptVnVZMlZ6TG5OdmRYSmpaUzV5WlhCc1lXTmxLQ2RjWEZ4Y01TY3NJQ2RjWEZ4Y01pY3BJQ3NnSjN3blhHNGdJQ0FnS3lCaWJHOWpheTVzYVhOMExuTnZkWEpqWlM1eVpYQnNZV05sS0NkY1hGeGNNU2NzSUNkY1hGeGNNeWNwSUNzZ0ozd25LVnh1SUNBb0tUdGNibHh1THlvcVhHNGdLaUJIUmswZ0t5QlVZV0pzWlhNZ1FteHZZMnNnUjNKaGJXMWhjbHh1SUNvdlhHNWNibUpzYjJOckxuUmhZbXhsY3lBOUlHMWxjbWRsS0h0OUxDQmliRzlqYXk1blptMHNJSHRjYmlBZ2JuQjBZV0pzWlRvZ0wxNGdLaWhjWEZNdUtseGNmQzRxS1Z4Y2JpQXFLRnN0T2wwcklDcGNYSHhiTFh3Z09sMHFLVnhjYmlnb1B6b3VLbHhjZkM0cUtEODZYRnh1ZkNRcEtTb3BYRnh1S2k4c1hHNGdJSFJoWW14bE9pQXZYaUFxWEZ4OEtDNHJLVnhjYmlBcVhGeDhLQ0FxV3kwNlhTdGJMWHdnT2wwcUtWeGNiaWdvUHpvZ0tseGNmQzRxS0Q4NlhGeHVmQ1FwS1NvcFhGeHVLaTljYm4wcE8xeHVYRzR2S2lwY2JpQXFJRUpzYjJOcklFeGxlR1Z5WEc0Z0tpOWNibHh1Wm5WdVkzUnBiMjRnVEdWNFpYSW9iM0IwYVc5dWN5a2dlMXh1SUNCMGFHbHpMblJ2YTJWdWN5QTlJRnRkTzF4dUlDQjBhR2x6TG5SdmEyVnVjeTVzYVc1cmN5QTlJSHQ5TzF4dUlDQjBhR2x6TG05d2RHbHZibk1nUFNCdmNIUnBiMjV6SUh4OElHMWhjbXRsWkM1a1pXWmhkV3gwY3p0Y2JpQWdkR2hwY3k1eWRXeGxjeUE5SUdKc2IyTnJMbTV2Y20xaGJEdGNibHh1SUNCcFppQW9kR2hwY3k1dmNIUnBiMjV6TG1kbWJTa2dlMXh1SUNBZ0lHbG1JQ2gwYUdsekxtOXdkR2x2Ym5NdWRHRmliR1Z6S1NCN1hHNGdJQ0FnSUNCMGFHbHpMbkoxYkdWeklEMGdZbXh2WTJzdWRHRmliR1Z6TzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQjBhR2x6TG5KMWJHVnpJRDBnWW14dlkyc3VaMlp0TzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUVWNGNHOXpaU0JDYkc5amF5QlNkV3hsYzF4dUlDb3ZYRzVjYmt4bGVHVnlMbkoxYkdWeklEMGdZbXh2WTJzN1hHNWNiaThxS2x4dUlDb2dVM1JoZEdsaklFeGxlQ0JOWlhSb2IyUmNiaUFxTDF4dVhHNU1aWGhsY2k1c1pYZ2dQU0JtZFc1amRHbHZiaWh6Y21Nc0lHOXdkR2x2Ym5NcElIdGNiaUFnZG1GeUlHeGxlR1Z5SUQwZ2JtVjNJRXhsZUdWeUtHOXdkR2x2Ym5NcE8xeHVJQ0J5WlhSMWNtNGdiR1Y0WlhJdWJHVjRLSE55WXlrN1hHNTlPMXh1WEc0dktpcGNiaUFxSUZCeVpYQnliMk5sYzNOcGJtZGNiaUFxTDF4dVhHNU1aWGhsY2k1d2NtOTBiM1I1Y0dVdWJHVjRJRDBnWm5WdVkzUnBiMjRvYzNKaktTQjdYRzRnSUhOeVl5QTlJSE55WTF4dUlDQWdJQzV5WlhCc1lXTmxLQzljWEhKY1hHNThYRnh5TDJjc0lDZGNYRzRuS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzljWEhRdlp5d2dKeUFnSUNBbktWeHVJQ0FnSUM1eVpYQnNZV05sS0M5Y1hIVXdNR0V3TDJjc0lDY2dKeWxjYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZYRngxTWpReU5DOW5MQ0FuWEZ4dUp5azdYRzVjYmlBZ2NtVjBkWEp1SUhSb2FYTXVkRzlyWlc0b2MzSmpMQ0IwY25WbEtUdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1RHVjRhVzVuWEc0Z0tpOWNibHh1VEdWNFpYSXVjSEp2ZEc5MGVYQmxMblJ2YTJWdUlEMGdablZ1WTNScGIyNG9jM0pqTENCMGIzQXNJR0p4S1NCN1hHNGdJSFpoY2lCemNtTWdQU0J6Y21NdWNtVndiR0ZqWlNndlhpQXJKQzluYlN3Z0p5Y3BYRzRnSUNBZ0xDQnVaWGgwWEc0Z0lDQWdMQ0JzYjI5elpWeHVJQ0FnSUN3Z1kyRndYRzRnSUNBZ0xDQmlkV3hzWEc0Z0lDQWdMQ0JpWEc0Z0lDQWdMQ0JwZEdWdFhHNGdJQ0FnTENCemNHRmpaVnh1SUNBZ0lDd2dhVnh1SUNBZ0lDd2diRHRjYmx4dUlDQjNhR2xzWlNBb2MzSmpLU0I3WEc0Z0lDQWdMeThnYm1WM2JHbHVaVnh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbTVsZDJ4cGJtVXVaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdhV1lnS0dOaGNGc3dYUzVzWlc1bmRHZ2dQaUF4S1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZEc5clpXNXpMbkIxYzJnb2UxeHVJQ0FnSUNBZ0lDQWdJSFI1Y0dVNklDZHpjR0ZqWlNkY2JpQWdJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdZMjlrWlZ4dUlDQWdJR2xtSUNoallYQWdQU0IwYUdsekxuSjFiR1Z6TG1OdlpHVXVaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdZMkZ3SUQwZ1kyRndXekJkTG5KbGNHeGhZMlVvTDE0Z2V6UjlMMmR0TENBbkp5azdYRzRnSUNBZ0lDQjBhR2x6TG5SdmEyVnVjeTV3ZFhOb0tIdGNiaUFnSUNBZ0lDQWdkSGx3WlRvZ0oyTnZaR1VuTEZ4dUlDQWdJQ0FnSUNCMFpYaDBPaUFoZEdocGN5NXZjSFJwYjI1ekxuQmxaR0Z1ZEdsalhHNGdJQ0FnSUNBZ0lDQWdQeUJqWVhBdWNtVndiR0ZqWlNndlhGeHVLeVF2TENBbkp5bGNiaUFnSUNBZ0lDQWdJQ0E2SUdOaGNGeHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5Qm1aVzVqWlhNZ0tHZG1iU2xjYmlBZ0lDQnBaaUFvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTVtWlc1alpYTXVaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdkR2hwY3k1MGIydGxibk11Y0hWemFDaDdYRzRnSUNBZ0lDQWdJSFI1Y0dVNklDZGpiMlJsSnl4Y2JpQWdJQ0FnSUNBZ2JHRnVaem9nWTJGd1d6SmRMRnh1SUNBZ0lDQWdJQ0IwWlhoME9pQmpZWEJiTTEwZ2ZId2dKeWRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnYUdWaFpHbHVaMXh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbWhsWVdScGJtY3VaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdkR2hwY3k1MGIydGxibk11Y0hWemFDaDdYRzRnSUNBZ0lDQWdJSFI1Y0dVNklDZG9aV0ZrYVc1bkp5eGNiaUFnSUNBZ0lDQWdaR1Z3ZEdnNklHTmhjRnN4WFM1c1pXNW5kR2dzWEc0Z0lDQWdJQ0FnSUhSbGVIUTZJR05oY0ZzeVhWeHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QjBZV0pzWlNCdWJ5QnNaV0ZrYVc1bklIQnBjR1VnS0dkbWJTbGNiaUFnSUNCcFppQW9kRzl3SUNZbUlDaGpZWEFnUFNCMGFHbHpMbkoxYkdWekxtNXdkR0ZpYkdVdVpYaGxZeWh6Y21NcEtTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNibHh1SUNBZ0lDQWdhWFJsYlNBOUlIdGNiaUFnSUNBZ0lDQWdkSGx3WlRvZ0ozUmhZbXhsSnl4Y2JpQWdJQ0FnSUNBZ2FHVmhaR1Z5T2lCallYQmJNVjB1Y21Wd2JHRmpaU2d2WGlBcWZDQXFYRng4SUNva0wyY3NJQ2NuS1M1emNHeHBkQ2d2SUNwY1hId2dLaThwTEZ4dUlDQWdJQ0FnSUNCaGJHbG5iam9nWTJGd1d6SmRMbkpsY0d4aFkyVW9MMTRnS254Y1hId2dLaVF2Wnl3Z0p5Y3BMbk53YkdsMEtDOGdLbHhjZkNBcUx5a3NYRzRnSUNBZ0lDQWdJR05sYkd4ek9pQmpZWEJiTTEwdWNtVndiR0ZqWlNndlhGeHVKQzhzSUNjbktTNXpjR3hwZENnblhGeHVKeWxjYmlBZ0lDQWdJSDA3WEc1Y2JpQWdJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0JwZEdWdExtRnNhV2R1TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJR2xtSUNndlhpQXFMU3M2SUNva0x5NTBaWE4wS0dsMFpXMHVZV3hwWjI1YmFWMHBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FYUmxiUzVoYkdsbmJsdHBYU0E5SUNkeWFXZG9kQ2M3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb0wxNGdLam90S3pvZ0tpUXZMblJsYzNRb2FYUmxiUzVoYkdsbmJsdHBYU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBkR1Z0TG1Gc2FXZHVXMmxkSUQwZ0oyTmxiblJsY2ljN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9MMTRnS2pvdEt5QXFKQzh1ZEdWemRDaHBkR1Z0TG1Gc2FXZHVXMmxkS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2wwWlcwdVlXeHBaMjViYVYwZ1BTQW5iR1ZtZENjN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdhWFJsYlM1aGJHbG5ibHRwWFNBOUlHNTFiR3c3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ1ptOXlJQ2hwSUQwZ01Ec2dhU0E4SUdsMFpXMHVZMlZzYkhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnYVhSbGJTNWpaV3hzYzF0cFhTQTlJR2wwWlcwdVkyVnNiSE5iYVYwdWMzQnNhWFFvTHlBcVhGeDhJQ292S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNocGRHVnRLVHRjYmx4dUlDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnYkdobFlXUnBibWRjYmlBZ0lDQnBaaUFvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTVzYUdWaFpHbHVaeTVsZUdWaktITnlZeWtwSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0IwYUdsekxuUnZhMlZ1Y3k1d2RYTm9LSHRjYmlBZ0lDQWdJQ0FnZEhsd1pUb2dKMmhsWVdScGJtY25MRnh1SUNBZ0lDQWdJQ0JrWlhCMGFEb2dZMkZ3V3pKZElEMDlQU0FuUFNjZ1B5QXhJRG9nTWl4Y2JpQWdJQ0FnSUNBZ2RHVjRkRG9nWTJGd1d6RmRYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR2h5WEc0Z0lDQWdhV1lnS0dOaGNDQTlJSFJvYVhNdWNuVnNaWE11YUhJdVpYaGxZeWh6Y21NcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNoN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUNkb2NpZGNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdZbXh2WTJ0eGRXOTBaVnh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbUpzYjJOcmNYVnZkR1V1WlhobFl5aHpjbU1wS1NCN1hHNGdJQ0FnSUNCemNtTWdQU0J6Y21NdWMzVmljM1J5YVc1bktHTmhjRnN3WFM1c1pXNW5kR2dwTzF4dVhHNGdJQ0FnSUNCMGFHbHpMblJ2YTJWdWN5NXdkWE5vS0h0Y2JpQWdJQ0FnSUNBZ2RIbHdaVG9nSjJKc2IyTnJjWFZ2ZEdWZmMzUmhjblFuWEc0Z0lDQWdJQ0I5S1R0Y2JseHVJQ0FnSUNBZ1kyRndJRDBnWTJGd1d6QmRMbkpsY0d4aFkyVW9MMTRnS2o0Z1B5OW5iU3dnSnljcE8xeHVYRzRnSUNBZ0lDQXZMeUJRWVhOeklHQjBiM0JnSUhSdklHdGxaWEFnZEdobElHTjFjbkpsYm5SY2JpQWdJQ0FnSUM4dklGd2lkRzl3YkdWMlpXeGNJaUJ6ZEdGMFpTNGdWR2hwY3lCcGN5QmxlR0ZqZEd4NVhHNGdJQ0FnSUNBdkx5Qm9iM2NnYldGeWEyUnZkMjR1Y0d3Z2QyOXlhM011WEc0Z0lDQWdJQ0IwYUdsekxuUnZhMlZ1S0dOaGNDd2dkRzl3TENCMGNuVmxLVHRjYmx4dUlDQWdJQ0FnZEdocGN5NTBiMnRsYm5NdWNIVnphQ2g3WEc0Z0lDQWdJQ0FnSUhSNWNHVTZJQ2RpYkc5amEzRjFiM1JsWDJWdVpDZGNiaUFnSUNBZ0lIMHBPMXh1WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJzYVhOMFhHNGdJQ0FnYVdZZ0tHTmhjQ0E5SUhSb2FYTXVjblZzWlhNdWJHbHpkQzVsZUdWaktITnlZeWtwSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0JpZFd4c0lEMGdZMkZ3V3pKZE8xeHVYRzRnSUNBZ0lDQjBhR2x6TG5SdmEyVnVjeTV3ZFhOb0tIdGNiaUFnSUNBZ0lDQWdkSGx3WlRvZ0oyeHBjM1JmYzNSaGNuUW5MRnh1SUNBZ0lDQWdJQ0J2Y21SbGNtVmtPaUJpZFd4c0xteGxibWQwYUNBK0lERmNiaUFnSUNBZ0lIMHBPMXh1WEc0Z0lDQWdJQ0F2THlCSFpYUWdaV0ZqYUNCMGIzQXRiR1YyWld3Z2FYUmxiUzVjYmlBZ0lDQWdJR05oY0NBOUlHTmhjRnN3WFM1dFlYUmphQ2gwYUdsekxuSjFiR1Z6TG1sMFpXMHBPMXh1WEc0Z0lDQWdJQ0J1WlhoMElEMGdabUZzYzJVN1hHNGdJQ0FnSUNCc0lEMGdZMkZ3TG14bGJtZDBhRHRjYmlBZ0lDQWdJR2tnUFNBd08xeHVYRzRnSUNBZ0lDQm1iM0lnS0RzZ2FTQThJR3c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0JwZEdWdElEMGdZMkZ3VzJsZE8xeHVYRzRnSUNBZ0lDQWdJQzh2SUZKbGJXOTJaU0IwYUdVZ2JHbHpkQ0JwZEdWdEozTWdZblZzYkdWMFhHNGdJQ0FnSUNBZ0lDOHZJSE52SUdsMElHbHpJSE5sWlc0Z1lYTWdkR2hsSUc1bGVIUWdkRzlyWlc0dVhHNGdJQ0FnSUNBZ0lITndZV05sSUQwZ2FYUmxiUzVzWlc1bmRHZzdYRzRnSUNBZ0lDQWdJR2wwWlcwZ1BTQnBkR1Z0TG5KbGNHeGhZMlVvTDE0Z0tpaGJLaXN0WFh4Y1hHUXJYRnd1S1NBckx5d2dKeWNwTzF4dVhHNGdJQ0FnSUNBZ0lDOHZJRTkxZEdSbGJuUWdkMmhoZEdWMlpYSWdkR2hsWEc0Z0lDQWdJQ0FnSUM4dklHeHBjM1FnYVhSbGJTQmpiMjUwWVdsdWN5NGdTR0ZqYTNrdVhHNGdJQ0FnSUNBZ0lHbG1JQ2grYVhSbGJTNXBibVJsZUU5bUtDZGNYRzRnSnlrcElIdGNiaUFnSUNBZ0lDQWdJQ0J6Y0dGalpTQXRQU0JwZEdWdExteGxibWQwYUR0Y2JpQWdJQ0FnSUNBZ0lDQnBkR1Z0SUQwZ0lYUm9hWE11YjNCMGFXOXVjeTV3WldSaGJuUnBZMXh1SUNBZ0lDQWdJQ0FnSUNBZ1B5QnBkR1Z0TG5KbGNHeGhZMlVvYm1WM0lGSmxaMFY0Y0NnblhpQjdNU3duSUNzZ2MzQmhZMlVnS3lBbmZTY3NJQ2RuYlNjcExDQW5KeWxjYmlBZ0lDQWdJQ0FnSUNBZ0lEb2dhWFJsYlM1eVpYQnNZV05sS0M5ZUlIc3hMRFI5TDJkdExDQW5KeWs3WEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQXZMeUJFWlhSbGNtMXBibVVnZDJobGRHaGxjaUIwYUdVZ2JtVjRkQ0JzYVhOMElHbDBaVzBnWW1Wc2IyNW5jeUJvWlhKbExseHVJQ0FnSUNBZ0lDQXZMeUJDWVdOcmNHVmtZV3dnYVdZZ2FYUWdaRzlsY3lCdWIzUWdZbVZzYjI1bklHbHVJSFJvYVhNZ2JHbHpkQzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11YjNCMGFXOXVjeTV6YldGeWRFeHBjM1J6SUNZbUlHa2dJVDA5SUd3Z0xTQXhLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1lpQTlJR0pzYjJOckxtSjFiR3hsZEM1bGVHVmpLR05oY0Z0cElDc2dNVjBwV3pCZE8xeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoaWRXeHNJQ0U5UFNCaUlDWW1JQ0VvWW5Wc2JDNXNaVzVuZEdnZ1BpQXhJQ1ltSUdJdWJHVnVaM1JvSUQ0Z01Ta3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lITnlZeUE5SUdOaGNDNXpiR2xqWlNocElDc2dNU2t1YW05cGJpZ25YRnh1SnlrZ0t5QnpjbU03WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBJRDBnYkNBdElERTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdMeThnUkdWMFpYSnRhVzVsSUhkb1pYUm9aWElnYVhSbGJTQnBjeUJzYjI5elpTQnZjaUJ1YjNRdVhHNGdJQ0FnSUNBZ0lDOHZJRlZ6WlRvZ0x5aGVmRnhjYmlrb1B5RWdLVnRlWEZ4dVhTdGNYRzVjWEc0b1B5RmNYSE1xSkNrdlhHNGdJQ0FnSUNBZ0lDOHZJR1p2Y2lCa2FYTmpiM1Z1ZENCaVpXaGhkbWx2Y2k1Y2JpQWdJQ0FnSUNBZ2JHOXZjMlVnUFNCdVpYaDBJSHg4SUM5Y1hHNWNYRzRvUHlGY1hITXFKQ2t2TG5SbGMzUW9hWFJsYlNrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hwSUNFOVBTQnNJQzBnTVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJRzVsZUhRZ1BTQnBkR1Z0TG1Ob1lYSkJkQ2hwZEdWdExteGxibWQwYUNBdElERXBJRDA5UFNBblhGeHVKenRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9JV3h2YjNObEtTQnNiMjl6WlNBOUlHNWxlSFE3WEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQjBhR2x6TG5SdmEyVnVjeTV3ZFhOb0tIdGNiaUFnSUNBZ0lDQWdJQ0IwZVhCbE9pQnNiMjl6WlZ4dUlDQWdJQ0FnSUNBZ0lDQWdQeUFuYkc5dmMyVmZhWFJsYlY5emRHRnlkQ2RjYmlBZ0lDQWdJQ0FnSUNBZ0lEb2dKMnhwYzNSZmFYUmxiVjl6ZEdGeWRDZGNiaUFnSUNBZ0lDQWdmU2s3WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdVbVZqZFhKelpTNWNiaUFnSUNBZ0lDQWdkR2hwY3k1MGIydGxiaWhwZEdWdExDQm1ZV3h6WlN3Z1luRXBPMXh1WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkRzlyWlc1ekxuQjFjMmdvZTF4dUlDQWdJQ0FnSUNBZ0lIUjVjR1U2SUNkc2FYTjBYMmwwWlcxZlpXNWtKMXh1SUNBZ0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNoN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUNkc2FYTjBYMlZ1WkNkY2JpQWdJQ0FnSUgwcE8xeHVYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5Qm9kRzFzWEc0Z0lDQWdhV1lnS0dOaGNDQTlJSFJvYVhNdWNuVnNaWE11YUhSdGJDNWxlR1ZqS0hOeVl5a3BJSHRjYmlBZ0lDQWdJSE55WXlBOUlITnlZeTV6ZFdKemRISnBibWNvWTJGd1d6QmRMbXhsYm1kMGFDazdYRzRnSUNBZ0lDQjBhR2x6TG5SdmEyVnVjeTV3ZFhOb0tIdGNiaUFnSUNBZ0lDQWdkSGx3WlRvZ2RHaHBjeTV2Y0hScGIyNXpMbk5oYm1sMGFYcGxYRzRnSUNBZ0lDQWdJQ0FnUHlBbmNHRnlZV2R5WVhCb0oxeHVJQ0FnSUNBZ0lDQWdJRG9nSjJoMGJXd25MRnh1SUNBZ0lDQWdJQ0J3Y21VNklDRjBhR2x6TG05d2RHbHZibk11YzJGdWFYUnBlbVZ5WEc0Z0lDQWdJQ0FnSUNBZ0ppWWdLR05oY0ZzeFhTQTlQVDBnSjNCeVpTY2dmSHdnWTJGd1d6RmRJRDA5UFNBbmMyTnlhWEIwSnlCOGZDQmpZWEJiTVYwZ1BUMDlJQ2R6ZEhsc1pTY3BMRnh1SUNBZ0lDQWdJQ0IwWlhoME9pQmpZWEJiTUYxY2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1pHVm1YRzRnSUNBZ2FXWWdLQ2doWW5FZ0ppWWdkRzl3S1NBbUppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NWtaV1l1WlhobFl5aHpjbU1wS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUhSb2FYTXVkRzlyWlc1ekxteHBibXR6VzJOaGNGc3hYUzUwYjB4dmQyVnlRMkZ6WlNncFhTQTlJSHRjYmlBZ0lDQWdJQ0FnYUhKbFpqb2dZMkZ3V3pKZExGeHVJQ0FnSUNBZ0lDQjBhWFJzWlRvZ1kyRndXek5kWEc0Z0lDQWdJQ0I5TzF4dUlDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnZEdGaWJHVWdLR2RtYlNsY2JpQWdJQ0JwWmlBb2RHOXdJQ1ltSUNoallYQWdQU0IwYUdsekxuSjFiR1Z6TG5SaFlteGxMbVY0WldNb2MzSmpLU2twSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc1Y2JpQWdJQ0FnSUdsMFpXMGdQU0I3WEc0Z0lDQWdJQ0FnSUhSNWNHVTZJQ2QwWVdKc1pTY3NYRzRnSUNBZ0lDQWdJR2hsWVdSbGNqb2dZMkZ3V3pGZExuSmxjR3hoWTJVb0wxNGdLbndnS2x4Y2ZDQXFKQzluTENBbkp5a3VjM0JzYVhRb0x5QXFYRng4SUNvdktTeGNiaUFnSUNBZ0lDQWdZV3hwWjI0NklHTmhjRnN5WFM1eVpYQnNZV05sS0M5ZUlDcDhYRng4SUNva0wyY3NJQ2NuS1M1emNHeHBkQ2d2SUNwY1hId2dLaThwTEZ4dUlDQWdJQ0FnSUNCalpXeHNjem9nWTJGd1d6TmRMbkpsY0d4aFkyVW9MeWcvT2lBcVhGeDhJQ29wUDF4Y2JpUXZMQ0FuSnlrdWMzQnNhWFFvSjF4Y2JpY3BYRzRnSUNBZ0lDQjlPMXh1WEc0Z0lDQWdJQ0JtYjNJZ0tHa2dQU0F3T3lCcElEd2dhWFJsYlM1aGJHbG5iaTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvTDE0Z0tpMHJPaUFxSkM4dWRHVnpkQ2hwZEdWdExtRnNhV2R1VzJsZEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsMFpXMHVZV3hwWjI1YmFWMGdQU0FuY21sbmFIUW5PMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0M5ZUlDbzZMU3M2SUNva0x5NTBaWE4wS0dsMFpXMHVZV3hwWjI1YmFWMHBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FYUmxiUzVoYkdsbmJsdHBYU0E5SUNkalpXNTBaWEluTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tDOWVJQ282TFNzZ0tpUXZMblJsYzNRb2FYUmxiUzVoYkdsbmJsdHBYU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBkR1Z0TG1Gc2FXZHVXMmxkSUQwZ0oyeGxablFuTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHbDBaVzB1WVd4cFoyNWJhVjBnUFNCdWRXeHNPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0JwZEdWdExtTmxiR3h6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJR2wwWlcwdVkyVnNiSE5iYVYwZ1BTQnBkR1Z0TG1ObGJHeHpXMmxkWEc0Z0lDQWdJQ0FnSUNBZ0xuSmxjR3hoWTJVb0wxNGdLbHhjZkNBcWZDQXFYRng4SUNva0wyY3NJQ2NuS1Z4dUlDQWdJQ0FnSUNBZ0lDNXpjR3hwZENndklDcGNYSHdnS2k4cE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQjBhR2x6TG5SdmEyVnVjeTV3ZFhOb0tHbDBaVzBwTzF4dVhHNGdJQ0FnSUNCamIyNTBhVzUxWlR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCMGIzQXRiR1YyWld3Z2NHRnlZV2R5WVhCb1hHNGdJQ0FnYVdZZ0tIUnZjQ0FtSmlBb1kyRndJRDBnZEdocGN5NXlkV3hsY3k1d1lYSmhaM0poY0dndVpYaGxZeWh6Y21NcEtTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNiaUFnSUNBZ0lIUm9hWE11ZEc5clpXNXpMbkIxYzJnb2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lBbmNHRnlZV2R5WVhCb0p5eGNiaUFnSUNBZ0lDQWdkR1Y0ZERvZ1kyRndXekZkTG1Ob1lYSkJkQ2hqWVhCYk1WMHViR1Z1WjNSb0lDMGdNU2tnUFQwOUlDZGNYRzRuWEc0Z0lDQWdJQ0FnSUNBZ1B5QmpZWEJiTVYwdWMyeHBZMlVvTUN3Z0xURXBYRzRnSUNBZ0lDQWdJQ0FnT2lCallYQmJNVjFjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnZEdWNGRGeHVJQ0FnSUdsbUlDaGpZWEFnUFNCMGFHbHpMbkoxYkdWekxuUmxlSFF1WlhobFl5aHpjbU1wS1NCN1hHNGdJQ0FnSUNBdkx5QlViM0F0YkdWMlpXd2djMmh2ZFd4a0lHNWxkbVZ5SUhKbFlXTm9JR2hsY21VdVhHNGdJQ0FnSUNCemNtTWdQU0J6Y21NdWMzVmljM1J5YVc1bktHTmhjRnN3WFM1c1pXNW5kR2dwTzF4dUlDQWdJQ0FnZEdocGN5NTBiMnRsYm5NdWNIVnphQ2g3WEc0Z0lDQWdJQ0FnSUhSNWNHVTZJQ2QwWlhoMEp5eGNiaUFnSUNBZ0lDQWdkR1Y0ZERvZ1kyRndXekJkWEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoemNtTXBJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkMXh1SUNBZ0lDQWdJQ0JGY25KdmNpZ25TVzVtYVc1cGRHVWdiRzl2Y0NCdmJpQmllWFJsT2lBbklDc2djM0pqTG1Ob1lYSkRiMlJsUVhRb01Da3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjBhR2x6TG5SdmEyVnVjenRjYm4wN1hHNWNiaThxS2x4dUlDb2dTVzVzYVc1bExVeGxkbVZzSUVkeVlXMXRZWEpjYmlBcUwxeHVYRzUyWVhJZ2FXNXNhVzVsSUQwZ2UxeHVJQ0JsYzJOaGNHVTZJQzllWEZ4Y1hDaGJYRnhjWEdBcWUzMWNYRnRjWEYwb0tTTXJYRnd0TGlGZlBsMHBMeXhjYmlBZ1lYVjBiMnhwYm1zNklDOWVQQ2hiWGlBK1hTc29RSHc2WEZ3dktWdGVJRDVkS3lrK0x5eGNiaUFnZFhKc09pQnViMjl3TEZ4dUlDQjBZV2M2SUM5ZVBDRXRMVnRjWEhOY1hGTmRLajh0TFQ1OFhqeGNYQzgvWEZ4M0t5Zy9PbHdpVzE1Y0lsMHFYQ0o4SjF0ZUoxMHFKM3hiWGlkY0lqNWRLU28vUGk4c1hHNGdJR3hwYm1zNklDOWVJVDljWEZzb2FXNXphV1JsS1Z4Y1hWeGNLR2h5WldaY1hDa3ZMRnh1SUNCeVpXWnNhVzVyT2lBdlhpRS9YRnhiS0dsdWMybGtaU2xjWEYxY1hITXFYRnhiS0Z0ZVhGeGRYU29wWEZ4ZEx5eGNiaUFnYm05c2FXNXJPaUF2WGlFL1hGeGJLQ2cvT2x4Y1cxdGVYRnhkWFNwY1hGMThXMTVjWEZ0Y1hGMWRLU29wWEZ4ZEx5eGNiaUFnYzNSeWIyNW5PaUF2WGw5ZktGdGNYSE5jWEZOZEt6OHBYMThvUHlGZktYeGVYRndxWEZ3cUtGdGNYSE5jWEZOZEt6OHBYRndxWEZ3cUtEOGhYRndxS1M4c1hHNGdJR1Z0T2lBdlhseGNZbDhvS0Q4NlcxNWZYWHhmWHlrclB5bGZYRnhpZkY1Y1hDb29LRDg2WEZ3cVhGd3FmRnRjWEhOY1hGTmRLU3MvS1Z4Y0tpZy9JVnhjS2lrdkxGeHVJQ0JqYjJSbE9pQXZYaWhnS3lsY1hITXFLRnRjWEhOY1hGTmRLajliWG1CZEtWeGNjeXBjWERFb1B5RmdLUzhzWEc0Z0lHSnlPaUF2WGlCN01peDlYRnh1S0Q4aFhGeHpLaVFwTHl4Y2JpQWdaR1ZzT2lCdWIyOXdMRnh1SUNCMFpYaDBPaUF2WGx0Y1hITmNYRk5kS3o4b1B6MWJYRnhjWER3aFhGeGJYeXBnWFh3Z2V6SXNmVnhjYm53a0tTOWNibjA3WEc1Y2JtbHViR2x1WlM1ZmFXNXphV1JsSUQwZ0x5Zy9PbHhjVzF0ZVhGeGRYU3BjWEYxOFcxNWNYRnRjWEYxZGZGeGNYU2cvUFZ0ZVhGeGJYU3BjWEYwcEtTb3ZPMXh1YVc1c2FXNWxMbDlvY21WbUlEMGdMMXhjY3lvOFB5aGJYRnh6WEZ4VFhTby9LVDQvS0Q4NlhGeHpLMXNuWENKZEtGdGNYSE5jWEZOZEtqOHBXeWRjSWwwcFAxeGNjeW92TzF4dVhHNXBibXhwYm1VdWJHbHVheUE5SUhKbGNHeGhZMlVvYVc1c2FXNWxMbXhwYm1zcFhHNGdJQ2duYVc1emFXUmxKeXdnYVc1c2FXNWxMbDlwYm5OcFpHVXBYRzRnSUNnbmFISmxaaWNzSUdsdWJHbHVaUzVmYUhKbFppbGNiaUFnS0NrN1hHNWNibWx1YkdsdVpTNXlaV1pzYVc1cklEMGdjbVZ3YkdGalpTaHBibXhwYm1VdWNtVm1iR2x1YXlsY2JpQWdLQ2RwYm5OcFpHVW5MQ0JwYm14cGJtVXVYMmx1YzJsa1pTbGNiaUFnS0NrN1hHNWNiaThxS2x4dUlDb2dUbTl5YldGc0lFbHViR2x1WlNCSGNtRnRiV0Z5WEc0Z0tpOWNibHh1YVc1c2FXNWxMbTV2Y20xaGJDQTlJRzFsY21kbEtIdDlMQ0JwYm14cGJtVXBPMXh1WEc0dktpcGNiaUFxSUZCbFpHRnVkR2xqSUVsdWJHbHVaU0JIY21GdGJXRnlYRzRnS2k5Y2JseHVhVzVzYVc1bExuQmxaR0Z1ZEdsaklEMGdiV1Z5WjJVb2UzMHNJR2x1YkdsdVpTNXViM0p0WVd3c0lIdGNiaUFnYzNSeWIyNW5PaUF2WGw5ZktEODlYRnhUS1NoYlhGeHpYRnhUWFNvL1hGeFRLVjlmS0Q4aFh5bDhYbHhjS2x4Y0tpZy9QVnhjVXlrb1cxeGNjMXhjVTEwcVAxeGNVeWxjWENwY1hDb29QeUZjWENvcEx5eGNiaUFnWlcwNklDOWVYeWcvUFZ4Y1V5a29XMXhjYzF4Y1UxMHFQMXhjVXlsZktEOGhYeWw4WGx4Y0tpZy9QVnhjVXlrb1cxeGNjMXhjVTEwcVAxeGNVeWxjWENvb1B5RmNYQ29wTDF4dWZTazdYRzVjYmk4cUtseHVJQ29nUjBaTklFbHViR2x1WlNCSGNtRnRiV0Z5WEc0Z0tpOWNibHh1YVc1c2FXNWxMbWRtYlNBOUlHMWxjbWRsS0h0OUxDQnBibXhwYm1VdWJtOXliV0ZzTENCN1hHNGdJR1Z6WTJGd1pUb2djbVZ3YkdGalpTaHBibXhwYm1VdVpYTmpZWEJsS1NnblhTa25MQ0FuZm54ZEtTY3BLQ2tzWEc0Z0lIVnliRG9nTDE0b2FIUjBjSE0vT2x4Y0wxeGNMMXRlWEZ4elBGMHJXMTQ4TGl3Nk8xd2lKeWxjWEYxY1hITmRLUzhzWEc0Z0lHUmxiRG9nTDE1K2ZpZy9QVnhjVXlrb1cxeGNjMXhjVTEwcVAxeGNVeWwrZmk4c1hHNGdJSFJsZUhRNklISmxjR3hoWTJVb2FXNXNhVzVsTG5SbGVIUXBYRzRnSUNBZ0tDZGRmQ2NzSUNkK1hYd25LVnh1SUNBZ0lDZ25mQ2NzSUNkOGFIUjBjSE0vT2k4dmZDY3BYRzRnSUNBZ0tDbGNibjBwTzF4dVhHNHZLaXBjYmlBcUlFZEdUU0FySUV4cGJtVWdRbkpsWVd0eklFbHViR2x1WlNCSGNtRnRiV0Z5WEc0Z0tpOWNibHh1YVc1c2FXNWxMbUp5WldGcmN5QTlJRzFsY21kbEtIdDlMQ0JwYm14cGJtVXVaMlp0TENCN1hHNGdJR0p5T2lCeVpYQnNZV05sS0dsdWJHbHVaUzVpY2lrb0ozc3lMSDBuTENBbktpY3BLQ2tzWEc0Z0lIUmxlSFE2SUhKbGNHeGhZMlVvYVc1c2FXNWxMbWRtYlM1MFpYaDBLU2duZXpJc2ZTY3NJQ2NxSnlrb0tWeHVmU2s3WEc1Y2JpOHFLbHh1SUNvZ1NXNXNhVzVsSUV4bGVHVnlJQ1lnUTI5dGNHbHNaWEpjYmlBcUwxeHVYRzVtZFc1amRHbHZiaUJKYm14cGJtVk1aWGhsY2loc2FXNXJjeXdnYjNCMGFXOXVjeWtnZTF4dUlDQjBhR2x6TG05d2RHbHZibk1nUFNCdmNIUnBiMjV6SUh4OElHMWhjbXRsWkM1a1pXWmhkV3gwY3p0Y2JpQWdkR2hwY3k1c2FXNXJjeUE5SUd4cGJtdHpPMXh1SUNCMGFHbHpMbkoxYkdWeklEMGdhVzVzYVc1bExtNXZjbTFoYkR0Y2JpQWdkR2hwY3k1eVpXNWtaWEpsY2lBOUlIUm9hWE11YjNCMGFXOXVjeTV5Wlc1a1pYSmxjaUI4ZkNCdVpYY2dVbVZ1WkdWeVpYSTdYRzRnSUhSb2FYTXVjbVZ1WkdWeVpYSXViM0IwYVc5dWN5QTlJSFJvYVhNdWIzQjBhVzl1Y3p0Y2JseHVJQ0JwWmlBb0lYUm9hWE11YkdsdWEzTXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYZGNiaUFnSUNBZ0lFVnljbTl5S0NkVWIydGxibk1nWVhKeVlYa2djbVZ4ZFdseVpYTWdZU0JnYkdsdWEzTmdJSEJ5YjNCbGNuUjVMaWNwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLSFJvYVhNdWIzQjBhVzl1Y3k1blptMHBJSHRjYmlBZ0lDQnBaaUFvZEdocGN5NXZjSFJwYjI1ekxtSnlaV0ZyY3lrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTV5ZFd4bGN5QTlJR2x1YkdsdVpTNWljbVZoYTNNN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSFJvYVhNdWNuVnNaWE1nUFNCcGJteHBibVV1WjJadE8xeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElHbG1JQ2gwYUdsekxtOXdkR2x2Ym5NdWNHVmtZVzUwYVdNcElIdGNiaUFnSUNCMGFHbHpMbkoxYkdWeklEMGdhVzVzYVc1bExuQmxaR0Z1ZEdsak8xeHVJQ0I5WEc1OVhHNWNiaThxS2x4dUlDb2dSWGh3YjNObElFbHViR2x1WlNCU2RXeGxjMXh1SUNvdlhHNWNia2x1YkdsdVpVeGxlR1Z5TG5KMWJHVnpJRDBnYVc1c2FXNWxPMXh1WEc0dktpcGNiaUFxSUZOMFlYUnBZeUJNWlhocGJtY3ZRMjl0Y0dsc2FXNW5JRTFsZEdodlpGeHVJQ292WEc1Y2JrbHViR2x1WlV4bGVHVnlMbTkxZEhCMWRDQTlJR1oxYm1OMGFXOXVLSE55WXl3Z2JHbHVhM01zSUc5d2RHbHZibk1wSUh0Y2JpQWdkbUZ5SUdsdWJHbHVaU0E5SUc1bGR5QkpibXhwYm1WTVpYaGxjaWhzYVc1cmN5d2diM0IwYVc5dWN5azdYRzRnSUhKbGRIVnliaUJwYm14cGJtVXViM1YwY0hWMEtITnlZeWs3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRXhsZUdsdVp5OURiMjF3YVd4cGJtZGNiaUFxTDF4dVhHNUpibXhwYm1WTVpYaGxjaTV3Y205MGIzUjVjR1V1YjNWMGNIVjBJRDBnWm5WdVkzUnBiMjRvYzNKaktTQjdYRzRnSUhaaGNpQnZkWFFnUFNBbkoxeHVJQ0FnSUN3Z2JHbHVhMXh1SUNBZ0lDd2dkR1Y0ZEZ4dUlDQWdJQ3dnYUhKbFpseHVJQ0FnSUN3Z1kyRndPMXh1WEc0Z0lIZG9hV3hsSUNoemNtTXBJSHRjYmlBZ0lDQXZMeUJsYzJOaGNHVmNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NWxjMk5oY0dVdVpYaGxZeWh6Y21NcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2IzVjBJQ3M5SUdOaGNGc3hYVHRjYmlBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR0YxZEc5c2FXNXJYRzRnSUNBZ2FXWWdLR05oY0NBOUlIUm9hWE11Y25Wc1pYTXVZWFYwYjJ4cGJtc3VaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdhV1lnS0dOaGNGc3lYU0E5UFQwZ0owQW5LU0I3WEc0Z0lDQWdJQ0FnSUhSbGVIUWdQU0JqWVhCYk1WMHVZMmhoY2tGMEtEWXBJRDA5UFNBbk9pZGNiaUFnSUNBZ0lDQWdJQ0EvSUhSb2FYTXViV0Z1WjJ4bEtHTmhjRnN4WFM1emRXSnpkSEpwYm1jb055a3BYRzRnSUNBZ0lDQWdJQ0FnT2lCMGFHbHpMbTFoYm1kc1pTaGpZWEJiTVYwcE8xeHVJQ0FnSUNBZ0lDQm9jbVZtSUQwZ2RHaHBjeTV0WVc1bmJHVW9KMjFoYVd4MGJ6b25LU0FySUhSbGVIUTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQjBaWGgwSUQwZ1pYTmpZWEJsS0dOaGNGc3hYU2s3WEc0Z0lDQWdJQ0FnSUdoeVpXWWdQU0IwWlhoME8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2IzVjBJQ3M5SUhSb2FYTXVjbVZ1WkdWeVpYSXViR2x1YXlob2NtVm1MQ0J1ZFd4c0xDQjBaWGgwS1R0Y2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUhWeWJDQW9aMlp0S1Z4dUlDQWdJR2xtSUNnaGRHaHBjeTVwYmt4cGJtc2dKaVlnS0dOaGNDQTlJSFJvYVhNdWNuVnNaWE11ZFhKc0xtVjRaV01vYzNKaktTa3BJSHRjYmlBZ0lDQWdJSE55WXlBOUlITnlZeTV6ZFdKemRISnBibWNvWTJGd1d6QmRMbXhsYm1kMGFDazdYRzRnSUNBZ0lDQjBaWGgwSUQwZ1pYTmpZWEJsS0dOaGNGc3hYU2s3WEc0Z0lDQWdJQ0JvY21WbUlEMGdkR1Y0ZER0Y2JpQWdJQ0FnSUc5MWRDQXJQU0IwYUdsekxuSmxibVJsY21WeUxteHBibXNvYUhKbFppd2diblZzYkN3Z2RHVjRkQ2s3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUIwWVdkY2JpQWdJQ0JwWmlBb1kyRndJRDBnZEdocGN5NXlkV3hsY3k1MFlXY3VaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0JwWmlBb0lYUm9hWE11YVc1TWFXNXJJQ1ltSUM5ZVBHRWdMMmt1ZEdWemRDaGpZWEJiTUYwcEtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWFXNU1hVzVySUQwZ2RISjFaVHRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvZEdocGN5NXBia3hwYm1zZ0ppWWdMMTQ4WEZ3dllUNHZhUzUwWlhOMEtHTmhjRnN3WFNrcElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1cGJreHBibXNnUFNCbVlXeHpaVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJSE55WXlBOUlITnlZeTV6ZFdKemRISnBibWNvWTJGd1d6QmRMbXhsYm1kMGFDazdYRzRnSUNBZ0lDQnZkWFFnS3owZ2RHaHBjeTV2Y0hScGIyNXpMbk5oYm1sMGFYcGxYRzRnSUNBZ0lDQWdJRDhnZEdocGN5NXZjSFJwYjI1ekxuTmhibWwwYVhwbGNseHVJQ0FnSUNBZ0lDQWdJRDhnZEdocGN5NXZjSFJwYjI1ekxuTmhibWwwYVhwbGNpaGpZWEJiTUYwcFhHNGdJQ0FnSUNBZ0lDQWdPaUJsYzJOaGNHVW9ZMkZ3V3pCZEtWeHVJQ0FnSUNBZ0lDQTZJR05oY0Zzd1hWeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z2JHbHVhMXh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbXhwYm1zdVpYaGxZeWh6Y21NcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2RHaHBjeTVwYmt4cGJtc2dQU0IwY25WbE8xeHVJQ0FnSUNBZ2IzVjBJQ3M5SUhSb2FYTXViM1YwY0hWMFRHbHVheWhqWVhBc0lIdGNiaUFnSUNBZ0lDQWdhSEpsWmpvZ1kyRndXekpkTEZ4dUlDQWdJQ0FnSUNCMGFYUnNaVG9nWTJGd1d6TmRYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJSFJvYVhNdWFXNU1hVzVySUQwZ1ptRnNjMlU3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJ5Wldac2FXNXJMQ0J1YjJ4cGJtdGNiaUFnSUNCcFppQW9LR05oY0NBOUlIUm9hWE11Y25Wc1pYTXVjbVZtYkdsdWF5NWxlR1ZqS0hOeVl5a3BYRzRnSUNBZ0lDQWdJSHg4SUNoallYQWdQU0IwYUdsekxuSjFiR1Z6TG01dmJHbHVheTVsZUdWaktITnlZeWtwS1NCN1hHNGdJQ0FnSUNCemNtTWdQU0J6Y21NdWMzVmljM1J5YVc1bktHTmhjRnN3WFM1c1pXNW5kR2dwTzF4dUlDQWdJQ0FnYkdsdWF5QTlJQ2hqWVhCYk1sMGdmSHdnWTJGd1d6RmRLUzV5WlhCc1lXTmxLQzljWEhNckwyY3NJQ2NnSnlrN1hHNGdJQ0FnSUNCc2FXNXJJRDBnZEdocGN5NXNhVzVyYzF0c2FXNXJMblJ2VEc5M1pYSkRZWE5sS0NsZE8xeHVJQ0FnSUNBZ2FXWWdLQ0ZzYVc1cklIeDhJQ0ZzYVc1ckxtaHlaV1lwSUh0Y2JpQWdJQ0FnSUNBZ2IzVjBJQ3M5SUdOaGNGc3dYUzVqYUdGeVFYUW9NQ2s3WEc0Z0lDQWdJQ0FnSUhOeVl5QTlJR05oY0Zzd1hTNXpkV0p6ZEhKcGJtY29NU2tnS3lCemNtTTdYRzRnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdkR2hwY3k1cGJreHBibXNnUFNCMGNuVmxPMXh1SUNBZ0lDQWdiM1YwSUNzOUlIUm9hWE11YjNWMGNIVjBUR2x1YXloallYQXNJR3hwYm1zcE8xeHVJQ0FnSUNBZ2RHaHBjeTVwYmt4cGJtc2dQU0JtWVd4elpUdGNiaUFnSUNBZ0lHTnZiblJwYm5WbE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklITjBjbTl1WjF4dUlDQWdJR2xtSUNoallYQWdQU0IwYUdsekxuSjFiR1Z6TG5OMGNtOXVaeTVsZUdWaktITnlZeWtwSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0J2ZFhRZ0t6MGdkR2hwY3k1eVpXNWtaWEpsY2k1emRISnZibWNvZEdocGN5NXZkWFJ3ZFhRb1kyRndXekpkSUh4OElHTmhjRnN4WFNrcE8xeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1pXMWNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NWxiUzVsZUdWaktITnlZeWtwSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0J2ZFhRZ0t6MGdkR2hwY3k1eVpXNWtaWEpsY2k1bGJTaDBhR2x6TG05MWRIQjFkQ2hqWVhCYk1sMGdmSHdnWTJGd1d6RmRLU2s3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJqYjJSbFhHNGdJQ0FnYVdZZ0tHTmhjQ0E5SUhSb2FYTXVjblZzWlhNdVkyOWtaUzVsZUdWaktITnlZeWtwSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0J2ZFhRZ0t6MGdkR2hwY3k1eVpXNWtaWEpsY2k1amIyUmxjM0JoYmlobGMyTmhjR1VvWTJGd1d6SmRMQ0IwY25WbEtTazdYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QmljbHh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbUp5TG1WNFpXTW9jM0pqS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUc5MWRDQXJQU0IwYUdsekxuSmxibVJsY21WeUxtSnlLQ2s3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJrWld3Z0tHZG1iU2xjYmlBZ0lDQnBaaUFvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTVrWld3dVpYaGxZeWh6Y21NcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2IzVjBJQ3M5SUhSb2FYTXVjbVZ1WkdWeVpYSXVaR1ZzS0hSb2FYTXViM1YwY0hWMEtHTmhjRnN4WFNrcE8xeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z2RHVjRkRnh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMblJsZUhRdVpYaGxZeWh6Y21NcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2IzVjBJQ3M5SUhSb2FYTXVjbVZ1WkdWeVpYSXVkR1Y0ZENobGMyTmhjR1VvZEdocGN5NXpiV0Z5ZEhsd1lXNTBjeWhqWVhCYk1GMHBLU2s3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvYzNKaktTQjdYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYZGNiaUFnSUNBZ0lDQWdSWEp5YjNJb0owbHVabWx1YVhSbElHeHZiM0FnYjI0Z1lubDBaVG9nSnlBcklITnlZeTVqYUdGeVEyOWtaVUYwS0RBcEtUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2IzVjBPMXh1ZlR0Y2JseHVMeW9xWEc0Z0tpQkRiMjF3YVd4bElFeHBibXRjYmlBcUwxeHVYRzVKYm14cGJtVk1aWGhsY2k1d2NtOTBiM1I1Y0dVdWIzVjBjSFYwVEdsdWF5QTlJR1oxYm1OMGFXOXVLR05oY0N3Z2JHbHVheWtnZTF4dUlDQjJZWElnYUhKbFppQTlJR1Z6WTJGd1pTaHNhVzVyTG1oeVpXWXBYRzRnSUNBZ0xDQjBhWFJzWlNBOUlHeHBibXN1ZEdsMGJHVWdQeUJsYzJOaGNHVW9iR2x1YXk1MGFYUnNaU2tnT2lCdWRXeHNPMXh1WEc0Z0lISmxkSFZ5YmlCallYQmJNRjB1WTJoaGNrRjBLREFwSUNFOVBTQW5JU2RjYmlBZ0lDQS9JSFJvYVhNdWNtVnVaR1Z5WlhJdWJHbHVheWhvY21WbUxDQjBhWFJzWlN3Z2RHaHBjeTV2ZFhSd2RYUW9ZMkZ3V3pGZEtTbGNiaUFnSUNBNklIUm9hWE11Y21WdVpHVnlaWEl1YVcxaFoyVW9hSEpsWml3Z2RHbDBiR1VzSUdWelkyRndaU2hqWVhCYk1WMHBLVHRjYm4wN1hHNWNiaThxS2x4dUlDb2dVMjFoY25SNWNHRnVkSE1nVkhKaGJuTm1iM0p0WVhScGIyNXpYRzRnS2k5Y2JseHVTVzVzYVc1bFRHVjRaWEl1Y0hKdmRHOTBlWEJsTG5OdFlYSjBlWEJoYm5SeklEMGdablZ1WTNScGIyNG9kR1Y0ZENrZ2UxeHVJQ0JwWmlBb0lYUm9hWE11YjNCMGFXOXVjeTV6YldGeWRIbHdZVzUwY3lrZ2NtVjBkWEp1SUhSbGVIUTdYRzRnSUhKbGRIVnliaUIwWlhoMFhHNGdJQ0FnTHk4Z1pXMHRaR0Z6YUdWelhHNGdJQ0FnTG5KbGNHeGhZMlVvTHkwdExTOW5MQ0FuWEZ4MU1qQXhOQ2NwWEc0Z0lDQWdMeThnWlc0dFpHRnphR1Z6WEc0Z0lDQWdMbkpsY0d4aFkyVW9MeTB0TDJjc0lDZGNYSFV5TURFekp5bGNiaUFnSUNBdkx5QnZjR1Z1YVc1bklITnBibWRzWlhOY2JpQWdJQ0F1Y21Wd2JHRmpaU2d2S0Y1OFd5MWNYSFV5TURFMEx5aGNYRnQ3WENKY1hITmRLU2N2Wnl3Z0p5UXhYRngxTWpBeE9DY3BYRzRnSUNBZ0x5OGdZMnh2YzJsdVp5QnphVzVuYkdWeklDWWdZWEJ2YzNSeWIzQm9aWE5jYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZKeTluTENBblhGeDFNakF4T1NjcFhHNGdJQ0FnTHk4Z2IzQmxibWx1WnlCa2IzVmliR1Z6WEc0Z0lDQWdMbkpsY0d4aFkyVW9MeWhlZkZzdFhGeDFNakF4TkM4b1hGeGJlMXhjZFRJd01UaGNYSE5kS1Z3aUwyY3NJQ2NrTVZ4Y2RUSXdNV01uS1Z4dUlDQWdJQzh2SUdOc2IzTnBibWNnWkc5MVlteGxjMXh1SUNBZ0lDNXlaWEJzWVdObEtDOWNJaTluTENBblhGeDFNakF4WkNjcFhHNGdJQ0FnTHk4Z1pXeHNhWEJ6WlhOY2JpQWdJQ0F1Y21Wd2JHRmpaU2d2WEZ3dWV6TjlMMmNzSUNkY1hIVXlNREkySnlrN1hHNTlPMXh1WEc0dktpcGNiaUFxSUUxaGJtZHNaU0JNYVc1cmMxeHVJQ292WEc1Y2JrbHViR2x1WlV4bGVHVnlMbkJ5YjNSdmRIbHdaUzV0WVc1bmJHVWdQU0JtZFc1amRHbHZiaWgwWlhoMEtTQjdYRzRnSUdsbUlDZ2hkR2hwY3k1dmNIUnBiMjV6TG0xaGJtZHNaU2tnY21WMGRYSnVJSFJsZUhRN1hHNGdJSFpoY2lCdmRYUWdQU0FuSjF4dUlDQWdJQ3dnYkNBOUlIUmxlSFF1YkdWdVozUm9YRzRnSUNBZ0xDQnBJRDBnTUZ4dUlDQWdJQ3dnWTJnN1hHNWNiaUFnWm05eUlDZzdJR2tnUENCc095QnBLeXNwSUh0Y2JpQWdJQ0JqYUNBOUlIUmxlSFF1WTJoaGNrTnZaR1ZCZENocEtUdGNiaUFnSUNCcFppQW9UV0YwYUM1eVlXNWtiMjBvS1NBK0lEQXVOU2tnZTF4dUlDQWdJQ0FnWTJnZ1BTQW5lQ2NnS3lCamFDNTBiMU4wY21sdVp5Z3hOaWs3WEc0Z0lDQWdmVnh1SUNBZ0lHOTFkQ0FyUFNBbkppTW5JQ3NnWTJnZ0t5QW5PeWM3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnYjNWME8xeHVmVHRjYmx4dUx5b3FYRzRnS2lCU1pXNWtaWEpsY2x4dUlDb3ZYRzVjYm1aMWJtTjBhVzl1SUZKbGJtUmxjbVZ5S0c5d2RHbHZibk1wSUh0Y2JpQWdkR2hwY3k1dmNIUnBiMjV6SUQwZ2IzQjBhVzl1Y3lCOGZDQjdmVHRjYm4xY2JseHVVbVZ1WkdWeVpYSXVjSEp2ZEc5MGVYQmxMbU52WkdVZ1BTQm1kVzVqZEdsdmJpaGpiMlJsTENCc1lXNW5MQ0JsYzJOaGNHVmtLU0I3WEc0Z0lHbG1JQ2gwYUdsekxtOXdkR2x2Ym5NdWFHbG5hR3hwWjJoMEtTQjdYRzRnSUNBZ2RtRnlJRzkxZENBOUlIUm9hWE11YjNCMGFXOXVjeTVvYVdkb2JHbG5hSFFvWTI5a1pTd2diR0Z1WnlrN1hHNGdJQ0FnYVdZZ0tHOTFkQ0FoUFNCdWRXeHNJQ1ltSUc5MWRDQWhQVDBnWTI5a1pTa2dlMXh1SUNBZ0lDQWdaWE5qWVhCbFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCamIyUmxJRDBnYjNWME8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHbG1JQ2doYkdGdVp5a2dlMXh1SUNBZ0lISmxkSFZ5YmlBblBIQnlaVDQ4WTI5a1pUNG5YRzRnSUNBZ0lDQXJJQ2hsYzJOaGNHVmtJRDhnWTI5a1pTQTZJR1Z6WTJGd1pTaGpiMlJsTENCMGNuVmxLU2xjYmlBZ0lDQWdJQ3NnSjF4Y2Jqd3ZZMjlrWlQ0OEwzQnlaVDRuTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUNjOGNISmxQanhqYjJSbElHTnNZWE56UFZ3aUoxeHVJQ0FnSUNzZ2RHaHBjeTV2Y0hScGIyNXpMbXhoYm1kUWNtVm1hWGhjYmlBZ0lDQXJJR1Z6WTJGd1pTaHNZVzVuTENCMGNuVmxLVnh1SUNBZ0lDc2dKMXdpUGlkY2JpQWdJQ0FySUNobGMyTmhjR1ZrSUQ4Z1kyOWtaU0E2SUdWelkyRndaU2hqYjJSbExDQjBjblZsS1NsY2JpQWdJQ0FySUNkY1hHNDhMMk52WkdVK1BDOXdjbVUrWEZ4dUp6dGNibjA3WEc1Y2JsSmxibVJsY21WeUxuQnliM1J2ZEhsd1pTNWliRzlqYTNGMWIzUmxJRDBnWm5WdVkzUnBiMjRvY1hWdmRHVXBJSHRjYmlBZ2NtVjBkWEp1SUNjOFlteHZZMnR4ZFc5MFpUNWNYRzRuSUNzZ2NYVnZkR1VnS3lBblBDOWliRzlqYTNGMWIzUmxQbHhjYmljN1hHNTlPMXh1WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdWFIUnRiQ0E5SUdaMWJtTjBhVzl1S0doMGJXd3BJSHRjYmlBZ2NtVjBkWEp1SUdoMGJXdzdYRzU5TzF4dVhHNVNaVzVrWlhKbGNpNXdjbTkwYjNSNWNHVXVhR1ZoWkdsdVp5QTlJR1oxYm1OMGFXOXVLSFJsZUhRc0lHeGxkbVZzTENCeVlYY3BJSHRjYmlBZ2NtVjBkWEp1SUNjOGFDZGNiaUFnSUNBcklHeGxkbVZzWEc0Z0lDQWdLeUFuSUdsa1BWd2lKMXh1SUNBZ0lDc2dkR2hwY3k1dmNIUnBiMjV6TG1obFlXUmxjbEJ5WldacGVGeHVJQ0FnSUNzZ2NtRjNMblJ2VEc5M1pYSkRZWE5sS0NrdWNtVndiR0ZqWlNndlcxNWNYSGRkS3k5bkxDQW5MU2NwWEc0Z0lDQWdLeUFuWENJK0oxeHVJQ0FnSUNzZ2RHVjRkRnh1SUNBZ0lDc2dKend2YUNkY2JpQWdJQ0FySUd4bGRtVnNYRzRnSUNBZ0t5QW5QbHhjYmljN1hHNTlPMXh1WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdWFISWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdjbVYwZFhKdUlIUm9hWE11YjNCMGFXOXVjeTU0YUhSdGJDQS9JQ2M4YUhJdlBseGNiaWNnT2lBblBHaHlQbHhjYmljN1hHNTlPMXh1WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdWJHbHpkQ0E5SUdaMWJtTjBhVzl1S0dKdlpIa3NJRzl5WkdWeVpXUXBJSHRjYmlBZ2RtRnlJSFI1Y0dVZ1BTQnZjbVJsY21Wa0lEOGdKMjlzSnlBNklDZDFiQ2M3WEc0Z0lISmxkSFZ5YmlBblBDY2dLeUIwZVhCbElDc2dKejVjWEc0bklDc2dZbTlrZVNBcklDYzhMeWNnS3lCMGVYQmxJQ3NnSno1Y1hHNG5PMXh1ZlR0Y2JseHVVbVZ1WkdWeVpYSXVjSEp2ZEc5MGVYQmxMbXhwYzNScGRHVnRJRDBnWm5WdVkzUnBiMjRvZEdWNGRDa2dlMXh1SUNCeVpYUjFjbTRnSnp4c2FUNG5JQ3NnZEdWNGRDQXJJQ2M4TDJ4cFBseGNiaWM3WEc1OU8xeHVYRzVTWlc1a1pYSmxjaTV3Y205MGIzUjVjR1V1Y0dGeVlXZHlZWEJvSUQwZ1puVnVZM1JwYjI0b2RHVjRkQ2tnZTF4dUlDQnlaWFIxY200Z0p6eHdQaWNnS3lCMFpYaDBJQ3NnSnp3dmNENWNYRzRuTzF4dWZUdGNibHh1VW1WdVpHVnlaWEl1Y0hKdmRHOTBlWEJsTG5SaFlteGxJRDBnWm5WdVkzUnBiMjRvYUdWaFpHVnlMQ0JpYjJSNUtTQjdYRzRnSUhKbGRIVnliaUFuUEhSaFlteGxQbHhjYmlkY2JpQWdJQ0FySUNjOGRHaGxZV1ErWEZ4dUoxeHVJQ0FnSUNzZ2FHVmhaR1Z5WEc0Z0lDQWdLeUFuUEM5MGFHVmhaRDVjWEc0blhHNGdJQ0FnS3lBblBIUmliMlI1UGx4Y2JpZGNiaUFnSUNBcklHSnZaSGxjYmlBZ0lDQXJJQ2M4TDNSaWIyUjVQbHhjYmlkY2JpQWdJQ0FySUNjOEwzUmhZbXhsUGx4Y2JpYzdYRzU5TzF4dVhHNVNaVzVrWlhKbGNpNXdjbTkwYjNSNWNHVXVkR0ZpYkdWeWIzY2dQU0JtZFc1amRHbHZiaWhqYjI1MFpXNTBLU0I3WEc0Z0lISmxkSFZ5YmlBblBIUnlQbHhjYmljZ0t5QmpiMjUwWlc1MElDc2dKend2ZEhJK1hGeHVKenRjYm4wN1hHNWNibEpsYm1SbGNtVnlMbkJ5YjNSdmRIbHdaUzUwWVdKc1pXTmxiR3dnUFNCbWRXNWpkR2x2YmloamIyNTBaVzUwTENCbWJHRm5jeWtnZTF4dUlDQjJZWElnZEhsd1pTQTlJR1pzWVdkekxtaGxZV1JsY2lBL0lDZDBhQ2NnT2lBbmRHUW5PMXh1SUNCMllYSWdkR0ZuSUQwZ1pteGhaM011WVd4cFoyNWNiaUFnSUNBL0lDYzhKeUFySUhSNWNHVWdLeUFuSUhOMGVXeGxQVndpZEdWNGRDMWhiR2xuYmpvbklDc2dabXhoWjNNdVlXeHBaMjRnS3lBblhDSStKMXh1SUNBZ0lEb2dKenduSUNzZ2RIbHdaU0FySUNjK0p6dGNiaUFnY21WMGRYSnVJSFJoWnlBcklHTnZiblJsYm5RZ0t5QW5QQzhuSUNzZ2RIbHdaU0FySUNjK1hGeHVKenRjYm4wN1hHNWNiaTh2SUhOd1lXNGdiR1YyWld3Z2NtVnVaR1Z5WlhKY2JsSmxibVJsY21WeUxuQnliM1J2ZEhsd1pTNXpkSEp2Ym1jZ1BTQm1kVzVqZEdsdmJpaDBaWGgwS1NCN1hHNGdJSEpsZEhWeWJpQW5QSE4wY205dVp6NG5JQ3NnZEdWNGRDQXJJQ2M4TDNOMGNtOXVaejRuTzF4dWZUdGNibHh1VW1WdVpHVnlaWEl1Y0hKdmRHOTBlWEJsTG1WdElEMGdablZ1WTNScGIyNG9kR1Y0ZENrZ2UxeHVJQ0J5WlhSMWNtNGdKenhsYlQ0bklDc2dkR1Y0ZENBcklDYzhMMlZ0UGljN1hHNTlPMXh1WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdVkyOWtaWE53WVc0Z1BTQm1kVzVqZEdsdmJpaDBaWGgwS1NCN1hHNGdJSEpsZEhWeWJpQW5QR052WkdVK0p5QXJJSFJsZUhRZ0t5QW5QQzlqYjJSbFBpYzdYRzU5TzF4dVhHNVNaVzVrWlhKbGNpNXdjbTkwYjNSNWNHVXVZbklnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnY21WMGRYSnVJSFJvYVhNdWIzQjBhVzl1Y3k1NGFIUnRiQ0EvSUNjOFluSXZQaWNnT2lBblBHSnlQaWM3WEc1OU8xeHVYRzVTWlc1a1pYSmxjaTV3Y205MGIzUjVjR1V1WkdWc0lEMGdablZ1WTNScGIyNG9kR1Y0ZENrZ2UxeHVJQ0J5WlhSMWNtNGdKenhrWld3K0p5QXJJSFJsZUhRZ0t5QW5QQzlrWld3K0p6dGNibjA3WEc1Y2JsSmxibVJsY21WeUxuQnliM1J2ZEhsd1pTNXNhVzVySUQwZ1puVnVZM1JwYjI0b2FISmxaaXdnZEdsMGJHVXNJSFJsZUhRcElIdGNiaUFnYVdZZ0tIUm9hWE11YjNCMGFXOXVjeTV6WVc1cGRHbDZaU2tnZTF4dUlDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNCMllYSWdjSEp2ZENBOUlHUmxZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDaDFibVZ6WTJGd1pTaG9jbVZtS1NsY2JpQWdJQ0FnSUNBZ0xuSmxjR3hoWTJVb0wxdGVYRngzT2wwdlp5d2dKeWNwWEc0Z0lDQWdJQ0FnSUM1MGIweHZkMlZ5UTJGelpTZ3BPMXh1SUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQW5KenRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLSEJ5YjNRdWFXNWtaWGhQWmlnbmFtRjJZWE5qY21sd2REb25LU0E5UFQwZ01DQjhmQ0J3Y205MExtbHVaR1Y0VDJZb0ozWmljMk55YVhCME9pY3BJRDA5UFNBd0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z0p5YzdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lIWmhjaUJ2ZFhRZ1BTQW5QR0VnYUhKbFpqMWNJaWNnS3lCb2NtVm1JQ3NnSjF3aUp6dGNiaUFnYVdZZ0tIUnBkR3hsS1NCN1hHNGdJQ0FnYjNWMElDczlJQ2NnZEdsMGJHVTlYQ0luSUNzZ2RHbDBiR1VnS3lBblhDSW5PMXh1SUNCOVhHNGdJRzkxZENBclBTQW5QaWNnS3lCMFpYaDBJQ3NnSnp3dllUNG5PMXh1SUNCeVpYUjFjbTRnYjNWME8xeHVmVHRjYmx4dVVtVnVaR1Z5WlhJdWNISnZkRzkwZVhCbExtbHRZV2RsSUQwZ1puVnVZM1JwYjI0b2FISmxaaXdnZEdsMGJHVXNJSFJsZUhRcElIdGNiaUFnZG1GeUlHOTFkQ0E5SUNjOGFXMW5JSE55WXoxY0lpY2dLeUJvY21WbUlDc2dKMXdpSUdGc2REMWNJaWNnS3lCMFpYaDBJQ3NnSjF3aUp6dGNiaUFnYVdZZ0tIUnBkR3hsS1NCN1hHNGdJQ0FnYjNWMElDczlJQ2NnZEdsMGJHVTlYQ0luSUNzZ2RHbDBiR1VnS3lBblhDSW5PMXh1SUNCOVhHNGdJRzkxZENBclBTQjBhR2x6TG05d2RHbHZibk11ZUdoMGJXd2dQeUFuTHo0bklEb2dKejRuTzF4dUlDQnlaWFIxY200Z2IzVjBPMXh1ZlR0Y2JseHVVbVZ1WkdWeVpYSXVjSEp2ZEc5MGVYQmxMblJsZUhRZ1BTQm1kVzVqZEdsdmJpaDBaWGgwS1NCN1hHNGdJSEpsZEhWeWJpQjBaWGgwTzF4dWZUdGNibHh1THlvcVhHNGdLaUJRWVhKemFXNW5JQ1lnUTI5dGNHbHNhVzVuWEc0Z0tpOWNibHh1Wm5WdVkzUnBiMjRnVUdGeWMyVnlLRzl3ZEdsdmJuTXBJSHRjYmlBZ2RHaHBjeTUwYjJ0bGJuTWdQU0JiWFR0Y2JpQWdkR2hwY3k1MGIydGxiaUE5SUc1MWJHdzdYRzRnSUhSb2FYTXViM0IwYVc5dWN5QTlJRzl3ZEdsdmJuTWdmSHdnYldGeWEyVmtMbVJsWm1GMWJIUnpPMXh1SUNCMGFHbHpMbTl3ZEdsdmJuTXVjbVZ1WkdWeVpYSWdQU0IwYUdsekxtOXdkR2x2Ym5NdWNtVnVaR1Z5WlhJZ2ZId2dibVYzSUZKbGJtUmxjbVZ5TzF4dUlDQjBhR2x6TG5KbGJtUmxjbVZ5SUQwZ2RHaHBjeTV2Y0hScGIyNXpMbkpsYm1SbGNtVnlPMXh1SUNCMGFHbHpMbkpsYm1SbGNtVnlMbTl3ZEdsdmJuTWdQU0IwYUdsekxtOXdkR2x2Ym5NN1hHNTlYRzVjYmk4cUtseHVJQ29nVTNSaGRHbGpJRkJoY25ObElFMWxkR2h2WkZ4dUlDb3ZYRzVjYmxCaGNuTmxjaTV3WVhKelpTQTlJR1oxYm1OMGFXOXVLSE55WXl3Z2IzQjBhVzl1Y3l3Z2NtVnVaR1Z5WlhJcElIdGNiaUFnZG1GeUlIQmhjbk5sY2lBOUlHNWxkeUJRWVhKelpYSW9iM0IwYVc5dWN5d2djbVZ1WkdWeVpYSXBPMXh1SUNCeVpYUjFjbTRnY0dGeWMyVnlMbkJoY25ObEtITnlZeWs3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRkJoY25ObElFeHZiM0JjYmlBcUwxeHVYRzVRWVhKelpYSXVjSEp2ZEc5MGVYQmxMbkJoY25ObElEMGdablZ1WTNScGIyNG9jM0pqS1NCN1hHNGdJSFJvYVhNdWFXNXNhVzVsSUQwZ2JtVjNJRWx1YkdsdVpVeGxlR1Z5S0hOeVl5NXNhVzVyY3l3Z2RHaHBjeTV2Y0hScGIyNXpMQ0IwYUdsekxuSmxibVJsY21WeUtUdGNiaUFnZEdocGN5NTBiMnRsYm5NZ1BTQnpjbU11Y21WMlpYSnpaU2dwTzF4dVhHNGdJSFpoY2lCdmRYUWdQU0FuSnp0Y2JpQWdkMmhwYkdVZ0tIUm9hWE11Ym1WNGRDZ3BLU0I3WEc0Z0lDQWdiM1YwSUNzOUlIUm9hWE11ZEc5cktDazdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdiM1YwTzF4dWZUdGNibHh1THlvcVhHNGdLaUJPWlhoMElGUnZhMlZ1WEc0Z0tpOWNibHh1VUdGeWMyVnlMbkJ5YjNSdmRIbHdaUzV1WlhoMElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lISmxkSFZ5YmlCMGFHbHpMblJ2YTJWdUlEMGdkR2hwY3k1MGIydGxibk11Y0c5d0tDazdYRzU5TzF4dVhHNHZLaXBjYmlBcUlGQnlaWFpwWlhjZ1RtVjRkQ0JVYjJ0bGJseHVJQ292WEc1Y2JsQmhjbk5sY2k1d2NtOTBiM1I1Y0dVdWNHVmxheUE5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0J5WlhSMWNtNGdkR2hwY3k1MGIydGxibk5iZEdocGN5NTBiMnRsYm5NdWJHVnVaM1JvSUMwZ01WMGdmSHdnTUR0Y2JuMDdYRzVjYmk4cUtseHVJQ29nVUdGeWMyVWdWR1Y0ZENCVWIydGxibk5jYmlBcUwxeHVYRzVRWVhKelpYSXVjSEp2ZEc5MGVYQmxMbkJoY25ObFZHVjRkQ0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0IyWVhJZ1ltOWtlU0E5SUhSb2FYTXVkRzlyWlc0dWRHVjRkRHRjYmx4dUlDQjNhR2xzWlNBb2RHaHBjeTV3WldWcktDa3VkSGx3WlNBOVBUMGdKM1JsZUhRbktTQjdYRzRnSUNBZ1ltOWtlU0FyUFNBblhGeHVKeUFySUhSb2FYTXVibVY0ZENncExuUmxlSFE3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEdocGN5NXBibXhwYm1VdWIzVjBjSFYwS0dKdlpIa3BPMXh1ZlR0Y2JseHVMeW9xWEc0Z0tpQlFZWEp6WlNCRGRYSnlaVzUwSUZSdmEyVnVYRzRnS2k5Y2JseHVVR0Z5YzJWeUxuQnliM1J2ZEhsd1pTNTBiMnNnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnYzNkcGRHTm9JQ2gwYUdsekxuUnZhMlZ1TG5SNWNHVXBJSHRjYmlBZ0lDQmpZWE5sSUNkemNHRmpaU2M2SUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUFuSnp0Y2JpQWdJQ0I5WEc0Z0lDQWdZMkZ6WlNBbmFISW5PaUI3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpXNWtaWEpsY2k1b2NpZ3BPMXh1SUNBZ0lIMWNiaUFnSUNCallYTmxJQ2RvWldGa2FXNW5Kem9nZTF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnVaR1Z5WlhJdWFHVmhaR2x1WnloY2JpQWdJQ0FnSUNBZ2RHaHBjeTVwYm14cGJtVXViM1YwY0hWMEtIUm9hWE11ZEc5clpXNHVkR1Y0ZENrc1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZEc5clpXNHVaR1Z3ZEdnc1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZEc5clpXNHVkR1Y0ZENrN1hHNGdJQ0FnZlZ4dUlDQWdJR05oYzJVZ0oyTnZaR1VuT2lCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaVzVrWlhKbGNpNWpiMlJsS0hSb2FYTXVkRzlyWlc0dWRHVjRkQ3hjYmlBZ0lDQWdJQ0FnZEdocGN5NTBiMnRsYmk1c1lXNW5MRnh1SUNBZ0lDQWdJQ0IwYUdsekxuUnZhMlZ1TG1WelkyRndaV1FwTzF4dUlDQWdJSDFjYmlBZ0lDQmpZWE5sSUNkMFlXSnNaU2M2SUh0Y2JpQWdJQ0FnSUhaaGNpQm9aV0ZrWlhJZ1BTQW5KMXh1SUNBZ0lDQWdJQ0FzSUdKdlpIa2dQU0FuSjF4dUlDQWdJQ0FnSUNBc0lHbGNiaUFnSUNBZ0lDQWdMQ0J5YjNkY2JpQWdJQ0FnSUNBZ0xDQmpaV3hzWEc0Z0lDQWdJQ0FnSUN3Z1pteGhaM05jYmlBZ0lDQWdJQ0FnTENCcU8xeHVYRzRnSUNBZ0lDQXZMeUJvWldGa1pYSmNiaUFnSUNBZ0lHTmxiR3dnUFNBbkp6dGNiaUFnSUNBZ0lHWnZjaUFvYVNBOUlEQTdJR2tnUENCMGFHbHpMblJ2YTJWdUxtaGxZV1JsY2k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0JtYkdGbmN5QTlJSHNnYUdWaFpHVnlPaUIwY25WbExDQmhiR2xuYmpvZ2RHaHBjeTUwYjJ0bGJpNWhiR2xuYmx0cFhTQjlPMXh1SUNBZ0lDQWdJQ0JqWld4c0lDczlJSFJvYVhNdWNtVnVaR1Z5WlhJdWRHRmliR1ZqWld4c0tGeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdWFXNXNhVzVsTG05MWRIQjFkQ2gwYUdsekxuUnZhMlZ1TG1obFlXUmxjbHRwWFNrc1hHNGdJQ0FnSUNBZ0lDQWdleUJvWldGa1pYSTZJSFJ5ZFdVc0lHRnNhV2R1T2lCMGFHbHpMblJ2YTJWdUxtRnNhV2R1VzJsZElIMWNiaUFnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR2hsWVdSbGNpQXJQU0IwYUdsekxuSmxibVJsY21WeUxuUmhZbXhsY205M0tHTmxiR3dwTzF4dVhHNGdJQ0FnSUNCbWIzSWdLR2tnUFNBd095QnBJRHdnZEdocGN5NTBiMnRsYmk1alpXeHNjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQnliM2NnUFNCMGFHbHpMblJ2YTJWdUxtTmxiR3h6VzJsZE8xeHVYRzRnSUNBZ0lDQWdJR05sYkd3Z1BTQW5KenRjYmlBZ0lDQWdJQ0FnWm05eUlDaHFJRDBnTURzZ2FpQThJSEp2ZHk1c1pXNW5kR2c3SUdvckt5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdObGJHd2dLejBnZEdocGN5NXlaVzVrWlhKbGNpNTBZV0pzWldObGJHd29YRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbWx1YkdsdVpTNXZkWFJ3ZFhRb2NtOTNXMnBkS1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJSHNnYUdWaFpHVnlPaUJtWVd4elpTd2dZV3hwWjI0NklIUm9hWE11ZEc5clpXNHVZV3hwWjI1YmFsMGdmVnh1SUNBZ0lDQWdJQ0FnSUNrN1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0JpYjJSNUlDczlJSFJvYVhNdWNtVnVaR1Z5WlhJdWRHRmliR1Z5YjNjb1kyVnNiQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpXNWtaWEpsY2k1MFlXSnNaU2hvWldGa1pYSXNJR0p2WkhrcE8xeHVJQ0FnSUgxY2JpQWdJQ0JqWVhObElDZGliRzlqYTNGMWIzUmxYM04wWVhKMEp6b2dlMXh1SUNBZ0lDQWdkbUZ5SUdKdlpIa2dQU0FuSnp0Y2JseHVJQ0FnSUNBZ2QyaHBiR1VnS0hSb2FYTXVibVY0ZENncExuUjVjR1VnSVQwOUlDZGliRzlqYTNGMWIzUmxYMlZ1WkNjcElIdGNiaUFnSUNBZ0lDQWdZbTlrZVNBclBTQjBhR2x6TG5SdmF5Z3BPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpXNWtaWEpsY2k1aWJHOWphM0YxYjNSbEtHSnZaSGtwTzF4dUlDQWdJSDFjYmlBZ0lDQmpZWE5sSUNkc2FYTjBYM04wWVhKMEp6b2dlMXh1SUNBZ0lDQWdkbUZ5SUdKdlpIa2dQU0FuSjF4dUlDQWdJQ0FnSUNBc0lHOXlaR1Z5WldRZ1BTQjBhR2x6TG5SdmEyVnVMbTl5WkdWeVpXUTdYRzVjYmlBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG01bGVIUW9LUzUwZVhCbElDRTlQU0FuYkdsemRGOWxibVFuS1NCN1hHNGdJQ0FnSUNBZ0lHSnZaSGtnS3owZ2RHaHBjeTUwYjJzb0tUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WdVpHVnlaWEl1YkdsemRDaGliMlI1TENCdmNtUmxjbVZrS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZMkZ6WlNBbmJHbHpkRjlwZEdWdFgzTjBZWEowSnpvZ2UxeHVJQ0FnSUNBZ2RtRnlJR0p2WkhrZ1BTQW5KenRjYmx4dUlDQWdJQ0FnZDJocGJHVWdLSFJvYVhNdWJtVjRkQ2dwTG5SNWNHVWdJVDA5SUNkc2FYTjBYMmwwWlcxZlpXNWtKeWtnZTF4dUlDQWdJQ0FnSUNCaWIyUjVJQ3M5SUhSb2FYTXVkRzlyWlc0dWRIbHdaU0E5UFQwZ0ozUmxlSFFuWEc0Z0lDQWdJQ0FnSUNBZ1B5QjBhR2x6TG5CaGNuTmxWR1Y0ZENncFhHNGdJQ0FnSUNBZ0lDQWdPaUIwYUdsekxuUnZheWdwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaVzVrWlhKbGNpNXNhWE4wYVhSbGJTaGliMlI1S1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZMkZ6WlNBbmJHOXZjMlZmYVhSbGJWOXpkR0Z5ZENjNklIdGNiaUFnSUNBZ0lIWmhjaUJpYjJSNUlEMGdKeWM3WEc1Y2JpQWdJQ0FnSUhkb2FXeGxJQ2gwYUdsekxtNWxlSFFvS1M1MGVYQmxJQ0U5UFNBbmJHbHpkRjlwZEdWdFgyVnVaQ2NwSUh0Y2JpQWdJQ0FnSUNBZ1ltOWtlU0FyUFNCMGFHbHpMblJ2YXlncE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV5Wlc1a1pYSmxjaTVzYVhOMGFYUmxiU2hpYjJSNUtUdGNiaUFnSUNCOVhHNGdJQ0FnWTJGelpTQW5hSFJ0YkNjNklIdGNiaUFnSUNBZ0lIWmhjaUJvZEcxc0lEMGdJWFJvYVhNdWRHOXJaVzR1Y0hKbElDWW1JQ0YwYUdsekxtOXdkR2x2Ym5NdWNHVmtZVzUwYVdOY2JpQWdJQ0FnSUNBZ1B5QjBhR2x6TG1sdWJHbHVaUzV2ZFhSd2RYUW9kR2hwY3k1MGIydGxiaTUwWlhoMEtWeHVJQ0FnSUNBZ0lDQTZJSFJvYVhNdWRHOXJaVzR1ZEdWNGREdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsYm1SbGNtVnlMbWgwYld3b2FIUnRiQ2s3WEc0Z0lDQWdmVnh1SUNBZ0lHTmhjMlVnSjNCaGNtRm5jbUZ3YUNjNklIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsYm1SbGNtVnlMbkJoY21GbmNtRndhQ2gwYUdsekxtbHViR2x1WlM1dmRYUndkWFFvZEdocGN5NTBiMnRsYmk1MFpYaDBLU2s3WEc0Z0lDQWdmVnh1SUNBZ0lHTmhjMlVnSjNSbGVIUW5PaUI3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1eVpXNWtaWEpsY2k1d1lYSmhaM0poY0dnb2RHaHBjeTV3WVhKelpWUmxlSFFvS1NrN1hHNGdJQ0FnZlZ4dUlDQjlYRzU5TzF4dVhHNHZLaXBjYmlBcUlFaGxiSEJsY25OY2JpQXFMMXh1WEc1bWRXNWpkR2x2YmlCbGMyTmhjR1VvYUhSdGJDd2daVzVqYjJSbEtTQjdYRzRnSUhKbGRIVnliaUJvZEcxc1hHNGdJQ0FnTG5KbGNHeGhZMlVvSVdWdVkyOWtaU0EvSUM4bUtEOGhJejljWEhjck95a3ZaeUE2SUM4bUwyY3NJQ2NtWVcxd095Y3BYRzRnSUNBZ0xuSmxjR3hoWTJVb0x6d3ZaeXdnSnlac2REc25LVnh1SUNBZ0lDNXlaWEJzWVdObEtDOCtMMmNzSUNjbVozUTdKeWxjYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZYQ0l2Wnl3Z0p5WnhkVzkwT3ljcFhHNGdJQ0FnTG5KbGNHeGhZMlVvTHljdlp5d2dKeVlqTXprN0p5azdYRzU5WEc1Y2JtWjFibU4wYVc5dUlIVnVaWE5qWVhCbEtHaDBiV3dwSUh0Y2JseDBMeThnWlhod2JHbGphWFJzZVNCdFlYUmphQ0JrWldOcGJXRnNMQ0JvWlhnc0lHRnVaQ0J1WVcxbFpDQklWRTFNSUdWdWRHbDBhV1Z6SUZ4dUlDQnlaWFIxY200Z2FIUnRiQzV5WlhCc1lXTmxLQzhtS0NNb1B6cGNYR1FyS1h3b1B6b2plRnN3TFRsQkxVWmhMV1pkS3lsOEtEODZYRngzS3lrcE96OHZaeXdnWm5WdVkzUnBiMjRvWHl3Z2Jpa2dlMXh1SUNBZ0lHNGdQU0J1TG5SdlRHOTNaWEpEWVhObEtDazdYRzRnSUNBZ2FXWWdLRzRnUFQwOUlDZGpiMnh2YmljcElISmxkSFZ5YmlBbk9pYzdYRzRnSUNBZ2FXWWdLRzR1WTJoaGNrRjBLREFwSUQwOVBTQW5JeWNwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ1TG1Ob1lYSkJkQ2d4S1NBOVBUMGdKM2duWEc0Z0lDQWdJQ0FnSUQ4Z1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTaHdZWEp6WlVsdWRDaHVMbk4xWW5OMGNtbHVaeWd5S1N3Z01UWXBLVnh1SUNBZ0lDQWdJQ0E2SUZOMGNtbHVaeTVtY205dFEyaGhja052WkdVb0syNHVjM1ZpYzNSeWFXNW5LREVwS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlDY25PMXh1SUNCOUtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2NtVndiR0ZqWlNoeVpXZGxlQ3dnYjNCMEtTQjdYRzRnSUhKbFoyVjRJRDBnY21WblpYZ3VjMjkxY21ObE8xeHVJQ0J2Y0hRZ1BTQnZjSFFnZkh3Z0p5YzdYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaUJ6Wld4bUtHNWhiV1VzSUhaaGJDa2dlMXh1SUNBZ0lHbG1JQ2doYm1GdFpTa2djbVYwZFhKdUlHNWxkeUJTWldkRmVIQW9jbVZuWlhnc0lHOXdkQ2s3WEc0Z0lDQWdkbUZzSUQwZ2RtRnNMbk52ZFhKalpTQjhmQ0IyWVd3N1hHNGdJQ0FnZG1Gc0lEMGdkbUZzTG5KbGNHeGhZMlVvTHloZWZGdGVYRnhiWFNsY1hGNHZaeXdnSnlReEp5azdYRzRnSUNBZ2NtVm5aWGdnUFNCeVpXZGxlQzV5WlhCc1lXTmxLRzVoYldVc0lIWmhiQ2s3WEc0Z0lDQWdjbVYwZFhKdUlITmxiR1k3WEc0Z0lIMDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHNXZiM0FvS1NCN2ZWeHVibTl2Y0M1bGVHVmpJRDBnYm05dmNEdGNibHh1Wm5WdVkzUnBiMjRnYldWeVoyVW9iMkpxS1NCN1hHNGdJSFpoY2lCcElEMGdNVnh1SUNBZ0lDd2dkR0Z5WjJWMFhHNGdJQ0FnTENCclpYazdYRzVjYmlBZ1ptOXlJQ2c3SUdrZ1BDQmhjbWQxYldWdWRITXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0IwWVhKblpYUWdQU0JoY21kMWJXVnVkSE5iYVYwN1hHNGdJQ0FnWm05eUlDaHJaWGtnYVc0Z2RHRnlaMlYwS1NCN1hHNGdJQ0FnSUNCcFppQW9UMkpxWldOMExuQnliM1J2ZEhsd1pTNW9ZWE5QZDI1UWNtOXdaWEowZVM1allXeHNLSFJoY21kbGRDd2dhMlY1S1NrZ2UxeHVJQ0FnSUNBZ0lDQnZZbXBiYTJWNVhTQTlJSFJoY21kbGRGdHJaWGxkTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ2WW1vN1hHNTlYRzVjYmx4dUx5b3FYRzRnS2lCTllYSnJaV1JjYmlBcUwxeHVYRzVtZFc1amRHbHZiaUJ0WVhKclpXUW9jM0pqTENCdmNIUXNJR05oYkd4aVlXTnJLU0I3WEc0Z0lHbG1JQ2hqWVd4c1ltRmpheUI4ZkNCMGVYQmxiMllnYjNCMElEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnYVdZZ0tDRmpZV3hzWW1GamF5a2dlMXh1SUNBZ0lDQWdZMkZzYkdKaFkyc2dQU0J2Y0hRN1hHNGdJQ0FnSUNCdmNIUWdQU0J1ZFd4c08xeHVJQ0FnSUgxY2JseHVJQ0FnSUc5d2RDQTlJRzFsY21kbEtIdDlMQ0J0WVhKclpXUXVaR1ZtWVhWc2RITXNJRzl3ZENCOGZDQjdmU2s3WEc1Y2JpQWdJQ0IyWVhJZ2FHbG5hR3hwWjJoMElEMGdiM0IwTG1ocFoyaHNhV2RvZEZ4dUlDQWdJQ0FnTENCMGIydGxibk5jYmlBZ0lDQWdJQ3dnY0dWdVpHbHVaMXh1SUNBZ0lDQWdMQ0JwSUQwZ01EdGNibHh1SUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0IwYjJ0bGJuTWdQU0JNWlhobGNpNXNaWGdvYzNKakxDQnZjSFFwWEc0Z0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR05oYkd4aVlXTnJLR1VwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEJsYm1ScGJtY2dQU0IwYjJ0bGJuTXViR1Z1WjNSb08xeHVYRzRnSUNBZ2RtRnlJR1J2Ym1VZ1BTQm1kVzVqZEdsdmJpaGxjbklwSUh0Y2JpQWdJQ0FnSUdsbUlDaGxjbklwSUh0Y2JpQWdJQ0FnSUNBZ2IzQjBMbWhwWjJoc2FXZG9kQ0E5SUdocFoyaHNhV2RvZER0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdOaGJHeGlZV05yS0dWeWNpazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSFpoY2lCdmRYUTdYRzVjYmlBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lHOTFkQ0E5SUZCaGNuTmxjaTV3WVhKelpTaDBiMnRsYm5Nc0lHOXdkQ2s3WEc0Z0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNBZ0lHVnljaUE5SUdVN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHOXdkQzVvYVdkb2JHbG5hSFFnUFNCb2FXZG9iR2xuYUhRN1hHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCbGNuSmNiaUFnSUNBZ0lDQWdQeUJqWVd4c1ltRmpheWhsY25JcFhHNGdJQ0FnSUNBZ0lEb2dZMkZzYkdKaFkyc29iblZzYkN3Z2IzVjBLVHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdhV1lnS0NGb2FXZG9iR2xuYUhRZ2ZId2dhR2xuYUd4cFoyaDBMbXhsYm1kMGFDQThJRE1wSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJrYjI1bEtDazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1pHVnNaWFJsSUc5d2RDNW9hV2RvYkdsbmFIUTdYRzVjYmlBZ0lDQnBaaUFvSVhCbGJtUnBibWNwSUhKbGRIVnliaUJrYjI1bEtDazdYRzVjYmlBZ0lDQm1iM0lnS0RzZ2FTQThJSFJ2YTJWdWN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnS0daMWJtTjBhVzl1S0hSdmEyVnVLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBiMnRsYmk1MGVYQmxJQ0U5UFNBblkyOWtaU2NwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0xTMXdaVzVrYVc1bklIeDhJR1J2Ym1Vb0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdhR2xuYUd4cFoyaDBLSFJ2YTJWdUxuUmxlSFFzSUhSdmEyVnVMbXhoYm1jc0lHWjFibU4wYVc5dUtHVnljaXdnWTI5a1pTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaGxjbklwSUhKbGRIVnliaUJrYjI1bEtHVnljaWs3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR052WkdVZ1BUMGdiblZzYkNCOGZDQmpiMlJsSUQwOVBTQjBiMnRsYmk1MFpYaDBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0xTMXdaVzVrYVc1bklIeDhJR1J2Ym1Vb0tUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2RHOXJaVzR1ZEdWNGRDQTlJR052WkdVN1hHNGdJQ0FnSUNBZ0lDQWdkRzlyWlc0dVpYTmpZWEJsWkNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUNBZ0xTMXdaVzVrYVc1bklIeDhJR1J2Ym1Vb0tUdGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0I5S1NoMGIydGxibk5iYVYwcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnlianRjYmlBZ2ZWeHVJQ0IwY25rZ2UxeHVJQ0FnSUdsbUlDaHZjSFFwSUc5d2RDQTlJRzFsY21kbEtIdDlMQ0J0WVhKclpXUXVaR1ZtWVhWc2RITXNJRzl3ZENrN1hHNGdJQ0FnY21WMGRYSnVJRkJoY25ObGNpNXdZWEp6WlNoTVpYaGxjaTVzWlhnb2MzSmpMQ0J2Y0hRcExDQnZjSFFwTzF4dUlDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdaUzV0WlhOellXZGxJQ3M5SUNkY1hHNVFiR1ZoYzJVZ2NtVndiM0owSUhSb2FYTWdkRzhnYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDJOb2Ftb3ZiV0Z5YTJWa0xpYzdYRzRnSUNBZ2FXWWdLQ2h2Y0hRZ2ZId2diV0Z5YTJWa0xtUmxabUYxYkhSektTNXphV3hsYm5RcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlBblBIQStRVzRnWlhKeWIzSWdiMk5qZFhKbFpEbzhMM0ErUEhCeVpUNG5YRzRnSUNBZ0lDQWdJQ3NnWlhOallYQmxLR1V1YldWemMyRm5aU0FySUNjbkxDQjBjblZsS1Z4dUlDQWdJQ0FnSUNBcklDYzhMM0J5WlQ0bk8xeHVJQ0FnSUgxY2JpQWdJQ0IwYUhKdmR5QmxPMXh1SUNCOVhHNTlYRzVjYmk4cUtseHVJQ29nVDNCMGFXOXVjMXh1SUNvdlhHNWNibTFoY210bFpDNXZjSFJwYjI1eklEMWNibTFoY210bFpDNXpaWFJQY0hScGIyNXpJRDBnWm5WdVkzUnBiMjRvYjNCMEtTQjdYRzRnSUcxbGNtZGxLRzFoY210bFpDNWtaV1poZFd4MGN5d2diM0IwS1R0Y2JpQWdjbVYwZFhKdUlHMWhjbXRsWkR0Y2JuMDdYRzVjYm0xaGNtdGxaQzVrWldaaGRXeDBjeUE5SUh0Y2JpQWdaMlp0T2lCMGNuVmxMRnh1SUNCMFlXSnNaWE02SUhSeWRXVXNYRzRnSUdKeVpXRnJjem9nWm1Gc2MyVXNYRzRnSUhCbFpHRnVkR2xqT2lCbVlXeHpaU3hjYmlBZ2MyRnVhWFJwZW1VNklHWmhiSE5sTEZ4dUlDQnpZVzVwZEdsNlpYSTZJRzUxYkd3c1hHNGdJRzFoYm1kc1pUb2dkSEoxWlN4Y2JpQWdjMjFoY25STWFYTjBjem9nWm1Gc2MyVXNYRzRnSUhOcGJHVnVkRG9nWm1Gc2MyVXNYRzRnSUdocFoyaHNhV2RvZERvZ2JuVnNiQ3hjYmlBZ2JHRnVaMUJ5WldacGVEb2dKMnhoYm1jdEp5eGNiaUFnYzIxaGNuUjVjR0Z1ZEhNNklHWmhiSE5sTEZ4dUlDQm9aV0ZrWlhKUWNtVm1hWGc2SUNjbkxGeHVJQ0J5Wlc1a1pYSmxjam9nYm1WM0lGSmxibVJsY21WeUxGeHVJQ0I0YUhSdGJEb2dabUZzYzJWY2JuMDdYRzVjYmk4cUtseHVJQ29nUlhod2IzTmxYRzRnS2k5Y2JseHViV0Z5YTJWa0xsQmhjbk5sY2lBOUlGQmhjbk5sY2p0Y2JtMWhjbXRsWkM1d1lYSnpaWElnUFNCUVlYSnpaWEl1Y0dGeWMyVTdYRzVjYm0xaGNtdGxaQzVTWlc1a1pYSmxjaUE5SUZKbGJtUmxjbVZ5TzF4dVhHNXRZWEpyWldRdVRHVjRaWElnUFNCTVpYaGxjanRjYm0xaGNtdGxaQzVzWlhobGNpQTlJRXhsZUdWeUxteGxlRHRjYmx4dWJXRnlhMlZrTGtsdWJHbHVaVXhsZUdWeUlEMGdTVzVzYVc1bFRHVjRaWEk3WEc1dFlYSnJaV1F1YVc1c2FXNWxUR1Y0WlhJZ1BTQkpibXhwYm1WTVpYaGxjaTV2ZFhSd2RYUTdYRzVjYm0xaGNtdGxaQzV3WVhKelpTQTlJRzFoY210bFpEdGNibHh1YVdZZ0tIUjVjR1Z2WmlCdGIyUjFiR1VnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltSUhSNWNHVnZaaUJsZUhCdmNuUnpJRDA5UFNBbmIySnFaV04wSnlrZ2UxeHVJQ0J0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRzFoY210bFpEdGNibjBnWld4elpTQnBaaUFvZEhsd1pXOW1JR1JsWm1sdVpTQTlQVDBnSjJaMWJtTjBhVzl1SnlBbUppQmtaV1pwYm1VdVlXMWtLU0I3WEc0Z0lHUmxabWx1WlNobWRXNWpkR2x2YmlncElIc2djbVYwZFhKdUlHMWhjbXRsWkRzZ2ZTazdYRzU5SUdWc2MyVWdlMXh1SUNCMGFHbHpMbTFoY210bFpDQTlJRzFoY210bFpEdGNibjFjYmx4dWZTa3VZMkZzYkNobWRXNWpkR2x2YmlncElIdGNiaUFnY21WMGRYSnVJSFJvYVhNZ2ZId2dLSFI1Y0dWdlppQjNhVzVrYjNjZ0lUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2QybHVaRzkzSURvZ1oyeHZZbUZzS1R0Y2JuMG9LU2s3WEc0aVhYMD0iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OXdZWFJvTFdKeWIzZHpaWEpwWm5rdmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnUTI5d2VYSnBaMmgwSUVwdmVXVnVkQ3dnU1c1akxpQmhibVFnYjNSb1pYSWdUbTlrWlNCamIyNTBjbWxpZFhSdmNuTXVYRzR2TDF4dUx5OGdVR1Z5YldsemMybHZiaUJwY3lCb1pYSmxZbmtnWjNKaGJuUmxaQ3dnWm5KbFpTQnZaaUJqYUdGeVoyVXNJSFJ2SUdGdWVTQndaWEp6YjI0Z2IySjBZV2x1YVc1bklHRmNiaTh2SUdOdmNIa2diMllnZEdocGN5QnpiMlowZDJGeVpTQmhibVFnWVhOemIyTnBZWFJsWkNCa2IyTjFiV1Z1ZEdGMGFXOXVJR1pwYkdWeklDaDBhR1ZjYmk4dklGd2lVMjltZEhkaGNtVmNJaWtzSUhSdklHUmxZV3dnYVc0Z2RHaGxJRk52Wm5SM1lYSmxJSGRwZEdodmRYUWdjbVZ6ZEhKcFkzUnBiMjRzSUdsdVkyeDFaR2x1WjF4dUx5OGdkMmwwYUc5MWRDQnNhVzFwZEdGMGFXOXVJSFJvWlNCeWFXZG9kSE1nZEc4Z2RYTmxMQ0JqYjNCNUxDQnRiMlJwWm5rc0lHMWxjbWRsTENCd2RXSnNhWE5vTEZ4dUx5OGdaR2x6ZEhKcFluVjBaU3dnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JSFJvWlNCVGIyWjBkMkZ5WlN3Z1lXNWtJSFJ2SUhCbGNtMXBkRnh1THk4Z2NHVnljMjl1Y3lCMGJ5QjNhRzl0SUhSb1pTQlRiMlowZDJGeVpTQnBjeUJtZFhKdWFYTm9aV1FnZEc4Z1pHOGdjMjhzSUhOMVltcGxZM1FnZEc4Z2RHaGxYRzR2THlCbWIyeHNiM2RwYm1jZ1kyOXVaR2wwYVc5dWN6cGNiaTh2WEc0dkx5QlVhR1VnWVdKdmRtVWdZMjl3ZVhKcFoyaDBJRzV2ZEdsalpTQmhibVFnZEdocGN5QndaWEp0YVhOemFXOXVJRzV2ZEdsalpTQnphR0ZzYkNCaVpTQnBibU5zZFdSbFpGeHVMeThnYVc0Z1lXeHNJR052Y0dsbGN5QnZjaUJ6ZFdKemRHRnVkR2xoYkNCd2IzSjBhVzl1Y3lCdlppQjBhR1VnVTI5bWRIZGhjbVV1WEc0dkwxeHVMeThnVkVoRklGTlBSbFJYUVZKRklFbFRJRkJTVDFaSlJFVkVJRndpUVZNZ1NWTmNJaXdnVjBsVVNFOVZWQ0JYUVZKU1FVNVVXU0JQUmlCQlRsa2dTMGxPUkN3Z1JWaFFVa1ZUVTF4dUx5OGdUMUlnU1UxUVRFbEZSQ3dnU1U1RFRGVkVTVTVISUVKVlZDQk9UMVFnVEVsTlNWUkZSQ0JVVHlCVVNFVWdWMEZTVWtGT1ZFbEZVeUJQUmx4dUx5OGdUVVZTUTBoQlRsUkJRa2xNU1ZSWkxDQkdTVlJPUlZOVElFWlBVaUJCSUZCQlVsUkpRMVZNUVZJZ1VGVlNVRTlUUlNCQlRrUWdUazlPU1U1R1VrbE9SMFZOUlU1VUxpQkpUbHh1THk4Z1RrOGdSVlpGVGxRZ1UwaEJURXdnVkVoRklFRlZWRWhQVWxNZ1QxSWdRMDlRV1ZKSlIwaFVJRWhQVEVSRlVsTWdRa1VnVEVsQlFreEZJRVpQVWlCQlRsa2dRMHhCU1Uwc1hHNHZMeUJFUVUxQlIwVlRJRTlTSUU5VVNFVlNJRXhKUVVKSlRFbFVXU3dnVjBoRlZFaEZVaUJKVGlCQlRpQkJRMVJKVDA0Z1QwWWdRMDlPVkZKQlExUXNJRlJQVWxRZ1QxSmNiaTh2SUU5VVNFVlNWMGxUUlN3Z1FWSkpVMGxPUnlCR1VrOU5MQ0JQVlZRZ1QwWWdUMUlnU1U0Z1EwOU9Ua1ZEVkVsUFRpQlhTVlJJSUZSSVJTQlRUMFpVVjBGU1JTQlBVaUJVU0VWY2JpOHZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRpQlVTRVVnVTA5R1ZGZEJVa1V1WEc1Y2JpOHZJSEpsYzI5c2RtVnpJQzRnWVc1a0lDNHVJR1ZzWlcxbGJuUnpJR2x1SUdFZ2NHRjBhQ0JoY25KaGVTQjNhWFJvSUdScGNtVmpkRzl5ZVNCdVlXMWxjeUIwYUdWeVpWeHVMeThnYlhWemRDQmlaU0J1YnlCemJHRnphR1Z6TENCbGJYQjBlU0JsYkdWdFpXNTBjeXdnYjNJZ1pHVjJhV05sSUc1aGJXVnpJQ2hqT2x4Y0tTQnBiaUIwYUdVZ1lYSnlZWGxjYmk4dklDaHpieUJoYkhOdklHNXZJR3hsWVdScGJtY2dZVzVrSUhSeVlXbHNhVzVuSUhOc1lYTm9aWE1nTFNCcGRDQmtiMlZ6SUc1dmRDQmthWE4wYVc1bmRXbHphRnh1THk4Z2NtVnNZWFJwZG1VZ1lXNWtJR0ZpYzI5c2RYUmxJSEJoZEdoektWeHVablZ1WTNScGIyNGdibTl5YldGc2FYcGxRWEp5WVhrb2NHRnlkSE1zSUdGc2JHOTNRV0p2ZG1WU2IyOTBLU0I3WEc0Z0lDOHZJR2xtSUhSb1pTQndZWFJvSUhSeWFXVnpJSFJ2SUdkdklHRmliM1psSUhSb1pTQnliMjkwTENCZ2RYQmdJR1Z1WkhNZ2RYQWdQaUF3WEc0Z0lIWmhjaUIxY0NBOUlEQTdYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQndZWEowY3k1c1pXNW5kR2dnTFNBeE95QnBJRDQ5SURBN0lHa3RMU2tnZTF4dUlDQWdJSFpoY2lCc1lYTjBJRDBnY0dGeWRITmJhVjA3WEc0Z0lDQWdhV1lnS0d4aGMzUWdQVDA5SUNjdUp5a2dlMXh1SUNBZ0lDQWdjR0Z5ZEhNdWMzQnNhV05sS0drc0lERXBPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9iR0Z6ZENBOVBUMGdKeTR1SnlrZ2UxeHVJQ0FnSUNBZ2NHRnlkSE11YzNCc2FXTmxLR2tzSURFcE8xeHVJQ0FnSUNBZ2RYQXJLenRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFZ3S1NCN1hHNGdJQ0FnSUNCd1lYSjBjeTV6Y0d4cFkyVW9hU3dnTVNrN1hHNGdJQ0FnSUNCMWNDMHRPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJQzh2SUdsbUlIUm9aU0J3WVhSb0lHbHpJR0ZzYkc5M1pXUWdkRzhnWjI4Z1lXSnZkbVVnZEdobElISnZiM1FzSUhKbGMzUnZjbVVnYkdWaFpHbHVaeUF1TG5OY2JpQWdhV1lnS0dGc2JHOTNRV0p2ZG1WU2IyOTBLU0I3WEc0Z0lDQWdabTl5SUNnN0lIVndMUzA3SUhWd0tTQjdYRzRnSUNBZ0lDQndZWEowY3k1MWJuTm9hV1owS0NjdUxpY3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQndZWEowY3p0Y2JuMWNibHh1THk4Z1UzQnNhWFFnWVNCbWFXeGxibUZ0WlNCcGJuUnZJRnR5YjI5MExDQmthWElzSUdKaGMyVnVZVzFsTENCbGVIUmRMQ0IxYm1sNElIWmxjbk5wYjI1Y2JpOHZJQ2R5YjI5MEp5QnBjeUJxZFhOMElHRWdjMnhoYzJnc0lHOXlJRzV2ZEdocGJtY3VYRzUyWVhJZ2MzQnNhWFJRWVhSb1VtVWdQVnh1SUNBZ0lDOWVLRnhjTHo5OEtTaGJYRnh6WEZ4VFhTby9LU2dvUHpwY1hDNTdNU3d5Zlh4YlhseGNMMTByUDN3cEtGeGNMbHRlTGx4Y0wxMHFmQ2twS0Q4NlcxeGNMMTBxS1NRdk8xeHVkbUZ5SUhOd2JHbDBVR0YwYUNBOUlHWjFibU4wYVc5dUtHWnBiR1Z1WVcxbEtTQjdYRzRnSUhKbGRIVnliaUJ6Y0d4cGRGQmhkR2hTWlM1bGVHVmpLR1pwYkdWdVlXMWxLUzV6YkdsalpTZ3hLVHRjYm4wN1hHNWNiaTh2SUhCaGRHZ3VjbVZ6YjJ4MlpTaGJabkp2YlNBdUxpNWRMQ0IwYnlsY2JpOHZJSEJ2YzJsNElIWmxjbk5wYjI1Y2JtVjRjRzl5ZEhNdWNtVnpiMngyWlNBOUlHWjFibU4wYVc5dUtDa2dlMXh1SUNCMllYSWdjbVZ6YjJ4MlpXUlFZWFJvSUQwZ0p5Y3NYRzRnSUNBZ0lDQnlaWE52YkhabFpFRmljMjlzZFhSbElEMGdabUZzYzJVN1hHNWNiaUFnWm05eUlDaDJZWElnYVNBOUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnZ0xTQXhPeUJwSUQ0OUlDMHhJQ1ltSUNGeVpYTnZiSFpsWkVGaWMyOXNkWFJsT3lCcExTMHBJSHRjYmlBZ0lDQjJZWElnY0dGMGFDQTlJQ2hwSUQ0OUlEQXBJRDhnWVhKbmRXMWxiblJ6VzJsZElEb2djSEp2WTJWemN5NWpkMlFvS1R0Y2JseHVJQ0FnSUM4dklGTnJhWEFnWlcxd2RIa2dZVzVrSUdsdWRtRnNhV1FnWlc1MGNtbGxjMXh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdjR0YwYUNBaFBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjBGeVozVnRaVzUwY3lCMGJ5QndZWFJvTG5KbGMyOXNkbVVnYlhWemRDQmlaU0J6ZEhKcGJtZHpKeWs3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2doY0dGMGFDa2dlMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVnpiMngyWldSUVlYUm9JRDBnY0dGMGFDQXJJQ2N2SnlBcklISmxjMjlzZG1Wa1VHRjBhRHRjYmlBZ0lDQnlaWE52YkhabFpFRmljMjlzZFhSbElEMGdjR0YwYUM1amFHRnlRWFFvTUNrZ1BUMDlJQ2N2Snp0Y2JpQWdmVnh1WEc0Z0lDOHZJRUYwSUhSb2FYTWdjRzlwYm5RZ2RHaGxJSEJoZEdnZ2MyaHZkV3hrSUdKbElISmxjMjlzZG1Wa0lIUnZJR0VnWm5Wc2JDQmhZbk52YkhWMFpTQndZWFJvTENCaWRYUmNiaUFnTHk4Z2FHRnVaR3hsSUhKbGJHRjBhWFpsSUhCaGRHaHpJSFJ2SUdKbElITmhabVVnS0cxcFoyaDBJR2hoY0hCbGJpQjNhR1Z1SUhCeWIyTmxjM011WTNka0tDa2dabUZwYkhNcFhHNWNiaUFnTHk4Z1RtOXliV0ZzYVhwbElIUm9aU0J3WVhSb1hHNGdJSEpsYzI5c2RtVmtVR0YwYUNBOUlHNXZjbTFoYkdsNlpVRnljbUY1S0dacGJIUmxjaWh5WlhOdmJIWmxaRkJoZEdndWMzQnNhWFFvSnk4bktTd2dablZ1WTNScGIyNG9jQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQWhJWEE3WEc0Z0lIMHBMQ0FoY21WemIyeDJaV1JCWW5OdmJIVjBaU2t1YW05cGJpZ25MeWNwTzF4dVhHNGdJSEpsZEhWeWJpQW9LSEpsYzI5c2RtVmtRV0p6YjJ4MWRHVWdQeUFuTHljZ09pQW5KeWtnS3lCeVpYTnZiSFpsWkZCaGRHZ3BJSHg4SUNjdUp6dGNibjA3WEc1Y2JpOHZJSEJoZEdndWJtOXliV0ZzYVhwbEtIQmhkR2dwWEc0dkx5QndiM05wZUNCMlpYSnphVzl1WEc1bGVIQnZjblJ6TG01dmNtMWhiR2w2WlNBOUlHWjFibU4wYVc5dUtIQmhkR2dwSUh0Y2JpQWdkbUZ5SUdselFXSnpiMngxZEdVZ1BTQmxlSEJ2Y25SekxtbHpRV0p6YjJ4MWRHVW9jR0YwYUNrc1hHNGdJQ0FnSUNCMGNtRnBiR2x1WjFOc1lYTm9JRDBnYzNWaWMzUnlLSEJoZEdnc0lDMHhLU0E5UFQwZ0p5OG5PMXh1WEc0Z0lDOHZJRTV2Y20xaGJHbDZaU0IwYUdVZ2NHRjBhRnh1SUNCd1lYUm9JRDBnYm05eWJXRnNhWHBsUVhKeVlYa29abWxzZEdWeUtIQmhkR2d1YzNCc2FYUW9KeThuS1N3Z1puVnVZM1JwYjI0b2NDa2dlMXh1SUNBZ0lISmxkSFZ5YmlBaElYQTdYRzRnSUgwcExDQWhhWE5CWW5OdmJIVjBaU2t1YW05cGJpZ25MeWNwTzF4dVhHNGdJR2xtSUNnaGNHRjBhQ0FtSmlBaGFYTkJZbk52YkhWMFpTa2dlMXh1SUNBZ0lIQmhkR2dnUFNBbkxpYzdYRzRnSUgxY2JpQWdhV1lnS0hCaGRHZ2dKaVlnZEhKaGFXeHBibWRUYkdGemFDa2dlMXh1SUNBZ0lIQmhkR2dnS3owZ0p5OG5PMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJQ2hwYzBGaWMyOXNkWFJsSUQ4Z0p5OG5JRG9nSnljcElDc2djR0YwYUR0Y2JuMDdYRzVjYmk4dklIQnZjMmw0SUhabGNuTnBiMjVjYm1WNGNHOXlkSE11YVhOQlluTnZiSFYwWlNBOUlHWjFibU4wYVc5dUtIQmhkR2dwSUh0Y2JpQWdjbVYwZFhKdUlIQmhkR2d1WTJoaGNrRjBLREFwSUQwOVBTQW5MeWM3WEc1OU8xeHVYRzR2THlCd2IzTnBlQ0IyWlhKemFXOXVYRzVsZUhCdmNuUnpMbXB2YVc0Z1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ2RtRnlJSEJoZEdoeklEMGdRWEp5WVhrdWNISnZkRzkwZVhCbExuTnNhV05sTG1OaGJHd29ZWEpuZFcxbGJuUnpMQ0F3S1R0Y2JpQWdjbVYwZFhKdUlHVjRjRzl5ZEhNdWJtOXliV0ZzYVhwbEtHWnBiSFJsY2lod1lYUm9jeXdnWm5WdVkzUnBiMjRvY0N3Z2FXNWtaWGdwSUh0Y2JpQWdJQ0JwWmlBb2RIbHdaVzltSUhBZ0lUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkQmNtZDFiV1Z1ZEhNZ2RHOGdjR0YwYUM1cWIybHVJRzExYzNRZ1ltVWdjM1J5YVc1bmN5Y3BPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnY0R0Y2JpQWdmU2t1YW05cGJpZ25MeWNwS1R0Y2JuMDdYRzVjYmx4dUx5OGdjR0YwYUM1eVpXeGhkR2wyWlNobWNtOXRMQ0IwYnlsY2JpOHZJSEJ2YzJsNElIWmxjbk5wYjI1Y2JtVjRjRzl5ZEhNdWNtVnNZWFJwZG1VZ1BTQm1kVzVqZEdsdmJpaG1jbTl0TENCMGJ5a2dlMXh1SUNCbWNtOXRJRDBnWlhod2IzSjBjeTV5WlhOdmJIWmxLR1p5YjIwcExuTjFZbk4wY2lneEtUdGNiaUFnZEc4Z1BTQmxlSEJ2Y25SekxuSmxjMjlzZG1Vb2RHOHBMbk4xWW5OMGNpZ3hLVHRjYmx4dUlDQm1kVzVqZEdsdmJpQjBjbWx0S0dGeWNpa2dlMXh1SUNBZ0lIWmhjaUJ6ZEdGeWRDQTlJREE3WEc0Z0lDQWdabTl5SUNnN0lITjBZWEowSUR3Z1lYSnlMbXhsYm1kMGFEc2djM1JoY25Rckt5a2dlMXh1SUNBZ0lDQWdhV1lnS0dGeWNsdHpkR0Z5ZEYwZ0lUMDlJQ2NuS1NCaWNtVmhhenRjYmlBZ0lDQjlYRzVjYmlBZ0lDQjJZWElnWlc1a0lEMGdZWEp5TG14bGJtZDBhQ0F0SURFN1hHNGdJQ0FnWm05eUlDZzdJR1Z1WkNBK1BTQXdPeUJsYm1RdExTa2dlMXh1SUNBZ0lDQWdhV1lnS0dGeWNsdGxibVJkSUNFOVBTQW5KeWtnWW5KbFlXczdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLSE4wWVhKMElENGdaVzVrS1NCeVpYUjFjbTRnVzEwN1hHNGdJQ0FnY21WMGRYSnVJR0Z5Y2k1emJHbGpaU2h6ZEdGeWRDd2daVzVrSUMwZ2MzUmhjblFnS3lBeEtUdGNiaUFnZlZ4dVhHNGdJSFpoY2lCbWNtOXRVR0Z5ZEhNZ1BTQjBjbWx0S0daeWIyMHVjM0JzYVhRb0p5OG5LU2s3WEc0Z0lIWmhjaUIwYjFCaGNuUnpJRDBnZEhKcGJTaDBieTV6Y0d4cGRDZ25MeWNwS1R0Y2JseHVJQ0IyWVhJZ2JHVnVaM1JvSUQwZ1RXRjBhQzV0YVc0b1puSnZiVkJoY25SekxteGxibWQwYUN3Z2RHOVFZWEowY3k1c1pXNW5kR2dwTzF4dUlDQjJZWElnYzJGdFpWQmhjblJ6VEdWdVozUm9JRDBnYkdWdVozUm9PMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdhV1lnS0daeWIyMVFZWEowYzF0cFhTQWhQVDBnZEc5UVlYSjBjMXRwWFNrZ2UxeHVJQ0FnSUNBZ2MyRnRaVkJoY25SelRHVnVaM1JvSUQwZ2FUdGNiaUFnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhaaGNpQnZkWFJ3ZFhSUVlYSjBjeUE5SUZ0ZE8xeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ2MyRnRaVkJoY25SelRHVnVaM1JvT3lCcElEd2dabkp2YlZCaGNuUnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnYjNWMGNIVjBVR0Z5ZEhNdWNIVnphQ2duTGk0bktUdGNiaUFnZlZ4dVhHNGdJRzkxZEhCMWRGQmhjblJ6SUQwZ2IzVjBjSFYwVUdGeWRITXVZMjl1WTJGMEtIUnZVR0Z5ZEhNdWMyeHBZMlVvYzJGdFpWQmhjblJ6VEdWdVozUm9LU2s3WEc1Y2JpQWdjbVYwZFhKdUlHOTFkSEIxZEZCaGNuUnpMbXB2YVc0b0p5OG5LVHRjYm4wN1hHNWNibVY0Y0c5eWRITXVjMlZ3SUQwZ0p5OG5PMXh1Wlhod2IzSjBjeTVrWld4cGJXbDBaWElnUFNBbk9pYzdYRzVjYm1WNGNHOXlkSE11WkdseWJtRnRaU0E5SUdaMWJtTjBhVzl1S0hCaGRHZ3BJSHRjYmlBZ2RtRnlJSEpsYzNWc2RDQTlJSE53YkdsMFVHRjBhQ2h3WVhSb0tTeGNiaUFnSUNBZ0lISnZiM1FnUFNCeVpYTjFiSFJiTUYwc1hHNGdJQ0FnSUNCa2FYSWdQU0J5WlhOMWJIUmJNVjA3WEc1Y2JpQWdhV1lnS0NGeWIyOTBJQ1ltSUNGa2FYSXBJSHRjYmlBZ0lDQXZMeUJPYnlCa2FYSnVZVzFsSUhkb1lYUnpiMlYyWlhKY2JpQWdJQ0J5WlhSMWNtNGdKeTRuTzF4dUlDQjlYRzVjYmlBZ2FXWWdLR1JwY2lrZ2UxeHVJQ0FnSUM4dklFbDBJR2hoY3lCaElHUnBjbTVoYldVc0lITjBjbWx3SUhSeVlXbHNhVzVuSUhOc1lYTm9YRzRnSUNBZ1pHbHlJRDBnWkdseUxuTjFZbk4wY2lnd0xDQmthWEl1YkdWdVozUm9JQzBnTVNrN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2NtOXZkQ0FySUdScGNqdGNibjA3WEc1Y2JseHVaWGh3YjNKMGN5NWlZWE5sYm1GdFpTQTlJR1oxYm1OMGFXOXVLSEJoZEdnc0lHVjRkQ2tnZTF4dUlDQjJZWElnWmlBOUlITndiR2wwVUdGMGFDaHdZWFJvS1ZzeVhUdGNiaUFnTHk4Z1ZFOUVUem9nYldGclpTQjBhR2x6SUdOdmJYQmhjbWx6YjI0Z1kyRnpaUzFwYm5ObGJuTnBkR2wyWlNCdmJpQjNhVzVrYjNkelAxeHVJQ0JwWmlBb1pYaDBJQ1ltSUdZdWMzVmljM1J5S0MweElDb2daWGgwTG14bGJtZDBhQ2tnUFQwOUlHVjRkQ2tnZTF4dUlDQWdJR1lnUFNCbUxuTjFZbk4wY2lnd0xDQm1MbXhsYm1kMGFDQXRJR1Y0ZEM1c1pXNW5kR2dwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJtTzF4dWZUdGNibHh1WEc1bGVIQnZjblJ6TG1WNGRHNWhiV1VnUFNCbWRXNWpkR2x2Ymlod1lYUm9LU0I3WEc0Z0lISmxkSFZ5YmlCemNHeHBkRkJoZEdnb2NHRjBhQ2xiTTEwN1hHNTlPMXh1WEc1bWRXNWpkR2x2YmlCbWFXeDBaWElnS0hoekxDQm1LU0I3WEc0Z0lDQWdhV1lnS0hoekxtWnBiSFJsY2lrZ2NtVjBkWEp1SUhoekxtWnBiSFJsY2lobUtUdGNiaUFnSUNCMllYSWdjbVZ6SUQwZ1cxMDdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQjRjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWmloNGMxdHBYU3dnYVN3Z2VITXBLU0J5WlhNdWNIVnphQ2g0YzF0cFhTazdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ5WlhNN1hHNTlYRzVjYmk4dklGTjBjbWx1Wnk1d2NtOTBiM1I1Y0dVdWMzVmljM1J5SUMwZ2JtVm5ZWFJwZG1VZ2FXNWtaWGdnWkc5dUozUWdkMjl5YXlCcGJpQkpSVGhjYm5aaGNpQnpkV0p6ZEhJZ1BTQW5ZV0luTG5OMVluTjBjaWd0TVNrZ1BUMDlJQ2RpSjF4dUlDQWdJRDhnWm5WdVkzUnBiMjRnS0hOMGNpd2djM1JoY25Rc0lHeGxiaWtnZXlCeVpYUjFjbTRnYzNSeUxuTjFZbk4wY2loemRHRnlkQ3dnYkdWdUtTQjlYRzRnSUNBZ09pQm1kVzVqZEdsdmJpQW9jM1J5TENCemRHRnlkQ3dnYkdWdUtTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoemRHRnlkQ0E4SURBcElITjBZWEowSUQwZ2MzUnlMbXhsYm1kMGFDQXJJSE4wWVhKME8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2MzUnlMbk4xWW5OMGNpaHpkR0Z5ZEN3Z2JHVnVLVHRjYmlBZ0lDQjlYRzQ3WEc0aVhYMD0iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoWydzdGF0ZW1hbiddLCBmYWN0b3J5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XHJcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXHJcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGF0ZW1hbicpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcclxuICAgICAgICByb290LnJlc3RhdGUgPSBmYWN0b3J5KCByb290LlN0YXRlTWFuKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoU3RhdGVNYW4pIHtcclxuXHJcbiAgdmFyIF8gPSBTdGF0ZU1hbi51dGlsO1xyXG5cclxuXHJcbiAgLy8gZ2V0IGFsbCBzdGF0ZSBtYXRjaCB0aGUgcGF0dGVyblxyXG4gIGZ1bmN0aW9uIGdldE1hdGNoU3RhdGVzKHN0YXRlbWFuLCBwYXR0ZXJuKXtcclxuICAgIHZhciBjdXJyZW50ID0gc3RhdGVtYW47XHJcbiAgICB2YXIgYWxsU3RhdGVzID0gW107XHJcblxyXG4gICAgdmFyIGN1cnJlbnRTdGF0ZXMgPSBjdXJyZW50Ll9zdGF0ZXM7XHJcblxyXG4gICAgZm9yKHZhciBpIGluIGN1cnJlbnRTdGF0ZXMpe1xyXG4gICAgICB2YXIgc3RhdGUgPSBjdXJyZW50U3RhdGVzW2ldO1xyXG4gICAgICBpZihwYXR0ZXJuLnRlc3Qoc3RhdGUuc3RhdGVOYW1lKSkgYWxsU3RhdGVzLnB1c2goIHN0YXRlICk7XHJcbiAgICAgIGlmKHN0YXRlLl9zdGF0ZXMpIGFsbFN0YXRlcyA9IGFsbFN0YXRlcy5jb25jYXQoZ2V0TWF0Y2hTdGF0ZXMoIHN0YXRlLCBwYXR0ZXJuKSlcclxuICAgIH1cclxuICAgIHJldHVybiBhbGxTdGF0ZXNcclxuICB9XHJcblxyXG4gIHZhciByZXN0YXRlID0gZnVuY3Rpb24ob3B0aW9uKXtcclxuICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcclxuICAgIHZhciBzdGF0ZW1hbiA9IG9wdGlvbi5zdGF0ZW1hbiB8fCBuZXcgU3RhdGVNYW4ob3B0aW9uKTtcclxuICAgIHZhciBwcmVTdGF0ZSA9IHN0YXRlbWFuLnN0YXRlO1xyXG4gICAgdmFyIEJhc2VDb21wb25lbnQgPSBvcHRpb24uQ29tcG9uZW50O1xyXG4gICAgdmFyIGdsb2JhbFZpZXcgPSBvcHRpb24udmlldyB8fCBkb2N1bWVudC5ib2R5O1xyXG5cclxuICAgIHZhciBmaWx0ZXJzID0ge1xyXG4gICAgICBlbmNvZGU6IGZ1bmN0aW9uKHZhbHVlLCBwYXJhbSl7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlbWFuLmhpc3RvcnkucHJlZml4ICsgKHN0YXRlbWFuLmVuY29kZSh2YWx1ZSwgcGFyYW0gfHwge30pIHx8IFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVtYW4uc3RhdGUgPSBmdW5jdGlvbihuYW1lLCBDb21wb25lbnQsIGNvbmZpZyl7XHJcbiAgICAgIGlmKHR5cGVvZiBjb25maWcgPT09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIGNvbmZpZyA9IHt1cmw6IGNvbmZpZ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgIC8vIFVzZSBnbG9iYWwgb3B0aW9uLnJlYnVpbGQgaWYgY29uZmlnLnJlYnVpbGQgaXMgbm90IGRlZmluZWQuXHJcbiAgICAgIGlmKGNvbmZpZy5yZWJ1aWxkID09PSB1bmRlZmluZWQpIGNvbmZpZy5yZWJ1aWxkID0gb3B0aW9uLnJlYnVpbGQ7XHJcblxyXG4gICAgICBpZighQ29tcG9uZW50KSByZXR1cm4gcHJlU3RhdGUuY2FsbChzdGF0ZW1hbiwgbmFtZSk7XHJcblxyXG4gICAgICBpZihCYXNlQ29tcG9uZW50KXtcclxuICAgICAgICAvLyAxLiByZWd1bGFyIHRlbXBsYXRlIG9yIHBhcnNlZCBhc3RcclxuICAgICAgICBpZih0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIENvbXBvbmVudCApKXtcclxuICAgICAgICAgIENvbXBvbmVudCA9IEJhc2VDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgICAgICAgICAgdGVtcGxhdGU6IENvbXBvbmVudFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMi4gaXQgYW4gT2JqZWN0LCBidXQgbmVlZCByZWd1bGFyaWZ5XHJcbiAgICAgICAgaWYodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQucmVndWxhcmlmeSApe1xyXG4gICAgICAgICAgQ29tcG9uZW50ID0gQmFzZUNvbXBvbmVudC5leHRlbmQoIENvbXBvbmVudCApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gMy4gZHVjayBjaGVjayBpcyBhIFJlZ3VsYXIgQ29tcG9uZW50XHJcbiAgICAgIGlmKCBDb21wb25lbnQuZXh0ZW5kICYmIENvbXBvbmVudC5fX2FmdGVyX18gKXtcclxuXHJcbiAgICAgICAgaWYoIUNvbXBvbmVudC5maWx0ZXIoXCJlbmNvZGVcIikpe1xyXG4gICAgICAgICAgQ29tcG9uZW50LmZpbHRlcihmaWx0ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgICAgY29tcG9uZW50OiBudWxsLFxyXG5cclxuICAgICAgICAgIC8vIEBUT0RPOlxyXG4gICAgICAgICAgY2FuVXBkYXRlOiBmdW5jdGlvbihvcHRpb24pe1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhblVwZGF0ZSA9IHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY29tcG9uZW50LmNhblVwZGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmKCBjYW5VcGRhdGUgKSByZXR1cm4gdGhpcy5jb21wb25lbnQuY2FuVXBkYXRlKG9wdGlvbik7XHJcbiAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICBjYW5MZWF2ZTogZnVuY3Rpb24ob3B0aW9uKXtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgY2FuTGVhdmUgPSB0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmNvbXBvbmVudC5jYW5MZWF2ZTtcclxuXHJcbiAgICAgICAgICAgIGlmKCBjYW5MZWF2ZSApIHJldHVybiB0aGlzLmNvbXBvbmVudC5jYW5MZWF2ZShvcHRpb24pO1xyXG5cclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgY2FuRW50ZXI6IGZ1bmN0aW9uKCBvcHRpb24gKXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7ICRwYXJhbTogb3B0aW9uLnBhcmFtIH0sXHJcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIG5vdCBleGlzdCBvciByZXF1aXJlZCB0byBiZSByZWJ1aWxkZWQgd2hlbiBlbnRlcmluZy5cclxuICAgICAgICAgICAgICBub0NvbXBvbmVudCA9ICFjb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgdmlldztcclxuXHJcbiAgICAgICAgICAgIGlmKG5vQ29tcG9uZW50KXtcclxuXHJcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcblxyXG4gICAgICAgICAgICAgICAgJHN0YXRlOiBzdGF0ZW1hbixcclxuXHJcbiAgICAgICAgICAgICAgICAkc3RhdGVOYW1lOiBuYW1lLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogbm90aWZ5IG90aGVyIG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzdGF0ZU5hbWUgbW9kdWxlJ3Mgc3RhdGVOYW1lXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgIHlvdSBjYW4gcGFzcyB3aWxkY2FyZCgqKSBmb3IgXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICBcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge1doYXRldmVyfSBwYXJhbSAgIGV2ZW50IHBhcmFtXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IHRoaXMgXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICRub3RpZnk6IGZ1bmN0aW9uKHN0YXRlTmFtZSwgdHlwZSwgcGFyYW0pe1xyXG5cclxuICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4sIGV2ZW50T2JqLCBzdGF0ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmKCFzdGF0ZU5hbWUpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmKH5zdGF0ZU5hbWUuaW5kZXhPZignKicpKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJy4nLCAnXFxcXC4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwqXFwqfFxcKi8sIGZ1bmN0aW9uKGNhcCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FwID09PSAnKionKSByZXR1cm4gJy4qJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiAnW14uXSonO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdldE1hdGNoU3RhdGVzLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYoc3RhdGUuY29tcG9uZW50KSBzdGF0ZS5jb21wb25lbnQuJGVtaXQodHlwZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbTogcGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBzdGF0ZS5zdGF0ZU5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVtYW4uc3RhdGUoc3RhdGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZighc3RhdGUgfHwgIXN0YXRlLmNvbXBvbmVudCkgcmV0dXJuIFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBvbmVudC4kZW1pdCh0eXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbTogcGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdG86IHN0YXRlTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNhbkVudGVyID0gdGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQuY2FuRW50ZXI7XHJcblxyXG4gICAgICAgICAgICBpZiggY2FuRW50ZXIgKSByZXR1cm4gdGhpcy5jb21wb25lbnQuY2FuRW50ZXIob3B0aW9uKTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKCBvcHRpb24gKXtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7ICRwYXJhbTogb3B0aW9uLnBhcmFtIH07XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LCB2aWV3O1xyXG5cclxuICAgICAgICAgICAgaWYoIWNvbXBvbmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgXy5leHRlbmQoY29tcG9uZW50LmRhdGEsIGRhdGEsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgaWYocGFyZW50LmNvbXBvbmVudCl7XHJcbiAgICAgICAgICAgICAgdmlldyA9IHBhcmVudC5jb21wb25lbnQuJHJlZnMudmlldztcclxuICAgICAgICAgICAgICBpZighdmlldykgdGhyb3cgdGhpcy5wYXJlbnQubmFtZSArIFwiIHNob3VsZCBoYXZlIGEgZWxlbWVudCB3aXRoIFtyZWY9dmlld11cIjtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgdmlldyA9IGdsb2JhbFZpZXc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbXBvbmVudC4kaW5qZWN0KHZpZXcpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tcG9uZW50LmVudGVyICYmIGNvbXBvbmVudC5lbnRlcihvcHRpb24pO1xyXG5cclxuICAgICAgICAgICAgY29tcG9uZW50LiR1cGRhdGUoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICBjb21wb25lbnQuJG11dGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24oIG9wdGlvbil7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYoIWNvbXBvbmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29tcG9uZW50LmxlYXZlICYmIGNvbXBvbmVudC5sZWF2ZShvcHRpb24pO1xyXG4gICAgICAgICAgICBpZiggY29uZmlnLnJlYnVpbGQpe1xyXG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgY29tcG9uZW50LiRpbmplY3QoZmFsc2UpO1xyXG4gICAgICAgICAgICBjb21wb25lbnQuJG11dGUodHJ1ZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihvcHRpb24pe1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGlmKCFjb21wb25lbnQpIHJldHVybjtcclxuICAgICAgICAgICAgY29tcG9uZW50LnVwZGF0ZSAmJiBjb21wb25lbnQudXBkYXRlKG9wdGlvbik7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC4kdXBkYXRlKHtcclxuICAgICAgICAgICAgICAkcGFyYW06IG9wdGlvbi5wYXJhbVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXy5leHRlbmQoc3RhdGUsIGNvbmZpZyB8fCB7fSk7XHJcblxyXG4gICAgICAgIHByZVN0YXRlLmNhbGwoc3RhdGVtYW4sIG5hbWUsIHN0YXRlKTtcclxuXHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHByZVN0YXRlLmNhbGwoc3RhdGVtYW4sIG5hbWUsIENvbXBvbmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVtYW47XHJcbiAgfVxyXG5cclxuICByZXN0YXRlLlN0YXRlTWFuID0gU3RhdGVNYW47XHJcblxyXG4gIHJldHVybiByZXN0YXRlO1xyXG5cclxufSkpO1xyXG4iLCJcbm1vZHVsZS5leHBvcnRzID0ge1xuICAnQkVHSU4nOiAneycsXG4gICdFTkQnOiAnfScsXG4gICdQUkVDT01QSUxFJzogZmFsc2Vcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ0NPTVBPTkVOVF9UWVBFJzogMSxcbiAgJ0VMRU1FTlRfVFlQRSc6IDIsXG4gICdFUlJPUic6IHtcbiAgICAnVU5NQVRDSEVEX0FTVCc6IDEwMVxuICB9LFxuICBcIk1TR1wiOiB7XG4gICAgMTAxOiBcIlVubWF0Y2hlZCBhc3QgYW5kIG1vdW50Tm9kZSwgcmVwb3J0IGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWd1bGFyanMvcmVndWxhci9pc3N1ZXNcIlxuICB9LFxuICAnTkFNRVNQQUNFJzoge1xuICAgIGh0bWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sXG4gICdPUFRJT05TJzoge1xuICAgICdTVEFCTEVfSU5JVCc6IHsgc3RhYmxlOiAhMCwgaW5pdDogITAgfSxcbiAgICAnRk9SQ0VfSU5JVCc6IHsgZm9yY2U6ICEwLCBpbml0OiAhMCB9LFxuICAgICdTVEFCTEUnOiB7c3RhYmxlOiAhMH0sXG4gICAgJ0lOSVQnOiB7IGluaXQ6ICEwIH0sXG4gICAgJ1NZTkMnOiB7IHN5bmM6ICEwIH0sXG4gICAgJ0ZPUkNFJzogeyBmb3JjZTogITAgfVxuICB9XG59XG4iLCJ2YXIgLy8gcGFja2FnZXNcbiAgXyA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuIGFuaW1hdGUgPSByZXF1aXJlKFwiLi4vaGVscGVyL2FuaW1hdGVcIiksXG4gZG9tID0gcmVxdWlyZShcIi4uL2RvbVwiKSxcbiBSZWd1bGFyID0gcmVxdWlyZShcIi4uL3JlbmRlci9jbGllbnRcIik7XG5cblxudmFyIC8vIHZhcmlhYmxlc1xuICByQ2xhc3NOYW1lID0gL15bLVxcd10rKFxcc1stXFx3XSspKiQvLFxuICByQ29tbWFTZXAgPSAvW1xcclxcblxcZiBdKixbXFxyXFxuXFxmIF0qKD89XFx3K1xcOikvLCAvLyAgZG9udCBzcGxpdCBjb21tYSBpbiAgRXhwcmVzc2lvblxuICByU3R5bGVzID0gL15cXHsuKlxcfSQvLCAvLyAgZm9yIFNpbXBpbGZ5XG4gIHJTcGFjZSA9IC9cXHMrLywgLy8gIGZvciBTaW1waWxmeVxuICBXSEVOX0NPTU1BTkQgPSBcIndoZW5cIixcbiAgRVZFTlRfQ09NTUFORCA9IFwib25cIixcbiAgVEhFTl9DT01NQU5EID0gXCJ0aGVuXCI7XG5cbi8qKlxuICogQW5pbWF0aW9uIFBsdWdpblxuICogQHBhcmFtIHtDb21wb25lbnR9IENvbXBvbmVudCBcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNlZWQodHlwZSl7XG5cbiAgdmFyIHN0ZXBzID0gW10sIGN1cnJlbnQgPSAwLCBjYWxsYmFjayA9IF8ubm9vcDtcbiAgdmFyIGtleTtcblxuICB2YXIgb3V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKGNiKXtcbiAgICAgIGtleSA9IF8udWlkKCk7XG4gICAgICBpZih0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBjYjtcbiAgICAgIGlmKGN1cnJlbnQ+IDAgKXtcbiAgICAgICAgY3VycmVudCA9IDAgO1xuICAgICAgfWVsc2V7XG4gICAgICAgIG91dC5zdGVwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0LmNvbXBlbGV0ZTtcbiAgICB9LFxuICAgIGNvbXBlbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgIGtleSA9IG51bGw7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgY2FsbGJhY2sgPSBfLm5vb3A7XG4gICAgICBjdXJyZW50ID0gMDtcbiAgICB9LFxuICAgIHN0ZXA6IGZ1bmN0aW9uKCl7XG4gICAgICBpZihzdGVwc1tjdXJyZW50XSkgc3RlcHNbY3VycmVudCBdKCBvdXQuZG9uZS5iaW5kKG91dCwga2V5KSApO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24ocGtleSl7XG4gICAgICBpZihwa2V5ICE9PSBrZXkpIHJldHVybjsgLy8gbWVhbnMgdGhlIGxvb3AgaXMgZG93blxuICAgICAgaWYoIGN1cnJlbnQgPCBzdGVwcy5sZW5ndGggLSAxICkge1xuICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgIG91dC5zdGVwKCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgb3V0LmNvbXBlbGV0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHVzaDogZnVuY3Rpb24oc3RlcCl7XG4gICAgICBzdGVwcy5wdXNoKHN0ZXApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuUmVndWxhci5fYWRkUHJvdG9Jbmhlcml0Q2FjaGUoXCJhbmltYXRpb25cIilcblxuXG4vLyBidWlsdGluIGFuaW1hdGlvblxuUmVndWxhci5hbmltYXRpb24oe1xuICBcIndhaXRcIjogZnVuY3Rpb24oIHN0ZXAgKXtcbiAgICB2YXIgdGltZW91dCA9IHBhcnNlSW50KCBzdGVwLnBhcmFtICkgfHwgMFxuICAgIHJldHVybiBmdW5jdGlvbihkb25lKXtcbiAgICAgIC8vIF8ubG9nKFwiZGVsYXkgXCIgKyB0aW1lb3V0KVxuICAgICAgc2V0VGltZW91dCggZG9uZSwgdGltZW91dCApO1xuICAgIH1cbiAgfSxcbiAgXCJjbGFzc1wiOiBmdW5jdGlvbihzdGVwKXtcbiAgICB2YXIgdG1wID0gc3RlcC5wYXJhbS5zcGxpdChcIixcIiksXG4gICAgICBjbGFzc05hbWUgPSB0bXBbMF0gfHwgXCJcIixcbiAgICAgIG1vZGUgPSBwYXJzZUludCh0bXBbMV0pIHx8IDE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSl7XG4gICAgICAvLyBfLmxvZyhjbGFzc05hbWUpXG4gICAgICBhbmltYXRlLnN0YXJ0Q2xhc3NBbmltYXRlKCBzdGVwLmVsZW1lbnQsIGNsYXNzTmFtZSAsIGRvbmUsIG1vZGUgKTtcbiAgICB9XG4gIH0sXG4gIFwiY2FsbFwiOiBmdW5jdGlvbihzdGVwKXtcbiAgICB2YXIgZm4gPSB0aGlzLiRleHByZXNzaW9uKHN0ZXAucGFyYW0pLmdldCwgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpe1xuICAgICAgLy8gXy5sb2coc3RlcC5wYXJhbSwgJ2NhbGwnKVxuICAgICAgZm4oc2VsZik7XG4gICAgICBzZWxmLiR1cGRhdGUoKTtcbiAgICAgIGRvbmUoKVxuICAgIH1cbiAgfSxcbiAgXCJlbWl0XCI6IGZ1bmN0aW9uKHN0ZXApe1xuICAgIHZhciBwYXJhbSA9IHN0ZXAucGFyYW07XG4gICAgdmFyIHRtcCA9IHBhcmFtLnNwbGl0KFwiLFwiKSxcbiAgICAgIGV2dCA9IHRtcFswXSB8fCBcIlwiLFxuICAgICAgYXJncyA9IHRtcFsxXT8gdGhpcy4kZXhwcmVzc2lvbih0bXBbMV0pLmdldDogbnVsbDtcblxuICAgIGlmKCFldnQpIHRocm93IEVycm9yKFwieW91IHNob3VkIHNwZWNpZmllZCBhIGV2ZW50bmFtZSBpbiBlbWl0IGNvbW1hbmRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpe1xuICAgICAgc2VsZi4kZW1pdChldnQsIGFyZ3M/IGFyZ3Moc2VsZikgOiB1bmRlZmluZWQpO1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcbiAgLy8gc3R5bGU6IGxlZnQgezEwfXB4LFxuICBzdHlsZTogZnVuY3Rpb24oc3RlcCl7XG4gICAgdmFyIHN0eWxlcyA9IHt9LCBcbiAgICAgIHBhcmFtID0gc3RlcC5wYXJhbSxcbiAgICAgIHBhaXJzID0gcGFyYW0uc3BsaXQoXCIsXCIpLCB2YWxpZDtcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpe1xuICAgICAgcGFpciA9IHBhaXIudHJpbSgpO1xuICAgICAgaWYocGFpcil7XG4gICAgICAgIHZhciB0bXAgPSBwYWlyLnNwbGl0KCByU3BhY2UgKSxcbiAgICAgICAgICBuYW1lID0gdG1wLnNoaWZ0KCksXG4gICAgICAgICAgdmFsdWUgPSB0bXAuam9pbihcIiBcIik7XG5cbiAgICAgICAgaWYoICFuYW1lIHx8ICF2YWx1ZSApIHRocm93IEVycm9yKFwiaW52YWxpZCBzdHlsZSBpbiBjb21tYW5kOiBzdHlsZVwiKTtcbiAgICAgICAgc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpe1xuICAgICAgaWYodmFsaWQpe1xuICAgICAgICBhbmltYXRlLnN0YXJ0U3R5bGVBbmltYXRlKHN0ZXAuZWxlbWVudCwgc3R5bGVzLCBkb25lKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuXG5cblxuLy8gaGFuY2RsZSB0aGUgci1hbmltYXRpb24gZGlyZWN0aXZlXG4vLyBlbCA6IHRoZSBlbGVtZW50IHRvIHByb2Nlc3Ncbi8vIHZhbHVlOiB0aGUgZGlyZWN0aXZlIHZhbHVlXG5mdW5jdGlvbiBwcm9jZXNzQW5pbWF0ZSggZWxlbWVudCwgdmFsdWUgKXtcbiAgdmFyIENvbXBvbmVudCA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgaWYoXy5pc0V4cHIodmFsdWUpKXtcbiAgICB2YWx1ZSA9IHZhbHVlLmdldCh0aGlzKTtcbiAgfVxuXG4gIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG4gIHZhciBjb21wb3NpdGVzID0gdmFsdWUuc3BsaXQoXCI7XCIpLCBcbiAgICBjb21wb3NpdGUsIGNvbnRleHQgPSB0aGlzLCBzZWVkcyA9IFtdLCBzZWVkLCBkZXN0cm9pZXMgPSBbXSwgZGVzdHJveSxcbiAgICBjb21tYW5kLCBwYXJhbSAsIGN1cnJlbnQgPSAwLCB0bXAsIGFuaW1hdG9yLCBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiByZXNldCggdHlwZSApe1xuICAgIHNlZWQgJiYgc2VlZHMucHVzaCggc2VlZCApXG4gICAgc2VlZCA9IGNyZWF0ZVNlZWQoIHR5cGUgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdoZW5DYWxsYmFjayhzdGFydCwgdmFsdWUpe1xuICAgIGlmKCAhIXZhbHVlICkgc3RhcnQoKVxuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0aW9uRGVzdHJveShlbGVtZW50KXtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgIGVsZW1lbnQub25lbnRlciA9IG51bGw7XG4gICAgICBlbGVtZW50Lm9ubGVhdmUgPSBudWxsO1xuICAgIH0gXG4gIH1cblxuICBmb3IoIHZhciBpID0gMCwgbGVuID0gY29tcG9zaXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApe1xuXG4gICAgY29tcG9zaXRlID0gY29tcG9zaXRlc1tpXTtcbiAgICB0bXAgPSBjb21wb3NpdGUuc3BsaXQoXCI6XCIpO1xuICAgIGNvbW1hbmQgPSB0bXBbMF0gJiYgdG1wWzBdLnRyaW0oKTtcbiAgICBwYXJhbSA9IHRtcFsxXSAmJiB0bXBbMV0udHJpbSgpO1xuXG4gICAgaWYoICFjb21tYW5kICkgY29udGludWU7XG5cbiAgICBpZiggY29tbWFuZCA9PT0gV0hFTl9DT01NQU5EICl7XG4gICAgICByZXNldChcIndoZW5cIik7XG4gICAgICB0aGlzLiR3YXRjaChwYXJhbSwgd2hlbkNhbGxiYWNrLmJpbmQoIHRoaXMsIHNlZWQuc3RhcnQgKSApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYoIGNvbW1hbmQgPT09IEVWRU5UX0NPTU1BTkQpe1xuICAgICAgcmVzZXQocGFyYW0pO1xuICAgICAgaWYoIHBhcmFtID09PSBcImxlYXZlXCIgKXtcbiAgICAgICAgZWxlbWVudC5vbmxlYXZlID0gc2VlZC5zdGFydDtcbiAgICAgICAgZGVzdHJvaWVzLnB1c2goIGFuaW1hdGlvbkRlc3Ryb3koZWxlbWVudCkgKTtcbiAgICAgIH1lbHNlIGlmKCBwYXJhbSA9PT0gXCJlbnRlclwiICl7XG4gICAgICAgIGVsZW1lbnQub25lbnRlciA9IHNlZWQuc3RhcnQ7XG4gICAgICAgIGRlc3Ryb2llcy5wdXNoKCBhbmltYXRpb25EZXN0cm95KGVsZW1lbnQpICk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYoIChcIm9uXCIgKyBwYXJhbSkgaW4gZWxlbWVudCl7IC8vIGlmIGRvbSBoYXZlIHRoZSBldmVudCAsIHdlIHVzZSBkb20gZXZlbnRcbiAgICAgICAgICBkZXN0cm9pZXMucHVzaCh0aGlzLl9oYW5kbGVFdmVudCggZWxlbWVudCwgcGFyYW0sIHNlZWQuc3RhcnQgKSk7XG4gICAgICAgIH1lbHNleyAvLyBvdGhlcndpc2UsIHdlIHVzZSBjb21wb25lbnQgZXZlbnRcbiAgICAgICAgICB0aGlzLiRvbihwYXJhbSwgc2VlZC5zdGFydCk7XG4gICAgICAgICAgZGVzdHJvaWVzLnB1c2godGhpcy4kb2ZmLmJpbmQodGhpcywgcGFyYW0sIHNlZWQuc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdG9yID0gIENvbXBvbmVudC5hbmltYXRpb24oY29tbWFuZCkgXG4gICAgaWYoIGFuaW1hdG9yICYmIHNlZWQgKXtcbiAgICAgIHNlZWQucHVzaChcbiAgICAgICAgYW5pbWF0b3IuY2FsbCh0aGlzLHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGRvbmU6IHNlZWQuZG9uZSxcbiAgICAgICAgICBwYXJhbTogcGFyYW0gXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBFcnJvciggYW5pbWF0b3I/IFwieW91IHNob3VsZCBzdGFydCB3aXRoIGBvbmAgb3IgYGV2ZW50YCBpbiBhbmltYXRpb25cIiA6IChcInVuZGVmaW5lZCBhbmltYXRvciDjgJBcIiArIGNvbW1hbmQgK1wi44CRXCIgKSk7XG4gICAgfVxuICB9XG5cbiAgaWYoZGVzdHJvaWVzLmxlbmd0aCl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICBkZXN0cm9pZXMuZm9yRWFjaChmdW5jdGlvbihkZXN0cm95KXtcbiAgICAgICAgZGVzdHJveSgpO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuXG5SZWd1bGFyLmRpcmVjdGl2ZSggXCJyLWFuaW1hdGlvblwiLCBwcm9jZXNzQW5pbWF0ZSlcblJlZ3VsYXIuZGlyZWN0aXZlKCBcInItYW5pbVwiLCBwcm9jZXNzQW5pbWF0ZSlcblxuIiwiLy8gUmVndWxhclxudmFyIF8gPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vZG9tXCIpO1xudmFyIGFuaW1hdGUgPSByZXF1aXJlKFwiLi4vaGVscGVyL2FuaW1hdGVcIik7XG52YXIgUmVndWxhciA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvY2xpZW50XCIpO1xudmFyIGNvbnN0cyA9IHJlcXVpcmUoXCIuLi9jb25zdFwiKTtcbnZhciBuYW1lc3BhY2VzID0gY29uc3RzLk5BTUVTUEFDRTtcbnZhciBPUFRJT05TID0gY29uc3RzLk9QVElPTlNcbnZhciBTVEFCTEUgPSBPUFRJT05TLlNUQUJMRTtcbnZhciBERUVQX1NUQUJMRSA9IHtkZWVwOiB0cnVlLCBzdGFibGU6IHRydWV9O1xuXG5cblxuXG5yZXF1aXJlKFwiLi9ldmVudC5qc1wiKTtcbnJlcXVpcmUoXCIuL2Zvcm0uanNcIik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4vLyAqKndhcm4qKjogY2xhc3MgaW50ZXBsYXRpb24gd2lsbCBvdmVycmlkZSB0aGlzIGRpcmVjdGl2ZSBcbiAgJ3ItY2xhc3MnOiBmdW5jdGlvbihlbGVtLCB2YWx1ZSl7XG5cbiAgICBpZih0eXBlb2YgdmFsdWU9PT0gJ3N0cmluZycpe1xuICAgICAgdmFsdWUgPSBfLmZpeE9ialN0cih2YWx1ZSlcbiAgICB9XG4gICAgdmFyIGlzTm90SHRtbCA9IGVsZW0ubmFtZXNwYWNlVVJJICYmIGVsZW0ubmFtZXNwYWNlVVJJICE9PSBuYW1lc3BhY2VzLmh0bWwgO1xuICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbihudmFsdWUpe1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IGlzTm90SHRtbD8gZWxlbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk6IGVsZW0uY2xhc3NOYW1lO1xuICAgICAgY2xhc3NOYW1lID0gJyAnKyAoY2xhc3NOYW1lfHwnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsnICc7XG4gICAgICBmb3IodmFyIGkgaW4gbnZhbHVlKSBpZihudmFsdWUuaGFzT3duUHJvcGVydHkoaSkpe1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZSgnICcgKyBpICsgJyAnLCcgJyk7XG4gICAgICAgIGlmKG52YWx1ZVtpXSA9PT0gdHJ1ZSl7XG4gICAgICAgICAgY2xhc3NOYW1lICs9IGkrJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUudHJpbSgpO1xuICAgICAgaWYoaXNOb3RIdG1sKXtcbiAgICAgICAgZG9tLmF0dHIoZWxlbSwgJ2NsYXNzJywgY2xhc3NOYW1lKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lXG4gICAgICB9XG4gICAgfSwgREVFUF9TVEFCTEUpO1xuICB9LFxuICAvLyAqKndhcm4qKjogc3R5bGUgaW50ZXBsYXRpb24gd2lsbCBvdmVycmlkZSB0aGlzIGRpcmVjdGl2ZSBcbiAgJ3Itc3R5bGUnOiBmdW5jdGlvbihlbGVtLCB2YWx1ZSl7XG4gICAgaWYodHlwZW9mIHZhbHVlPT09ICdzdHJpbmcnKXtcbiAgICAgIHZhbHVlID0gXy5maXhPYmpTdHIodmFsdWUpXG4gICAgfVxuICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbihudmFsdWUpe1xuICAgICAgZm9yKHZhciBpIGluIG52YWx1ZSkgaWYobnZhbHVlLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgZG9tLmNzcyhlbGVtLCBpLCBudmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH0sREVFUF9TVEFCTEUpO1xuICB9LFxuICAvLyB3aGVuIGV4cHJlc3Npb24gaXMgZXZhbHVhdGUgdG8gdHJ1ZSwgdGhlIGVsZW0gd2lsbCBhZGQgZGlzcGxheTpub25lXG4gIC8vIEV4YW1wbGU6IDxkaXYgci1oaWRlPXt7aXRlbXMubGVuZ3RoID4gMH19PjwvZGl2PlxuICAnci1oaWRlJzogZnVuY3Rpb24oZWxlbSwgdmFsdWUpe1xuICAgIHZhciBwcmVCb29sID0gbnVsbCwgY29tcGVsZXRlO1xuICAgIGlmKCBfLmlzRXhwcih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKXtcbiAgICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbihudmFsdWUpe1xuICAgICAgICB2YXIgYm9vbCA9ICEhbnZhbHVlO1xuICAgICAgICBpZihib29sID09PSBwcmVCb29sKSByZXR1cm47IFxuICAgICAgICBwcmVCb29sID0gYm9vbDtcbiAgICAgICAgaWYoYm9vbCl7XG4gICAgICAgICAgaWYoZWxlbS5vbmxlYXZlKXtcbiAgICAgICAgICAgIGNvbXBlbGV0ZSA9IGVsZW0ub25sZWF2ZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgICAgICAgICAgICBjb21wZWxldGUgPSBudWxsO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBpZihjb21wZWxldGUpIGNvbXBlbGV0ZSgpO1xuICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgaWYoZWxlbS5vbmVudGVyKXtcbiAgICAgICAgICAgIGVsZW0ub25lbnRlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgU1RBQkxFKTtcbiAgICB9ZWxzZSBpZighIXZhbHVlKXtcbiAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfSxcbiAgJ3ItaHRtbCc6IHtcbiAgICBzc3I6IGZ1bmN0aW9uKHZhbHVlLCB0YWcpe1xuICAgICAgdGFnLmJvZHkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oZWxlbSwgdmFsdWUpe1xuICAgICAgdGhpcy4kd2F0Y2godmFsdWUsIGZ1bmN0aW9uKG52YWx1ZSl7XG4gICAgICAgIG52YWx1ZSA9IG52YWx1ZSB8fCBcIlwiO1xuICAgICAgICBkb20uaHRtbChlbGVtLCBudmFsdWUpXG4gICAgICB9LCB7Zm9yY2U6IHRydWUsIHN0YWJsZTogdHJ1ZX0pO1xuICAgIH1cbiAgfSxcbiAgJ3JlZic6IHtcbiAgICBhY2NlcHQ6IGNvbnN0cy5DT01QT05FTlRfVFlQRSArIGNvbnN0cy5FTEVNRU5UX1RZUEUsXG4gICAgbGluazogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICl7XG4gICAgICB2YXIgcmVmcyA9IHRoaXMuJHJlZnMgfHwgKHRoaXMuJHJlZnMgPSB7fSk7XG4gICAgICB2YXIgY3ZhbDtcbiAgICAgIGlmKF8uaXNFeHByKHZhbHVlKSl7XG4gICAgICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbihudmFsLCBvdmFsKXtcbiAgICAgICAgICBjdmFsID0gbnZhbDtcbiAgICAgICAgICBpZihyZWZzW292YWxdID09PSBlbGVtKSByZWZzW292YWxdID0gbnVsbDtcbiAgICAgICAgICBpZihjdmFsKSByZWZzW2N2YWxdID0gZWxlbTtcbiAgICAgICAgfSwgU1RBQkxFKVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJlZnNbY3ZhbCA9IHZhbHVlXSA9IGVsZW07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgcmVmc1tjdmFsXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblJlZ3VsYXIuZGlyZWN0aXZlKG1vZHVsZS5leHBvcnRzKTtcblxuXG5cblxuXG5cblxuXG5cblxuIiwiLyoqXG4gKiBldmVudCBkaXJlY3RpdmUgIGJ1bmRsZVxuICpcbiAqL1xudmFyIF8gPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vZG9tXCIpO1xudmFyIFJlZ3VsYXIgPSByZXF1aXJlKFwiLi4vcmVuZGVyL2NsaWVudFwiKTtcblxuUmVndWxhci5fYWRkUHJvdG9Jbmhlcml0Q2FjaGUoXCJldmVudFwiKTtcblxuUmVndWxhci5kaXJlY3RpdmUoIC9eb24tXFx3KyQvLCBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgLCBhdHRycykge1xuICBpZiAoICFuYW1lIHx8ICF2YWx1ZSApIHJldHVybjtcbiAgdmFyIHR5cGUgPSBuYW1lLnNwbGl0KFwiLVwiKVsxXTtcbiAgcmV0dXJuIHRoaXMuX2hhbmRsZUV2ZW50KCBlbGVtLCB0eXBlLCB2YWx1ZSwgYXR0cnMgKTtcbn0pO1xuLy8gVE9ETy5cbi8qKlxuLSAkKCdkeCcpLmRlbGVnYXRlKClcbiovXG5SZWd1bGFyLmRpcmVjdGl2ZSggL14oZGVsZWdhdGV8ZGUpLVxcdyskLywgZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuICB2YXIgcm9vdCA9IHRoaXMuJHJvb3Q7XG4gIHZhciBfZGVsZWdhdGVzID0gcm9vdC5fZGVsZWdhdGVzIHx8ICggcm9vdC5fZGVsZWdhdGVzID0ge30gKTtcbiAgaWYgKCAhbmFtZSB8fCAhdmFsdWUgKSByZXR1cm47XG4gIHZhciB0eXBlID0gbmFtZS5zcGxpdChcIi1cIilbMV07XG4gIHZhciBmaXJlID0gXy5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIHZhbHVlLCB0eXBlKTtcblxuICBmdW5jdGlvbiBkZWxlZ2F0ZUV2ZW50KGV2KXtcbiAgICBtYXRjaFBhcmVudChldiwgX2RlbGVnYXRlc1t0eXBlXSwgcm9vdC5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIGlmKCAhX2RlbGVnYXRlc1t0eXBlXSApe1xuICAgIF9kZWxlZ2F0ZXNbdHlwZV0gPSBbXTtcblxuICAgIGlmKHJvb3QucGFyZW50Tm9kZSl7XG4gICAgICBkb20ub24ocm9vdC5wYXJlbnROb2RlLCB0eXBlLCBkZWxlZ2F0ZUV2ZW50KTtcbiAgICB9ZWxzZXtcbiAgICAgIHJvb3QuJG9uKCBcIiRpbmplY3RcIiwgZnVuY3Rpb24oIG5vZGUsIHBvc2l0aW9uLCBwcmVQYXJlbnQgKXtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgaWYoIHByZVBhcmVudCApe1xuICAgICAgICAgIGRvbS5vZmYocHJlUGFyZW50LCB0eXBlLCBkZWxlZ2F0ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZihuZXdQYXJlbnQpIGRvbS5vbih0aGlzLnBhcmVudE5vZGUsIHR5cGUsIGRlbGVnYXRlRXZlbnQpO1xuICAgICAgfSlcbiAgICB9XG4gICAgcm9vdC4kb24oXCIkZGVzdHJveVwiLCBmdW5jdGlvbigpe1xuICAgICAgaWYocm9vdC5wYXJlbnROb2RlKSBkb20ub2ZmKHJvb3QucGFyZW50Tm9kZSwgdHlwZSwgZGVsZWdhdGVFdmVudClcbiAgICAgIF9kZWxlZ2F0ZXNbdHlwZV0gPSBudWxsO1xuICAgIH0pXG4gIH1cbiAgdmFyIGRlbGVnYXRlID0ge1xuICAgIGVsZW1lbnQ6IGVsZW0sXG4gICAgZmlyZTogZmlyZVxuICB9XG4gIF9kZWxlZ2F0ZXNbdHlwZV0ucHVzaCggZGVsZWdhdGUgKTtcblxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGVsZWdhdGVzID0gX2RlbGVnYXRlc1t0eXBlXTtcbiAgICBpZighZGVsZWdhdGVzIHx8ICFkZWxlZ2F0ZXMubGVuZ3RoKSByZXR1cm47XG4gICAgZm9yKCB2YXIgaSA9IDAsIGxlbiA9IGRlbGVnYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApe1xuICAgICAgaWYoIGRlbGVnYXRlc1tpXSA9PT0gZGVsZWdhdGUgKSBkZWxlZ2F0ZXMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuXG5mdW5jdGlvbiBtYXRjaFBhcmVudChldiAsIGRlbGVnYXRlcywgc3RvcCl7XG4gIGlmKCFzdG9wKSByZXR1cm47XG4gIHZhciB0YXJnZXQgPSBldi50YXJnZXQsIHBhaXI7XG4gIHdoaWxlKHRhcmdldCAmJiB0YXJnZXQgIT09IHN0b3Ape1xuICAgIGZvciggdmFyIGkgPSAwLCBsZW4gPSBkZWxlZ2F0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKXtcbiAgICAgIHBhaXIgPSBkZWxlZ2F0ZXNbaV07XG4gICAgICBpZihwYWlyICYmIHBhaXIuZWxlbWVudCA9PT0gdGFyZ2V0KXtcbiAgICAgICAgcGFpci5maXJlKGV2KVxuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxufSIsIi8vIFJlZ3VsYXJcbnZhciBfID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4uL2RvbVwiKTtcbnZhciBPUFRJT05TID0gcmVxdWlyZSgnLi4vY29uc3QnKS5PUFRJT05TXG52YXIgU1RBQkxFID0gT1BUSU9OUy5TVEFCTEU7XG52YXIgaGFzSW5wdXQ7XG52YXIgUmVndWxhciA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvY2xpZW50XCIpO1xuXG52YXIgbW9kZWxIYW5kbGVycyA9IHtcbiAgXCJ0ZXh0XCI6IGluaXRUZXh0LFxuICBcInNlbGVjdFwiOiBpbml0U2VsZWN0LFxuICBcImNoZWNrYm94XCI6IGluaXRDaGVja0JveCxcbiAgXCJyYWRpb1wiOiBpbml0UmFkaW9cbn1cblxuXG4vLyBAVE9ET1xuXG5cbi8vIGF1dG9VcGRhdGUgZGlyZWN0aXZlIGZvciBzZWxlY3QgZWxlbWVudFxuLy8gdG8gZml4IHItbW9kZWwgaXNzdWUgLCB3aGVuIGhhbmRsZSBkeW5hbWljIG9wdGlvbnNcblxuXG4vKipcbiAqIDxzZWxlY3Qgci1tb2RlbD17bmFtZX0+IFxuICogICA8ci1vcHRpb24gdmFsdWU9e3ZhbHVlfSA+PC9yLW9wdGlvbj5cbiAqIDwvc2VsZWN0PlxuICovXG5cblxuLy8gdHdvLXdheSBiaW5kaW5nIHdpdGggci1tb2RlbFxuLy8gd29ya3Mgb24gaW5wdXQsIHRleHRhcmVhLCBjaGVja2JveCwgcmFkaW8sIHNlbGVjdFxuXG5cblJlZ3VsYXIuZGlyZWN0aXZlKFwici1tb2RlbFwiLCB7XG4gIHBhcmFtOiBbJ3Rocm90dGxlJywgJ2xhenknXSxcbiAgbGluazogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lLCBleHRyYSApe1xuICAgIHZhciB0YWcgPSBlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc2lnbiA9IHRhZztcbiAgICBpZihzaWduID09PSBcImlucHV0XCIpIHNpZ24gPSBlbGVtLnR5cGUgfHwgXCJ0ZXh0XCI7XG4gICAgZWxzZSBpZihzaWduID09PSBcInRleHRhcmVhXCIpIHNpZ24gPSBcInRleHRcIjtcbiAgICBpZih0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHZhbHVlID0gdGhpcy4kZXhwcmVzc2lvbih2YWx1ZSk7XG5cbiAgICBpZiggbW9kZWxIYW5kbGVyc1tzaWduXSApIHJldHVybiBtb2RlbEhhbmRsZXJzW3NpZ25dLmNhbGwodGhpcywgZWxlbSwgdmFsdWUsIGV4dHJhKTtcbiAgICBlbHNlIGlmKHRhZyA9PT0gXCJpbnB1dFwiKXtcbiAgICAgIHJldHVybiBtb2RlbEhhbmRsZXJzLnRleHQuY2FsbCh0aGlzLCBlbGVtLCB2YWx1ZSwgZXh0cmEpO1xuICAgIH1cbiAgfVxuICAvL0BUT0RPXG4gIC8vIHNzcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuICAvLyAgIHJldHVybiB2YWx1ZT8gXCJ2YWx1ZT1cIiArIHZhbHVlOiBcIlwiXG4gIC8vIH1cbn0pO1xuXG5cblxuXG5cbi8vIGJpbmRpbmcgPHNlbGVjdD5cblxuZnVuY3Rpb24gaW5pdFNlbGVjdCggZWxlbSwgcGFyc2VkLCBleHRyYSl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdjID0gdGhpcy4kd2F0Y2gocGFyc2VkLCBmdW5jdGlvbihuZXdWYWx1ZSl7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnb3B0aW9uJyk7XG4gICAgZm9yKHZhciBpID0wLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGggOyBpIDwgbGVuOyBpKyspe1xuICAgICAgaWYoY2hpbGRyZW5baV0udmFsdWUgPT0gbmV3VmFsdWUpe1xuICAgICAgICBlbGVtLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIFNUQUJMRSk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlcigpe1xuICAgIHBhcnNlZC5zZXQoc2VsZiwgdGhpcy52YWx1ZSk7XG4gICAgd2MubGFzdCA9IHRoaXMudmFsdWU7XG4gICAgc2VsZi4kdXBkYXRlKCk7XG4gIH1cblxuICBkb20ub24oIGVsZW0sIFwiY2hhbmdlXCIsIGhhbmRsZXIgKTtcbiAgXG4gIGlmKHBhcnNlZC5nZXQoc2VsZikgPT09IHVuZGVmaW5lZCAmJiBlbGVtLnZhbHVlKXtcbiAgICBwYXJzZWQuc2V0KHNlbGYsIGVsZW0udmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlc3Ryb3koKXtcbiAgICBkb20ub2ZmKGVsZW0sIFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xuICB9XG59XG5cbi8vIGlucHV0LHRleHRhcmVhIGJpbmRpbmdcbmZ1bmN0aW9uIGluaXRUZXh0KGVsZW0sIHBhcnNlZCwgZXh0cmEpe1xuICB2YXIgcGFyYW0gPSBleHRyYS5wYXJhbTtcbiAgdmFyIHRocm90dGxlLCBsYXp5ID0gcGFyYW0ubGF6eVxuXG4gIGlmKCd0aHJvdHRsZScgaW4gcGFyYW0pe1xuICAgIC8vIDxpbnB1dCB0aHJvdHRsZSByLW1vZGVsPlxuICAgIGlmKHBhcmFtW3Rocm90dGxlXSA9PT0gdHJ1ZSl7XG4gICAgICB0aHJvdHRsZSA9IDQwMDtcbiAgICB9ZWxzZXtcbiAgICAgIHRocm90dGxlID0gcGFyc2VJbnQocGFyYW0udGhyb3R0bGUgLCAxMClcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB3YyA9IHRoaXMuJHdhdGNoKHBhcnNlZCwgZnVuY3Rpb24obmV3VmFsdWUpe1xuICAgIGlmKGVsZW0udmFsdWUgIT09IG5ld1ZhbHVlKSBlbGVtLnZhbHVlID0gbmV3VmFsdWUgPT0gbnVsbD8gXCJcIjogXCJcIiArIG5ld1ZhbHVlO1xuICB9LCBTVEFCTEUpO1xuXG4gIC8vIEBUT0RPIHRvIGZpeGVkIGV2ZW50XG4gIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KXtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYoZXYudHlwZT09PSdjdXQnIHx8IGV2LnR5cGU9PT0ncGFzdGUnKXtcbiAgICAgIF8ubmV4dFRpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhhdC52YWx1ZVxuICAgICAgICBwYXJzZWQuc2V0KHNlbGYsIHZhbHVlKTtcbiAgICAgICAgd2MubGFzdCA9IHZhbHVlO1xuICAgICAgICBzZWxmLiR1cGRhdGUoKTtcbiAgICAgIH0pXG4gICAgfWVsc2V7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoYXQudmFsdWVcbiAgICAgICAgcGFyc2VkLnNldChzZWxmLCB2YWx1ZSk7XG4gICAgICAgIHdjLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgc2VsZi4kdXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIGlmKHRocm90dGxlICYmICFsYXp5KXtcbiAgICB2YXIgcHJlSGFuZGxlID0gaGFuZGxlciwgdGlkO1xuICAgIGhhbmRsZXIgPSBfLnRocm90dGxlKGhhbmRsZXIsIHRocm90dGxlKTtcbiAgfVxuXG4gIGlmKGhhc0lucHV0ID09PSB1bmRlZmluZWQpe1xuICAgIGhhc0lucHV0ID0gZG9tLm1zaWUgIT09IDkgJiYgXCJvbmlucHV0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICB9XG5cbiAgaWYobGF6eSl7XG4gICAgZG9tLm9uKGVsZW0sICdjaGFuZ2UnLCBoYW5kbGVyKVxuICB9ZWxzZXtcbiAgICBpZiggaGFzSW5wdXQpe1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgaGFuZGxlciApO1xuICAgIH1lbHNle1xuICAgICAgZG9tLm9uKGVsZW0sIFwicGFzdGUga2V5dXAgY3V0IGNoYW5nZVwiLCBoYW5kbGVyKVxuICAgIH1cbiAgfVxuICBpZihwYXJzZWQuZ2V0KHNlbGYpID09PSB1bmRlZmluZWQgJiYgZWxlbS52YWx1ZSl7XG4gICAgIHBhcnNlZC5zZXQoc2VsZiwgZWxlbS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpe1xuICAgIGlmKGxhenkpIHJldHVybiBkb20ub2ZmKGVsZW0sIFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xuICAgIGlmKCBoYXNJbnB1dCApe1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgaGFuZGxlciApO1xuICAgIH1lbHNle1xuICAgICAgZG9tLm9mZihlbGVtLCBcInBhc3RlIGtleXVwIGN1dCBjaGFuZ2VcIiwgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBpbnB1dDpjaGVja2JveCAgYmluZGluZ1xuXG5mdW5jdGlvbiBpbml0Q2hlY2tCb3goZWxlbSwgcGFyc2VkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgd2F0Y2hlciA9IHRoaXMuJHdhdGNoKHBhcnNlZCwgZnVuY3Rpb24obmV3VmFsdWUpe1xuICAgIGRvbS5hdHRyKGVsZW0sICdjaGVja2VkJywgISFuZXdWYWx1ZSk7XG4gIH0sIFNUQUJMRSk7XG5cbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCl7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5jaGVja2VkO1xuICAgIHBhcnNlZC5zZXQoc2VsZiwgdmFsdWUpO1xuICAgIHdhdGNoZXIubGFzdCA9IHZhbHVlO1xuICAgIHNlbGYuJHVwZGF0ZSgpO1xuICB9XG4gIGlmKHBhcnNlZC5zZXQpIGRvbS5vbihlbGVtLCBcImNoYW5nZVwiLCBoYW5kbGVyKVxuXG4gIGlmKHBhcnNlZC5nZXQoc2VsZikgPT09IHVuZGVmaW5lZCl7XG4gICAgcGFyc2VkLnNldChzZWxmLCAhIWVsZW0uY2hlY2tlZCk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZGVzdHJveSgpe1xuICAgIGlmKHBhcnNlZC5zZXQpIGRvbS5vZmYoZWxlbSwgXCJjaGFuZ2VcIiwgaGFuZGxlcilcbiAgfVxufVxuXG5cbi8vIGlucHV0OnJhZGlvIGJpbmRpbmdcblxuZnVuY3Rpb24gaW5pdFJhZGlvKGVsZW0sIHBhcnNlZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdjID0gdGhpcy4kd2F0Y2gocGFyc2VkLCBmdW5jdGlvbiggbmV3VmFsdWUgKXtcbiAgICBpZihuZXdWYWx1ZSA9PSBlbGVtLnZhbHVlKSBlbGVtLmNoZWNrZWQgPSB0cnVlO1xuICAgIGVsc2UgZWxlbS5jaGVja2VkID0gZmFsc2U7XG4gIH0sIFNUQUJMRSk7XG5cblxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKXtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHBhcnNlZC5zZXQoc2VsZiwgdmFsdWUpO1xuICAgIHNlbGYuJHVwZGF0ZSgpO1xuICB9XG4gIGlmKHBhcnNlZC5zZXQpIGRvbS5vbihlbGVtLCBcImNoYW5nZVwiLCBoYW5kbGVyKVxuICAvLyBiZWFjdXNlIG9ubHkgYWZ0ZXIgY29tcGlsZShpbml0KSwgdGhlIGRvbSBzdHJ1Y3RydWUgaXMgZXhzaXQuIFxuICBpZihwYXJzZWQuZ2V0KHNlbGYpID09PSB1bmRlZmluZWQpe1xuICAgIGlmKGVsZW0uY2hlY2tlZCkge1xuICAgICAgcGFyc2VkLnNldChzZWxmLCBlbGVtLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZGVzdHJveSgpe1xuICAgIGlmKHBhcnNlZC5zZXQpIGRvbS5vZmYoZWxlbSwgXCJjaGFuZ2VcIiwgaGFuZGxlcilcbiAgfVxufVxuXG5cblxuIiwiLypqc2hpbnQgLVcwODIgKi8gXG5cbi8vIHRoYW5rcyBmb3IgYW5ndWxhciAmJiBtb290b29scyBmb3Igc29tZSBjb25jaXNlJmNyb3NzLXBsYXRmb3JtICBpbXBsZW1lbnRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gVGhlIE1JVCBMaWNlbnNlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcblxuLy8gLS0tXG4vLyBsaWNlbnNlOiBNSVQtc3R5bGUgbGljZW5zZS4gaHR0cDovL21vb3Rvb2xzLm5ldFxuXG5cbmlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKXtcbiAgXG52YXIgZG9tID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xudmFyIF8gPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbnZhciB0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG52YXIgYWRkRXZlbnQsIHJlbW92ZUV2ZW50O1xudmFyIG5vb3AgPSBmdW5jdGlvbigpe31cblxudmFyIG5hbWVzcGFjZXMgPSBjb25zdHMuTkFNRVNQQUNFO1xuXG5kb20uYm9keSA9IGRvY3VtZW50LmJvZHk7XG5kb20uZG9jID0gZG9jdW1lbnQ7XG5kb20udE5vZGUgPSB0Tm9kZTtcblxuXG4vLyBjYW1lbENhc2VcbnZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiAoc3RyKXtcbiAgcmV0dXJuIChcIlwiICsgc3RyKS5yZXBsYWNlKC8tXFxEL2csIGZ1bmN0aW9uKG1hdGNoKXtcbiAgICByZXR1cm4gbWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5cblxuaWYodE5vZGUuYWRkRXZlbnRMaXN0ZW5lcil7XG4gIGFkZEV2ZW50ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgZm4pIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgfVxuICByZW1vdmVFdmVudCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIGZuKSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSkgXG4gIH1cbn1lbHNle1xuICBhZGRFdmVudCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIGZuKSB7XG4gICAgbm9kZS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICB9XG4gIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgZm4pIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7IFxuICB9XG59XG5cblxuZG9tLm1zaWUgPSBwYXJzZUludCgoL21zaWUgKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgfHwgW10pWzFdKTtcbmlmIChpc05hTihkb20ubXNpZSkpIHtcbiAgZG9tLm1zaWUgPSBwYXJzZUludCgoL3RyaWRlbnRcXC8uKjsgcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgfHwgW10pWzFdKTtcbn1cblxuZG9tLmZpbmQgPSBmdW5jdGlvbihzbCl7XG4gIGlmKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICB0cnl7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzbCk7XG4gICAgfWNhdGNoKGUpe1xuXG4gICAgfVxuICB9XG4gIGlmKHNsLmluZGV4T2YoJyMnKSE9PS0xKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIHNsLnNsaWNlKDEpICk7XG59XG5cblxuZG9tLmluamVjdCA9IGZ1bmN0aW9uKG5vZGUsIHJlZmVyLCBwb3NpdGlvbil7XG5cbiAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbiAgaWYoIW5vZGUpIHJldHVybiA7XG4gIGlmKEFycmF5LmlzQXJyYXkobm9kZSkpe1xuICAgIHZhciB0bXAgPSBub2RlO1xuICAgIG5vZGUgPSBkb20uZnJhZ21lbnQoKTtcbiAgICBmb3IodmFyIGkgPSAwLGxlbiA9IHRtcC5sZW5ndGg7IGkgPCBsZW4gO2krKyl7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRtcFtpXSlcbiAgICB9XG4gIH1cblxuICB2YXIgZmlyc3RDaGlsZCwgbmV4dDtcbiAgc3dpdGNoKHBvc2l0aW9uKXtcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcmVmZXIuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBpZiggZmlyc3RDaGlsZCA9IHJlZmVyLmZpcnN0Q2hpbGQgKXtcbiAgICAgICAgcmVmZXIuaW5zZXJ0QmVmb3JlKCBub2RlLCByZWZlci5maXJzdENoaWxkICk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmVmZXIuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIGlmKCBuZXh0ID0gcmVmZXIubmV4dFNpYmxpbmcgKXtcbiAgICAgICAgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggbm9kZSwgbmV4dCApO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJlZmVyLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICByZWZlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggbm9kZSwgcmVmZXIgKTtcbiAgfVxufVxuXG5cbmRvbS5pZCA9IGZ1bmN0aW9uKGlkKXtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbn1cblxuLy8gY3JlYXRlRWxlbWVudCBcbmRvbS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBucyl7XG4gIGlmKG5zID09PSAnc3ZnJyl7XG4gICAgaWYoIWVudi5zdmcpIHRocm93IEVycm9yKCd0aGUgZW52IG5lZWQgc3ZnIHN1cHBvcnQnKVxuICAgIG5zID0gbmFtZXNwYWNlcy5zdmc7XG4gIH1cbiAgcmV0dXJuICFucz8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0eXBlKTtcbn1cblxuLy8gZG9jdW1lbnRGcmFnbWVudFxuZG9tLmZyYWdtZW50ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn1cblxuXG5cblxudmFyIHNwZWNpYWxBdHRyID0ge1xuICAnY2xhc3MnOiBmdW5jdGlvbihub2RlLCB2YWx1ZSl7XG4gICAgICgnY2xhc3NOYW1lJyBpbiBub2RlICYmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCAgKSkgPyBcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gKHZhbHVlIHx8ICcnKSA6IG5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIHZhbHVlKTtcbiAgfSxcbiAgJ2Zvcic6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKXtcbiAgICAoJ2h0bWxGb3InIGluIG5vZGUpID8gbm9kZS5odG1sRm9yID0gdmFsdWUgOiBub2RlLnNldEF0dHJpYnV0ZSgnZm9yJywgdmFsdWUpO1xuICB9LFxuICAnc3R5bGUnOiBmdW5jdGlvbihub2RlLCB2YWx1ZSl7XG4gICAgKG5vZGUuc3R5bGUpID8gbm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgOiBub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB2YWx1ZSk7XG4gIH0sXG4gICd2YWx1ZSc6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKXtcbiAgICBub2RlLnZhbHVlID0gKHZhbHVlICE9IG51bGwpID8gdmFsdWUgOiAnJztcbiAgfVxufVxuXG5cbi8vIGF0dHJpYnV0ZSBTZXR0ZXIgJiBHZXR0ZXJcbmRvbS5hdHRyID0gZnVuY3Rpb24obm9kZSwgbmFtZSwgdmFsdWUpe1xuICBpZiAoXy5pc0Jvb2xlYW5BdHRyKG5hbWUpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICghIXZhbHVlKSB7XG4gICAgICAgIG5vZGVbbmFtZV0gPSB0cnVlO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBuYW1lKTtcbiAgICAgICAgLy8gbHQgaWU3IC4gdGhlIGphdmFzY3JpcHQgY2hlY2tlZCBzZXR0aW5nIGlzIGluIHZhbGlkXG4gICAgICAgIC8vaHR0cDovL2J5dGVzLmNvbS90b3BpYy9qYXZhc2NyaXB0L2luc2lnaHRzLzc5OTE2Ny1icm93c2VyLXF1aXJrLWR5bmFtaWNhbGx5LWFwcGVuZGVkLWNoZWNrZWQtY2hlY2tib3gtZG9lcy1ub3QtYXBwZWFyLWNoZWNrZWQtaWVcbiAgICAgICAgaWYoZG9tLm1zaWUgJiYgZG9tLm1zaWUgPD03ICYmIG5hbWUgPT09ICdjaGVja2VkJyApIG5vZGUuZGVmYXVsdENoZWNrZWQgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlW25hbWVdID0gZmFsc2U7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKG5vZGVbbmFtZV0gfHxcbiAgICAgICAgICAgICAgIChub2RlLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKG5hbWUpfHwgbm9vcCkuc3BlY2lmaWVkKSA/IG5hbWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGlmIGluIHNwZWNpYWxBdHRyO1xuICAgIGlmKHNwZWNpYWxBdHRyW25hbWVdKSBzcGVjaWFsQXR0cltuYW1lXShub2RlLCB2YWx1ZSk7XG4gICAgZWxzZSBpZih2YWx1ZSA9PT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICBlbHNlIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZSkge1xuICAgIC8vIHRoZSBleHRyYSBhcmd1bWVudCBcIjJcIiBpcyB0byBnZXQgdGhlIHJpZ2h0IHRoaW5nIGZvciBhLmhyZWYgaW4gSUUsIHNlZSBqUXVlcnkgY29kZVxuICAgIC8vIHNvbWUgZWxlbWVudHMgKGUuZy4gRG9jdW1lbnQpIGRvbid0IGhhdmUgZ2V0IGF0dHJpYnV0ZSwgc28gcmV0dXJuIHVuZGVmaW5lZFxuICAgIHZhciByZXQgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lLCAyKTtcbiAgICAvLyBub3JtYWxpemUgbm9uLWV4aXN0aW5nIGF0dHJpYnV0ZXMgdG8gdW5kZWZpbmVkIChhcyBqUXVlcnkpXG4gICAgcmV0dXJuIHJldCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcbiAgfVxufVxuXG5cbmRvbS5vbiA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIGhhbmRsZXIpe1xuICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gIGhhbmRsZXIucmVhbCA9IGZ1bmN0aW9uKGV2KXtcbiAgICB2YXIgJGV2ZW50ID0gbmV3IEV2ZW50KGV2KTtcbiAgICAkZXZlbnQub3JpZ2luID0gbm9kZTtcbiAgICBoYW5kbGVyLmNhbGwobm9kZSwgJGV2ZW50KTtcbiAgfVxuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpe1xuICAgIHR5cGUgPSBmaXhFdmVudE5hbWUobm9kZSwgdHlwZSk7XG4gICAgYWRkRXZlbnQobm9kZSwgdHlwZSwgaGFuZGxlci5yZWFsKTtcbiAgfSk7XG4gIHJldHVybiBkb207XG59XG5kb20ub2ZmID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgaGFuZGxlcil7XG4gIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgaGFuZGxlciA9IGhhbmRsZXIucmVhbCB8fCBoYW5kbGVyO1xuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpe1xuICAgIHR5cGUgPSBmaXhFdmVudE5hbWUobm9kZSwgdHlwZSk7XG4gICAgcmVtb3ZlRXZlbnQobm9kZSwgdHlwZSwgaGFuZGxlcik7XG4gIH0pXG59XG5cblxuZG9tLnRleHQgPSAoZnVuY3Rpb24gKCl7XG4gIHZhciBtYXAgPSB7fTtcbiAgaWYgKGRvbS5tc2llICYmIGRvbS5tc2llIDwgOSkge1xuICAgIG1hcFsxXSA9ICdpbm5lclRleHQnOyAgICBcbiAgICBtYXBbM10gPSAnbm9kZVZhbHVlJzsgICAgXG4gIH0gZWxzZSB7XG4gICAgbWFwWzFdID0gbWFwWzNdID0gJ3RleHRDb250ZW50JztcbiAgfVxuICBcbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgIHZhciB0ZXh0UHJvcCA9IG1hcFtub2RlLm5vZGVUeXBlXTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHRQcm9wID8gbm9kZVt0ZXh0UHJvcF0gOiAnJztcbiAgICB9XG4gICAgbm9kZVt0ZXh0UHJvcF0gPSB2YWx1ZTtcbiAgfVxufSkoKTtcblxuXG5kb20uaHRtbCA9IGZ1bmN0aW9uKCBub2RlLCBodG1sICl7XG4gIGlmKHR5cGVvZiBodG1sID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICByZXR1cm4gbm9kZS5pbm5lckhUTUw7XG4gIH1lbHNle1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufVxuXG5kb20ucmVwbGFjZSA9IGZ1bmN0aW9uKG5vZGUsIHJlcGxhY2VkKXtcbiAgaWYocmVwbGFjZWQucGFyZW50Tm9kZSkgcmVwbGFjZWQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgcmVwbGFjZWQpO1xufVxuXG5kb20ucmVtb3ZlID0gZnVuY3Rpb24obm9kZSl7XG4gIGlmKG5vZGUucGFyZW50Tm9kZSkgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vLyBjc3MgU2V0dGxlICYgR2V0dGVyIGZyb20gYW5ndWxhclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBpdCBpc250IGNvbXB1dGVkIHN0eWxlIFxuZG9tLmNzcyA9IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIHZhbHVlKXtcbiAgaWYoIHR5cGVvZiAobmFtZSkgPT09IFwib2JqZWN0XCIgJiYgbmFtZSApe1xuICAgIGZvcih2YXIgaSBpbiBuYW1lKXtcbiAgICAgIGlmKCBuYW1lLmhhc093blByb3BlcnR5KGkpICl7XG4gICAgICAgIGRvbS5jc3MoIG5vZGUsIGksIG5hbWVbaV0gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICggdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICkge1xuXG4gICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICBpZihuYW1lKSBub2RlLnN0eWxlW25hbWVdID0gdmFsdWU7XG5cbiAgfSBlbHNlIHtcblxuICAgIHZhciB2YWw7XG4gICAgaWYgKGRvbS5tc2llIDw9IDgpIHtcbiAgICAgIC8vIHRoaXMgaXMgc29tZSBJRSBzcGVjaWZpYyB3ZWlyZG5lc3MgdGhhdCBqUXVlcnkgMS42LjQgZG9lcyBub3Qgc3VyZSB3aHlcbiAgICAgIHZhbCA9IG5vZGUuY3VycmVudFN0eWxlICYmIG5vZGUuY3VycmVudFN0eWxlW25hbWVdO1xuICAgICAgaWYgKHZhbCA9PT0gJycpIHZhbCA9ICdhdXRvJztcbiAgICB9XG4gICAgdmFsID0gdmFsIHx8IG5vZGUuc3R5bGVbbmFtZV07XG4gICAgaWYgKGRvbS5tc2llIDw9IDgpIHtcbiAgICAgIHZhbCA9IHZhbCA9PT0gJycgPyB1bmRlZmluZWQgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiAgdmFsO1xuICB9XG59XG5cbmRvbS5hZGRDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNsYXNzTmFtZSl7XG4gIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWUgfHwgXCJcIjtcbiAgaWYgKChcIiBcIiArIGN1cnJlbnQgKyBcIiBcIikuaW5kZXhPZihcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiKSA9PT0gLTEpIHtcbiAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQ/ICggY3VycmVudCArIFwiIFwiICsgY2xhc3NOYW1lICkgOiBjbGFzc05hbWU7XG4gIH1cbn1cblxuZG9tLmRlbENsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xhc3NOYW1lKXtcbiAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZSB8fCBcIlwiO1xuICBub2RlLmNsYXNzTmFtZSA9IChcIiBcIiArIGN1cnJlbnQgKyBcIiBcIikucmVwbGFjZShcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiLCBcIiBcIikudHJpbSgpO1xufVxuXG5kb20uaGFzQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbGFzc05hbWUpe1xuICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lIHx8IFwiXCI7XG4gIHJldHVybiAoXCIgXCIgKyBjdXJyZW50ICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgIT09IC0xO1xufVxuXG5cblxuLy8gc2ltcGxlIEV2ZW50IHdyYXBcblxuLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExMDY4MTk2L2llOC1pZTctb25jaGFuZ2UtZXZlbnQtaXMtZW1pdGVkLW9ubHktYWZ0ZXItcmVwZWF0ZWQtc2VsZWN0aW9uXG5mdW5jdGlvbiBmaXhFdmVudE5hbWUoZWxlbSwgbmFtZSl7XG4gIHJldHVybiAobmFtZSA9PT0gJ2NoYW5nZScgICYmICBkb20ubXNpZSA8IDkgJiYgXG4gICAgICAoZWxlbSAmJiBlbGVtLnRhZ05hbWUgJiYgZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PT0naW5wdXQnICYmIFxuICAgICAgICAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJylcbiAgICAgIClcbiAgICApPyAnY2xpY2snOiBuYW1lO1xufVxuXG52YXIgck1vdXNlRXZlbnQgPSAvXig/OmNsaWNrfGRibGNsaWNrfGNvbnRleHRtZW51fERPTU1vdXNlU2Nyb2xsfG1vdXNlKD86XFx3KykpJC9cbnZhciBkb2MgPSBkb2N1bWVudDtcbmRvYyA9ICghZG9jLmNvbXBhdE1vZGUgfHwgZG9jLmNvbXBhdE1vZGUgPT09ICdDU1MxQ29tcGF0JykgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogZG9jLmJvZHk7XG5mdW5jdGlvbiBFdmVudChldil7XG4gIGV2ID0gZXYgfHwgd2luZG93LmV2ZW50O1xuICBpZihldi5fZml4ZWQpIHJldHVybiBldjtcbiAgdGhpcy5ldmVudCA9IGV2O1xuICB0aGlzLnRhcmdldCA9IGV2LnRhcmdldCB8fCBldi5zcmNFbGVtZW50O1xuXG4gIHZhciB0eXBlID0gdGhpcy50eXBlID0gZXYudHlwZTtcbiAgdmFyIGJ1dHRvbiA9IHRoaXMuYnV0dG9uID0gZXYuYnV0dG9uO1xuXG4gIC8vIGlmIGlzIG1vdXNlIGV2ZW50IHBhdGNoIHBhZ2VYXG4gIGlmKHJNb3VzZUV2ZW50LnRlc3QodHlwZSkpeyAvL2ZpeCBwYWdlWFxuICAgIHRoaXMucGFnZVggPSAoZXYucGFnZVggIT0gbnVsbCkgPyBldi5wYWdlWCA6IGV2LmNsaWVudFggKyBkb2Muc2Nyb2xsTGVmdDtcbiAgICB0aGlzLnBhZ2VZID0gKGV2LnBhZ2VYICE9IG51bGwpID8gZXYucGFnZVkgOiBldi5jbGllbnRZICsgZG9jLnNjcm9sbFRvcDtcbiAgICBpZiAodHlwZSA9PT0gJ21vdXNlb3ZlcicgfHwgdHlwZSA9PT0gJ21vdXNlb3V0Jyl7Ly8gZml4IHJlbGF0ZWRUYXJnZXRcbiAgICAgIHZhciByZWxhdGVkID0gZXYucmVsYXRlZFRhcmdldCB8fCBldlsodHlwZSA9PT0gJ21vdXNlb3ZlcicgPyAnZnJvbScgOiAndG8nKSArICdFbGVtZW50J107XG4gICAgICB3aGlsZSAocmVsYXRlZCAmJiByZWxhdGVkLm5vZGVUeXBlID09PSAzKSByZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xuICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZDtcbiAgICB9XG4gIH1cbiAgLy8gaWYgaXMgbW91c2VzY3JvbGxcbiAgaWYgKHR5cGUgPT09ICdET01Nb3VzZVNjcm9sbCcgfHwgdHlwZSA9PT0gJ21vdXNld2hlZWwnKXtcbiAgICAvLyBmZiBldi5kZXRhaWw6IDMgICAgb3RoZXIgZXYud2hlZWxEZWx0YTogLTEyMFxuICAgIHRoaXMud2hlZWxEZWx0YSA9IChldi53aGVlbERlbHRhKSA/IGV2LndoZWVsRGVsdGEgLyAxMjAgOiAtKGV2LmRldGFpbCB8fCAwKSAvIDM7XG4gIH1cbiAgXG4gIC8vIGZpeCB3aGljaFxuICB0aGlzLndoaWNoID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZTtcbiAgaWYoICF0aGlzLndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKXtcbiAgICAvLyBodHRwOi8vYXBpLmpxdWVyeS5jb20vZXZlbnQud2hpY2gvIHVzZSB3aGljaFxuICAgIHRoaXMud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuICB9XG4gIHRoaXMuX2ZpeGVkID0gdHJ1ZTtcbn1cblxuXy5leHRlbmQoRXZlbnQucHJvdG90eXBlLCB7XG4gIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdCgpLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCkgdGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVsc2UgdGhpcy5ldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGVsc2UgdGhpcy5ldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHRoaXMuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbn0pXG5cblxuZG9tLm5leHRGcmFtZSA9IChmdW5jdGlvbigpe1xuICAgIHZhciByZXF1ZXN0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8IFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMTYpXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICBmdW5jdGlvbih0aWQpe1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGlkKVxuICAgICAgICAgICAgICAgICB9XG4gIFxuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIHZhciBpZCA9IHJlcXVlc3QoY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbigpeyBjYW5jZWwoaWQpOyB9XG4gIH1cbn0pKCk7XG5cbi8vIDNrcyBmb3IgYW5ndWxhcidzIHJhZiAgc2VydmljZVxudmFyIGtcbmRvbS5uZXh0UmVmbG93ID0gZG9tLm1zaWU/IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgcmV0dXJuIGRvbS5uZXh0RnJhbWUoZnVuY3Rpb24oKXtcbiAgICBrID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICBjYWxsYmFjaygpO1xuICB9KVxufTogZG9tLm5leHRGcmFtZTtcblxufVxuXG5cblxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIHNvbWUgZml4dHVyZSB0ZXN0O1xuLy8gLS0tLS0tLS0tLS0tLS0tXG52YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuZXhwb3J0cy5zdmcgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCBcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIiApO1xufSkoKTtcblxuXG5leHBvcnRzLmJyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQubm9kZVR5cGU7XG4vLyB3aGV0aGVyIGhhdmUgY29tcG9uZW50IGluIGluaXRpYWxpemluZ1xuZXhwb3J0cy5leHByQ2FjaGUgPSBfLmNhY2hlKDEwMDApO1xuZXhwb3J0cy5ub2RlID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgKCAnJyArIHByb2Nlc3MgKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuZXhwb3J0cy5pc1J1bm5pbmcgPSBmYWxzZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5eVpXZDFiR0Z5YW5NdmJHbGlMMlZ1ZGk1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnYzI5dFpTQm1hWGgwZFhKbElIUmxjM1E3WEc0dkx5QXRMUzB0TFMwdExTMHRMUzB0TFMxY2JuWmhjaUJmSUQwZ2NtVnhkV2x5WlNnbkxpOTFkR2xzSnlrN1hHNWxlSEJ2Y25SekxuTjJaeUE5SUNobWRXNWpkR2x2YmlncGUxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHUnZZM1Z0Wlc1MElDRTlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlDWW1JR1J2WTNWdFpXNTBMbWx0Y0d4bGJXVnVkR0YwYVc5dUxtaGhjMFpsWVhSMWNtVW9JRndpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2VkZJdlUxWkhNVEV2Wm1WaGRIVnlaU05DWVhOcFkxTjBjblZqZEhWeVpWd2lMQ0JjSWpFdU1Wd2lJQ2s3WEc1OUtTZ3BPMXh1WEc1Y2JtVjRjRzl5ZEhNdVluSnZkM05sY2lBOUlIUjVjR1Z2WmlCa2IyTjFiV1Z1ZENBaFBUMGdYQ0oxYm1SbFptbHVaV1JjSWlBbUppQmtiMk4xYldWdWRDNXViMlJsVkhsd1pUdGNiaTh2SUhkb1pYUm9aWElnYUdGMlpTQmpiMjF3YjI1bGJuUWdhVzRnYVc1cGRHbGhiR2w2YVc1blhHNWxlSEJ2Y25SekxtVjRjSEpEWVdOb1pTQTlJRjh1WTJGamFHVW9NVEF3TUNrN1hHNWxlSEJ2Y25SekxtNXZaR1VnUFNCMGVYQmxiMllnY0hKdlkyVnpjeUFoUFQwZ1hDSjFibVJsWm1sdVpXUmNJaUFtSmlBb0lDY25JQ3NnY0hKdlkyVnpjeUFwSUQwOVBTQW5XMjlpYW1WamRDQndjbTlqWlhOelhTYzdYRzVsZUhCdmNuUnpMbWx6VW5WdWJtbHVaeUE5SUdaaGJITmxPMXh1SWwxOSIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgY29tYmluZSA9IHJlcXVpcmUoJy4vaGVscGVyL2NvbWJpbmUnKVxuXG5mdW5jdGlvbiBHcm91cChsaXN0KXtcbiAgdGhpcy5jaGlsZHJlbiA9IGxpc3QgfHwgW107XG59XG5cblxudmFyIG8gPSBfLmV4dGVuZChHcm91cC5wcm90b3R5cGUsIHtcbiAgZGVzdHJveTogZnVuY3Rpb24oZmlyc3Qpe1xuICAgIGNvbWJpbmUuZGVzdHJveSh0aGlzLmNoaWxkcmVuLCBmaXJzdCk7XG4gICAgaWYodGhpcy5vbmRlc3Ryb3kpIHRoaXMub25kZXN0cm95KCk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV1cbiAgfSxcbiAgcHVzaDogZnVuY3Rpb24oaXRlbSl7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCBpdGVtICk7XG4gIH1cbn0pXG5vLmluamVjdCA9IG8uJGluamVjdCA9IGNvbWJpbmUuaW5qZWN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuXG5cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZG9tICA9IHJlcXVpcmUoXCIuLi9kb21cIik7XG52YXIgYW5pbWF0ZSA9IHt9O1xudmFyIGVudiA9IHJlcXVpcmUoXCIuLi9lbnZcIik7XG5cblxuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpe1xudmFyIFxuICB0cmFuc2l0aW9uRW5kID0gJ3RyYW5zaXRpb25lbmQnLCBcbiAgYW5pbWF0aW9uRW5kID0gJ2FuaW1hdGlvbmVuZCcsIFxuICB0cmFuc2l0aW9uUHJvcGVydHkgPSAndHJhbnNpdGlvbicsIFxuICBhbmltYXRpb25Qcm9wZXJ0eSA9ICdhbmltYXRpb24nO1xuXG5pZighKCdvbnRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykpe1xuICBpZignb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICBcbiAgICAvLyBDaHJvbWUvU2FmICgrIE1vYmlsZSBTYWYpL0FuZHJvaWRcbiAgICB0cmFuc2l0aW9uRW5kICs9ICcgd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gICAgdHJhbnNpdGlvblByb3BlcnR5ID0gJ3dlYmtpdFRyYW5zaXRpb24nXG4gIH0gZWxzZSBpZignb25vdHJhbnNpdGlvbmVuZCcgaW4gZG9tLnROb2RlIHx8IG5hdmlnYXRvci5hcHBOYW1lID09PSAnT3BlcmEnKSB7XG5cbiAgICAvLyBPcGVyYVxuICAgIHRyYW5zaXRpb25FbmQgKz0gJyBvVHJhbnNpdGlvbkVuZCc7XG4gICAgdHJhbnNpdGlvblByb3BlcnR5ID0gJ29UcmFuc2l0aW9uJztcbiAgfVxufVxuaWYoISgnb25hbmltYXRpb25lbmQnIGluIHdpbmRvdykpe1xuICBpZiAoJ29ud2Via2l0YW5pbWF0aW9uZW5kJyBpbiB3aW5kb3cpe1xuICAgIC8vIENocm9tZS9TYWYgKCsgTW9iaWxlIFNhZikvQW5kcm9pZFxuICAgIGFuaW1hdGlvbkVuZCArPSAnIHdlYmtpdEFuaW1hdGlvbkVuZCc7XG4gICAgYW5pbWF0aW9uUHJvcGVydHkgPSAnd2Via2l0QW5pbWF0aW9uJztcblxuICB9ZWxzZSBpZiAoJ29ub2FuaW1hdGlvbmVuZCcgaW4gZG9tLnROb2RlKXtcbiAgICAvLyBPcGVyYVxuICAgIGFuaW1hdGlvbkVuZCArPSAnIG9BbmltYXRpb25FbmQnO1xuICAgIGFuaW1hdGlvblByb3BlcnR5ID0gJ29BbmltYXRpb24nO1xuICB9XG59XG59XG5cbi8qKlxuICogaW5qZWN0IG5vZGUgd2l0aCBhbmltYXRpb25cbiAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gcmVmZXIgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gZGlyZWN0aW9uIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuYW5pbWF0ZS5pbmplY3QgPSBmdW5jdGlvbiggbm9kZSwgcmVmZXIgLGRpcmVjdGlvbiwgY2FsbGJhY2sgKXtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBfLm5vb3A7XG4gIGlmKCBBcnJheS5pc0FycmF5KG5vZGUpICl7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9tLmZyYWdtZW50KCk7XG4gICAgdmFyIGNvdW50PTA7XG5cbiAgICBmb3IodmFyIGkgPSAwLGxlbiA9IG5vZGUubGVuZ3RoO2kgPCBsZW47IGkrKyApe1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZVtpXSk7IFxuICAgIH1cbiAgICBkb20uaW5qZWN0KGZyYWdtZW50LCByZWZlciwgZGlyZWN0aW9uKTtcblxuICAgIC8vIGlmIGFsbCBub2RlcyBpcyBkb25lLCB3ZSBjYWxsIHRoZSBjYWxsYmFja1xuICAgIHZhciBlbnRlckNhbGxiYWNrID0gZnVuY3Rpb24gKCl7XG4gICAgICBjb3VudCsrO1xuICAgICAgaWYoIGNvdW50ID09PSBsZW4gKSBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBpZihsZW4gPT09IGNvdW50KSBjYWxsYmFjaygpO1xuICAgIGZvciggaSA9IDA7IGkgPCBsZW47IGkrKyApe1xuICAgICAgaWYobm9kZVtpXS5vbmVudGVyKXtcbiAgICAgICAgbm9kZVtpXS5vbmVudGVyKGVudGVyQ2FsbGJhY2spO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGVudGVyQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1lbHNle1xuICAgIGlmKCFub2RlKSByZXR1cm47XG4gICAgZG9tLmluamVjdCggbm9kZSwgcmVmZXIsIGRpcmVjdGlvbiApO1xuICAgIGlmKG5vZGUub25lbnRlcil7XG4gICAgICBub2RlLm9uZW50ZXIoY2FsbGJhY2spXG4gICAgfWVsc2V7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHJlbW92ZSBub2RlIHdpdGggYW5pbWF0aW9uXG4gKiBAcGFyYW0gIHtbdHlwZV19ICAgbm9kZSAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuYW5pbWF0ZS5yZW1vdmUgPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjayl7XG4gIGlmKCFub2RlKSByZXR1cm47XG4gIHZhciBjb3VudCA9IDA7XG4gIGZ1bmN0aW9uIGxvb3AoKXtcbiAgICBjb3VudCsrO1xuICAgIGlmKGNvdW50ID09PSBsZW4pIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgfVxuICBpZiggQXJyYXkuaXNBcnJheShub2RlKSApe1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IG5vZGUubGVuZ3RoOyBpIDwgbGVuIDsgaSsrKXtcbiAgICAgIGFuaW1hdGUucmVtb3ZlKG5vZGVbaV0sIGxvb3ApXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZih0eXBlb2Ygbm9kZS5vbmxlYXZlID09PSdmdW5jdGlvbicpe1xuICAgIG5vZGUub25sZWF2ZShmdW5jdGlvbigpe1xuICAgICAgcmVtb3ZlRG9uZShub2RlLCBjYWxsYmFjaylcbiAgICB9KVxuICB9ZWxzZXtcbiAgICByZW1vdmVEb25lKG5vZGUsIGNhbGxiYWNrKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURvbmUobm9kZSwgY2FsbGJhY2spe1xuICAgIGRvbS5yZW1vdmUobm9kZSk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbn1cblxuXG5cbmFuaW1hdGUuc3RhcnRDbGFzc0FuaW1hdGUgPSBmdW5jdGlvbiAoIG5vZGUsIGNsYXNzTmFtZSwgIGNhbGxiYWNrLCBtb2RlICl7XG4gIHZhciBhY3RpdmVDbGFzc05hbWUsIHRpbWVvdXQsIHRpZCwgb25jZUFuaW07XG4gIGlmKCAoIWFuaW1hdGlvbkVuZCAmJiAhdHJhbnNpdGlvbkVuZCkgfHwgZW52LmlzUnVubmluZyApe1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgaWYobW9kZSAhPT0gNCl7XG4gICAgb25jZUFuaW0gPSBfLm9uY2UoZnVuY3Rpb24gb25BbmltYXRlRW5kKCl7XG4gICAgICBpZih0aWQpIGNsZWFyVGltZW91dCh0aWQpO1xuXG4gICAgICBpZihtb2RlID09PSAyKSB7XG4gICAgICAgIGRvbS5kZWxDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuICAgICAgfVxuICAgICAgaWYobW9kZSAhPT0gMyl7IC8vIG1vZGUgaG9sZCB0aGUgY2xhc3NcbiAgICAgICAgZG9tLmRlbENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBkb20ub2ZmKG5vZGUsIGFuaW1hdGlvbkVuZCwgb25jZUFuaW0pXG4gICAgICBkb20ub2ZmKG5vZGUsIHRyYW5zaXRpb25FbmQsIG9uY2VBbmltKVxuXG4gICAgICBjYWxsYmFjaygpO1xuXG4gICAgfSk7XG4gIH1lbHNle1xuICAgIG9uY2VBbmltID0gXy5vbmNlKGZ1bmN0aW9uIG9uQW5pbWF0ZUVuZCgpe1xuICAgICAgaWYodGlkKSBjbGVhclRpbWVvdXQodGlkKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cbiAgaWYobW9kZSA9PT0gMil7IC8vIGF1dG8gcmVtb3ZlZFxuICAgIGRvbS5hZGRDbGFzcyggbm9kZSwgY2xhc3NOYW1lICk7XG5cbiAgICBhY3RpdmVDbGFzc05hbWUgPSBfLm1hcChjbGFzc05hbWUuc3BsaXQoL1xccysvKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgICAgcmV0dXJuIG5hbWUgKyAnLWFjdGl2ZSc7XG4gICAgfSkuam9pbihcIiBcIik7XG5cbiAgICBkb20ubmV4dFJlZmxvdyhmdW5jdGlvbigpe1xuICAgICAgZG9tLmFkZENsYXNzKCBub2RlLCBhY3RpdmVDbGFzc05hbWUgKTtcbiAgICAgIHRpbWVvdXQgPSBnZXRNYXhUaW1lb3V0KCBub2RlICk7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCBvbmNlQW5pbSwgdGltZW91dCApO1xuICAgIH0pO1xuXG4gIH1lbHNlIGlmKG1vZGU9PT00KXtcbiAgICBkb20ubmV4dFJlZmxvdyhmdW5jdGlvbigpe1xuICAgICAgZG9tLmRlbENsYXNzKCBub2RlLCBjbGFzc05hbWUgKTtcbiAgICAgIHRpbWVvdXQgPSBnZXRNYXhUaW1lb3V0KCBub2RlICk7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCBvbmNlQW5pbSwgdGltZW91dCApO1xuICAgIH0pO1xuXG4gIH1lbHNle1xuICAgIGRvbS5uZXh0UmVmbG93KGZ1bmN0aW9uKCl7XG4gICAgICBkb20uYWRkQ2xhc3MoIG5vZGUsIGNsYXNzTmFtZSApO1xuICAgICAgdGltZW91dCA9IGdldE1heFRpbWVvdXQoIG5vZGUgKTtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoIG9uY2VBbmltLCB0aW1lb3V0ICk7XG4gICAgfSk7XG4gIH1cblxuXG5cbiAgZG9tLm9uKCBub2RlLCBhbmltYXRpb25FbmQsIG9uY2VBbmltIClcbiAgZG9tLm9uKCBub2RlLCB0cmFuc2l0aW9uRW5kLCBvbmNlQW5pbSApXG4gIHJldHVybiBvbmNlQW5pbTtcbn1cblxuXG5hbmltYXRlLnN0YXJ0U3R5bGVBbmltYXRlID0gZnVuY3Rpb24obm9kZSwgc3R5bGVzLCBjYWxsYmFjayl7XG4gIHZhciB0aW1lb3V0LCBvbmNlQW5pbSwgdGlkO1xuXG4gIGRvbS5uZXh0UmVmbG93KGZ1bmN0aW9uKCl7XG4gICAgZG9tLmNzcyggbm9kZSwgc3R5bGVzICk7XG4gICAgdGltZW91dCA9IGdldE1heFRpbWVvdXQoIG5vZGUgKTtcbiAgICB0aWQgPSBzZXRUaW1lb3V0KCBvbmNlQW5pbSwgdGltZW91dCApO1xuICB9KTtcblxuXG4gIG9uY2VBbmltID0gXy5vbmNlKGZ1bmN0aW9uIG9uQW5pbWF0ZUVuZCgpe1xuICAgIGlmKHRpZCkgY2xlYXJUaW1lb3V0KHRpZCk7XG5cbiAgICBkb20ub2ZmKG5vZGUsIGFuaW1hdGlvbkVuZCwgb25jZUFuaW0pXG4gICAgZG9tLm9mZihub2RlLCB0cmFuc2l0aW9uRW5kLCBvbmNlQW5pbSlcblxuICAgIGNhbGxiYWNrKCk7XG5cbiAgfSk7XG5cbiAgZG9tLm9uKCBub2RlLCBhbmltYXRpb25FbmQsIG9uY2VBbmltIClcbiAgZG9tLm9uKCBub2RlLCB0cmFuc2l0aW9uRW5kLCBvbmNlQW5pbSApXG5cbiAgcmV0dXJuIG9uY2VBbmltO1xufVxuXG5cbi8qKlxuICogZ2V0IG1heHRpbWVvdXRcbiAqIEBwYXJhbSAge05vZGV9IG5vZGUgXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBnZXRNYXhUaW1lb3V0KG5vZGUpe1xuICB2YXIgdGltZW91dCA9IDAsXG4gICAgdER1cmF0aW9uID0gMCxcbiAgICB0RGVsYXkgPSAwLFxuICAgIGFEdXJhdGlvbiA9IDAsXG4gICAgYURlbGF5ID0gMCxcbiAgICByYXRpbyA9IDUgLyAzLFxuICAgIHN0eWxlcyA7XG5cbiAgaWYod2luZG93LmdldENvbXB1dGVkU3R5bGUpe1xuXG4gICAgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSksXG4gICAgdER1cmF0aW9uID0gZ2V0TWF4VGltZSggc3R5bGVzW3RyYW5zaXRpb25Qcm9wZXJ0eSArICdEdXJhdGlvbiddKSB8fCB0RHVyYXRpb247XG4gICAgdERlbGF5ID0gZ2V0TWF4VGltZSggc3R5bGVzW3RyYW5zaXRpb25Qcm9wZXJ0eSArICdEZWxheSddKSB8fCB0RGVsYXk7XG4gICAgYUR1cmF0aW9uID0gZ2V0TWF4VGltZSggc3R5bGVzW2FuaW1hdGlvblByb3BlcnR5ICsgJ0R1cmF0aW9uJ10pIHx8IGFEdXJhdGlvbjtcbiAgICBhRGVsYXkgPSBnZXRNYXhUaW1lKCBzdHlsZXNbYW5pbWF0aW9uUHJvcGVydHkgKyAnRGVsYXknXSkgfHwgYURlbGF5O1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCggdER1cmF0aW9uK3REZWxheSwgYUR1cmF0aW9uICsgYURlbGF5ICk7XG5cbiAgfVxuICByZXR1cm4gdGltZW91dCAqIDEwMDAgKiByYXRpbztcbn1cblxuZnVuY3Rpb24gZ2V0TWF4VGltZShzdHIpe1xuXG4gIHZhciBtYXhUaW1lb3V0ID0gMCwgdGltZTtcblxuICBpZighc3RyKSByZXR1cm4gMDtcblxuICBzdHIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24oc3RyKXtcblxuICAgIHRpbWUgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgaWYoIHRpbWUgPiBtYXhUaW1lb3V0ICkgbWF4VGltZW91dCA9IHRpbWU7XG5cbiAgfSk7XG5cbiAgcmV0dXJuIG1heFRpbWVvdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW5pbWF0ZTsiLCIvLyBzb21lIG5lc3RlZCAgb3BlcmF0aW9uIGluIGFzdCBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBkb20gPSByZXF1aXJlKFwiLi4vZG9tXCIpO1xudmFyIGFuaW1hdGUgPSByZXF1aXJlKFwiLi9hbmltYXRlXCIpO1xuXG52YXIgY29tYmluZSA9IG1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIGdldCB0aGUgaW5pdGlhbCBkb20gaW4gb2JqZWN0XG4gIG5vZGU6IGZ1bmN0aW9uKGl0ZW0pe1xuICAgIHZhciBjaGlsZHJlbixub2RlLCBub2RlcztcbiAgICBpZighaXRlbSkgcmV0dXJuO1xuICAgIGlmKHR5cGVvZiBpdGVtLm5vZGUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGl0ZW0ubm9kZSgpO1xuICAgIGlmKHR5cGVvZiBpdGVtLm5vZGVUeXBlID09PSBcIm51bWJlclwiKSByZXR1cm4gaXRlbTtcbiAgICBpZihpdGVtLmdyb3VwKSByZXR1cm4gY29tYmluZS5ub2RlKGl0ZW0uZ3JvdXApXG5cbiAgICBpdGVtID0gaXRlbS5jaGlsZHJlbiB8fCBpdGVtO1xuICAgIGlmKCBBcnJheS5pc0FycmF5KGl0ZW0gKSl7XG4gICAgICB2YXIgbGVuID0gaXRlbS5sZW5ndGg7XG4gICAgICBpZihsZW4gPT09IDEpe1xuICAgICAgICByZXR1cm4gY29tYmluZS5ub2RlKGl0ZW1bMF0pO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGl0ZW0ubGVuZ3RoOyBpIDwgbGVuOyBpKysgKXtcbiAgICAgICAgbm9kZSA9IGNvbWJpbmUubm9kZShpdGVtW2ldKTtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShub2RlKSl7XG4gICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2Rlcywgbm9kZSlcbiAgICAgICAgfWVsc2UgaWYobm9kZSkge1xuICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBcbiAgfSxcbiAgLy8gQFRPRE8gcmVtb3ZlIF9ncmFnQ29udGFpbmVyXG4gIGluamVjdDogZnVuY3Rpb24obm9kZSwgcG9zICl7XG4gICAgdmFyIGdyb3VwID0gdGhpcztcbiAgICB2YXIgZnJhZ21lbnQgPSBjb21iaW5lLm5vZGUoZ3JvdXAuZ3JvdXAgfHwgZ3JvdXApO1xuICAgIGlmKG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICBhbmltYXRlLnJlbW92ZShmcmFnbWVudClcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9ZWxzZXtcbiAgICAgIGlmKCFmcmFnbWVudCkgcmV0dXJuIGdyb3VwO1xuICAgICAgaWYodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSBub2RlID0gZG9tLmZpbmQobm9kZSk7XG4gICAgICBpZighbm9kZSkgdGhyb3cgRXJyb3IoJ2luamVjdGVkIG5vZGUgaXMgbm90IGZvdW5kJyk7XG4gICAgICAvLyB1c2UgYW5pbWF0ZSB0byBhbmltYXRlIGZpcnN0Y2hpbGRyZW5cbiAgICAgIGFuaW1hdGUuaW5qZWN0KGZyYWdtZW50LCBub2RlLCBwb3MpO1xuICAgIH1cbiAgICAvLyBpZiBpdCBpcyBhIGNvbXBvbmVudFxuICAgIGlmKGdyb3VwLiRlbWl0KSB7XG4gICAgICB2YXIgcHJlUGFyZW50ID0gZ3JvdXAucGFyZW50Tm9kZTtcbiAgICAgIHZhciBuZXdQYXJlbnQgPSAocG9zID09PSdhZnRlcicgfHwgcG9zID09PSAnYmVmb3JlJyk/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGU7XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gbmV3UGFyZW50O1xuICAgICAgZ3JvdXAuJGVtaXQoXCIkaW5qZWN0XCIsIG5vZGUsIHBvcywgcHJlUGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9LFxuXG4gIC8vIGdldCB0aGUgbGFzdCBkb20gaW4gb2JqZWN0KGZvciBpbnNlcnRpb24gb3BlcmF0aW9uKVxuICBsYXN0OiBmdW5jdGlvbihpdGVtKXtcbiAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuO1xuXG4gICAgaWYodHlwZW9mIGl0ZW0ubGFzdCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaXRlbS5sYXN0KCk7XG4gICAgaWYodHlwZW9mIGl0ZW0ubm9kZVR5cGUgPT09IFwibnVtYmVyXCIpIHJldHVybiBpdGVtO1xuXG4gICAgaWYoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gY29tYmluZS5sYXN0KGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKTtcbiAgICBpZihpdGVtLmdyb3VwKSByZXR1cm4gY29tYmluZS5sYXN0KGl0ZW0uZ3JvdXApO1xuXG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24oaXRlbSwgZmlyc3Qpe1xuICAgIGlmKCFpdGVtKSByZXR1cm47XG4gICAgaWYoIHR5cGVvZiBpdGVtLm5vZGVUeXBlID09PSBcIm51bWJlclwiICApIHJldHVybiBmaXJzdCAmJiBkb20ucmVtb3ZlKGl0ZW0pXG4gICAgaWYoIHR5cGVvZiBpdGVtLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIiApIHJldHVybiBpdGVtLmRlc3Ryb3koZmlyc3QpO1xuXG4gICAgaWYoIEFycmF5LmlzQXJyYXkoaXRlbSkpe1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gaXRlbS5sZW5ndGg7IGkgPCBsZW47IGkrKyApe1xuICAgICAgICBjb21iaW5lLmRlc3Ryb3koaXRlbVtpXSwgZmlyc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cblxuLy8gQFRPRE86IG5lZWQgbW92ZSB0byBkb20uanNcbmRvbS5lbGVtZW50ID0gZnVuY3Rpb24oIGNvbXBvbmVudCwgYWxsICl7XG4gIGlmKCFjb21wb25lbnQpIHJldHVybiAhYWxsPyBudWxsOiBbXTtcbiAgdmFyIG5vZGVzID0gY29tYmluZS5ub2RlKCBjb21wb25lbnQgKTtcbiAgaWYoIG5vZGVzLm5vZGVUeXBlID09PSAxICkgcmV0dXJuIGFsbD8gW25vZGVzXTogbm9kZXM7XG4gIHZhciBlbGVtZW50cyA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpPG5vZGVzLmxlbmd0aCA7aSsrKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmKCBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDEpe1xuICAgICAgaWYoIWFsbCkgcmV0dXJuIG5vZGU7XG4gICAgICBlbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgIH0gXG4gIH1cbiAgcmV0dXJuICFhbGw/IGVsZW1lbnRzWzBdOiBlbGVtZW50cztcbn1cblxuXG5cbiIsImZ1bmN0aW9uIE5vZGVDdXJzb3Iobm9kZSl7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG59XG5cblxudmFyIG5vID0gTm9kZUN1cnNvci5wcm90b3R5cGU7XG5cbm5vLm5leHQgPSBmdW5jdGlvbigpe1xuICB0aGlzLm5vZGUgPSB0aGlzLm5vZGUubmV4dFNpYmxpbmc7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG4peyByZXR1cm4gbmV3IE5vZGVDdXJzb3Iobil9XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gc2ltcGxlRGlmZihub3csIG9sZCl7XG4gIHZhciBubGVuID0gbm93Lmxlbmd0aDtcbiAgdmFyIG9sZW4gPSBvbGQubGVuZ3RoO1xuICBpZihubGVuICE9PSBvbGVuKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbmxlbiA7IGkrKyl7XG4gICAgaWYobm93W2ldICE9PSBvbGRbaV0pIHJldHVybiAgdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2VcblxufVxuXG5mdW5jdGlvbiBlcXVhbHMoYSxiKXtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbi8vIGFycmF5MSAtIG9sZCBhcnJheVxuLy8gYXJyYXkyIC0gbmV3IGFycmF5XG5mdW5jdGlvbiBsZChhcnJheTEsIGFycmF5MiwgZXF1YWxGbil7XG4gIHZhciBuID0gYXJyYXkxLmxlbmd0aDtcbiAgdmFyIG0gPSBhcnJheTIubGVuZ3RoO1xuICB2YXIgZXF1YWxGbiA9IGVxdWFsRm4gfHwgZXF1YWxzO1xuICB2YXIgbWF0cml4ID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKXtcbiAgICBtYXRyaXgucHVzaChbaV0pO1xuICB9XG4gIGZvcih2YXIgaj0xO2o8PW07aisrKXtcbiAgICBtYXRyaXhbMF1bal09ajtcbiAgfVxuICBmb3IodmFyIGkgPSAxOyBpIDw9IG47IGkrKyl7XG4gICAgZm9yKHZhciBqID0gMTsgaiA8PSBtOyBqKyspe1xuICAgICAgaWYoZXF1YWxGbihhcnJheTFbaS0xXSwgYXJyYXkyW2otMV0pKXtcbiAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2ktMV1bai0xXTtcbiAgICAgIH1lbHNle1xuICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihcbiAgICAgICAgICBtYXRyaXhbaS0xXVtqXSsxLCAvL2RlbGV0ZVxuICAgICAgICAgIG1hdHJpeFtpXVtqLTFdKzEvL2FkZFxuICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cbi8vIGFycjIgLSBuZXcgYXJyYXlcbi8vIGFycjEgLSBvbGQgYXJyYXlcbmZ1bmN0aW9uIGRpZmZBcnJheShhcnIyLCBhcnIxLCBkaWZmLCBkaWZmRm4pIHtcbiAgaWYoIWRpZmYpIHJldHVybiBzaW1wbGVEaWZmKGFycjIsIGFycjEpO1xuICB2YXIgbWF0cml4ID0gbGQoYXJyMSwgYXJyMiwgZGlmZkZuKVxuICB2YXIgbiA9IGFycjEubGVuZ3RoO1xuICB2YXIgaSA9IG47XG4gIHZhciBtID0gYXJyMi5sZW5ndGg7XG4gIHZhciBqID0gbTtcbiAgdmFyIGVkaXRzID0gW107XG4gIHZhciBjdXJyZW50ID0gbWF0cml4W2ldW2pdO1xuICB3aGlsZShpPjAgfHwgaj4wKXtcbiAgLy8gdGhlIGxhc3QgbGluZVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBlZGl0cy51bnNoaWZ0KDMpO1xuICAgICAgai0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHRoZSBsYXN0IGNvbFxuICAgIGlmIChqID09PSAwKSB7XG4gICAgICBlZGl0cy51bnNoaWZ0KDIpO1xuICAgICAgaS0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBub3J0aFdlc3QgPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICB2YXIgd2VzdCA9IG1hdHJpeFtpIC0gMV1bal07XG4gICAgdmFyIG5vcnRoID0gbWF0cml4W2ldW2ogLSAxXTtcblxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihub3J0aCwgd2VzdCwgbm9ydGhXZXN0KTtcblxuICAgIGlmIChtaW4gPT09IHdlc3QpIHtcbiAgICAgIGVkaXRzLnVuc2hpZnQoMik7IC8vZGVsZXRlXG4gICAgICBpLS07XG4gICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICB9IGVsc2UgaWYgKG1pbiA9PT0gbm9ydGhXZXN0ICkge1xuICAgICAgaWYgKG5vcnRoV2VzdCA9PT0gY3VycmVudCkge1xuICAgICAgICBlZGl0cy51bnNoaWZ0KDApOyAvL25vIGNoYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdHMudW5zaGlmdCgxKTsgLy91cGRhdGVcbiAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGotLTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdHMudW5zaGlmdCgzKTsgLy9hZGRcbiAgICAgIGotLTtcbiAgICAgIGN1cnJlbnQgPSBub3J0aDtcbiAgICB9XG4gIH1cbiAgdmFyIExFQVZFID0gMDtcbiAgdmFyIEFERCA9IDM7XG4gIHZhciBERUxFTEUgPSAyO1xuICB2YXIgVVBEQVRFID0gMTtcbiAgdmFyIG4gPSAwO209MDtcbiAgdmFyIHN0ZXBzID0gW107XG4gIHZhciBzdGVwID0geyBpbmRleDogbnVsbCwgYWRkOjAsIHJlbW92ZWQ6W10gfTtcblxuICBmb3IodmFyIGk9MDtpPGVkaXRzLmxlbmd0aDtpKyspe1xuICAgIGlmKGVkaXRzW2ldID4gMCApeyAvLyBOT1QgTEVBVkVcbiAgICAgIGlmKHN0ZXAuaW5kZXggPT09IG51bGwpe1xuICAgICAgICBzdGVwLmluZGV4ID0gbTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvL0xFQVZFXG4gICAgICBpZihzdGVwLmluZGV4ICE9IG51bGwpe1xuICAgICAgICBzdGVwcy5wdXNoKHN0ZXApXG4gICAgICAgIHN0ZXAgPSB7aW5kZXg6IG51bGwsIGFkZDowLCByZW1vdmVkOltdfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoKGVkaXRzW2ldKXtcbiAgICAgIGNhc2UgTEVBVkU6XG4gICAgICAgIG4rKztcbiAgICAgICAgbSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQUREOlxuICAgICAgICBzdGVwLmFkZCsrO1xuICAgICAgICBtKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBERUxFTEU6XG4gICAgICAgIHN0ZXAucmVtb3ZlZC5wdXNoKGFycjFbbl0pXG4gICAgICAgIG4rKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVQREFURTpcbiAgICAgICAgc3RlcC5hZGQrKztcbiAgICAgICAgc3RlcC5yZW1vdmVkLnB1c2goYXJyMVtuXSlcbiAgICAgICAgbisrO1xuICAgICAgICBtKys7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZihzdGVwLmluZGV4ICE9IG51bGwpe1xuICAgIHN0ZXBzLnB1c2goc3RlcClcbiAgfVxuICByZXR1cm4gc3RlcHNcbn1cblxuXG5cbi8vIGRpZmZPYmplY3Rcbi8vIC0tLS1cbi8vIHRlc3QgaWYgb2JqMSBkZWVwRXF1YWwgb2JqMlxuZnVuY3Rpb24gZGlmZk9iamVjdCggbm93LCBsYXN0LCBkaWZmICl7XG5cblxuICBpZighZGlmZil7XG5cbiAgICBmb3IoIHZhciBqIGluIG5vdyApe1xuICAgICAgaWYoIGxhc3Rbal0gIT09IG5vd1tqXSApIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZm9yKCB2YXIgbiBpbiBsYXN0ICl7XG4gICAgICBpZihsYXN0W25dICE9PSBub3dbbl0pIHJldHVybiB0cnVlO1xuICAgIH1cblxuICB9ZWxzZXtcblxuICAgIHZhciBuS2V5cyA9IF8ua2V5cyhub3cpO1xuICAgIHZhciBsS2V5cyA9IF8ua2V5cyhsYXN0KTtcblxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGEgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gYil7ICAgICAgICAgICAgICAgICAgIHJldHVybiBub3dbYl0gW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgcmV0dXJuIGRpZmZBcnJheShuS2V5cywgbEtleXMsIGRpZmYsIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIG5vd1tiXSA9PT0gbGFzdFthXTtcbiAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xuXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRpZmZBcnJheTogZGlmZkFycmF5LFxuICBkaWZmT2JqZWN0OiBkaWZmT2JqZWN0XG59IiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzU0MDY0L2hvdy10by1jb252ZXJ0LWNoYXJhY3RlcnMtdG8taHRtbC1lbnRpdGllcy11c2luZy1wbGFpbi1qYXZhc2NyaXB0XG52YXIgZW50aXRpZXMgPSB7XG4gICdxdW90JzozNCwgXG4gICdhbXAnOjM4LCBcbiAgJ2Fwb3MnOjM5LCBcbiAgJ2x0Jzo2MCwgXG4gICdndCc6NjIsIFxuICAnbmJzcCc6MTYwLCBcbiAgJ2lleGNsJzoxNjEsIFxuICAnY2VudCc6MTYyLCBcbiAgJ3BvdW5kJzoxNjMsIFxuICAnY3VycmVuJzoxNjQsIFxuICAneWVuJzoxNjUsIFxuICAnYnJ2YmFyJzoxNjYsIFxuICAnc2VjdCc6MTY3LCBcbiAgJ3VtbCc6MTY4LCBcbiAgJ2NvcHknOjE2OSwgXG4gICdvcmRmJzoxNzAsIFxuICAnbGFxdW8nOjE3MSwgXG4gICdub3QnOjE3MiwgXG4gICdzaHknOjE3MywgXG4gICdyZWcnOjE3NCwgXG4gICdtYWNyJzoxNzUsIFxuICAnZGVnJzoxNzYsIFxuICAncGx1c21uJzoxNzcsIFxuICAnc3VwMic6MTc4LCBcbiAgJ3N1cDMnOjE3OSwgXG4gICdhY3V0ZSc6MTgwLCBcbiAgJ21pY3JvJzoxODEsIFxuICAncGFyYSc6MTgyLCBcbiAgJ21pZGRvdCc6MTgzLCBcbiAgJ2NlZGlsJzoxODQsIFxuICAnc3VwMSc6MTg1LCBcbiAgJ29yZG0nOjE4NiwgXG4gICdyYXF1byc6MTg3LCBcbiAgJ2ZyYWMxNCc6MTg4LCBcbiAgJ2ZyYWMxMic6MTg5LCBcbiAgJ2ZyYWMzNCc6MTkwLCBcbiAgJ2lxdWVzdCc6MTkxLCBcbiAgJ0FncmF2ZSc6MTkyLCBcbiAgJ0FhY3V0ZSc6MTkzLCBcbiAgJ0FjaXJjJzoxOTQsIFxuICAnQXRpbGRlJzoxOTUsIFxuICAnQXVtbCc6MTk2LCBcbiAgJ0FyaW5nJzoxOTcsIFxuICAnQUVsaWcnOjE5OCwgXG4gICdDY2VkaWwnOjE5OSwgXG4gICdFZ3JhdmUnOjIwMCwgXG4gICdFYWN1dGUnOjIwMSwgXG4gICdFY2lyYyc6MjAyLCBcbiAgJ0V1bWwnOjIwMywgXG4gICdJZ3JhdmUnOjIwNCwgXG4gICdJYWN1dGUnOjIwNSwgXG4gICdJY2lyYyc6MjA2LCBcbiAgJ0l1bWwnOjIwNywgXG4gICdFVEgnOjIwOCwgXG4gICdOdGlsZGUnOjIwOSwgXG4gICdPZ3JhdmUnOjIxMCwgXG4gICdPYWN1dGUnOjIxMSwgXG4gICdPY2lyYyc6MjEyLCBcbiAgJ090aWxkZSc6MjEzLCBcbiAgJ091bWwnOjIxNCwgXG4gICd0aW1lcyc6MjE1LCBcbiAgJ09zbGFzaCc6MjE2LCBcbiAgJ1VncmF2ZSc6MjE3LCBcbiAgJ1VhY3V0ZSc6MjE4LCBcbiAgJ1VjaXJjJzoyMTksIFxuICAnVXVtbCc6MjIwLCBcbiAgJ1lhY3V0ZSc6MjIxLCBcbiAgJ1RIT1JOJzoyMjIsIFxuICAnc3psaWcnOjIyMywgXG4gICdhZ3JhdmUnOjIyNCwgXG4gICdhYWN1dGUnOjIyNSwgXG4gICdhY2lyYyc6MjI2LCBcbiAgJ2F0aWxkZSc6MjI3LCBcbiAgJ2F1bWwnOjIyOCwgXG4gICdhcmluZyc6MjI5LCBcbiAgJ2FlbGlnJzoyMzAsIFxuICAnY2NlZGlsJzoyMzEsIFxuICAnZWdyYXZlJzoyMzIsIFxuICAnZWFjdXRlJzoyMzMsIFxuICAnZWNpcmMnOjIzNCwgXG4gICdldW1sJzoyMzUsIFxuICAnaWdyYXZlJzoyMzYsIFxuICAnaWFjdXRlJzoyMzcsIFxuICAnaWNpcmMnOjIzOCwgXG4gICdpdW1sJzoyMzksIFxuICAnZXRoJzoyNDAsIFxuICAnbnRpbGRlJzoyNDEsIFxuICAnb2dyYXZlJzoyNDIsIFxuICAnb2FjdXRlJzoyNDMsIFxuICAnb2NpcmMnOjI0NCwgXG4gICdvdGlsZGUnOjI0NSwgXG4gICdvdW1sJzoyNDYsIFxuICAnZGl2aWRlJzoyNDcsIFxuICAnb3NsYXNoJzoyNDgsIFxuICAndWdyYXZlJzoyNDksIFxuICAndWFjdXRlJzoyNTAsIFxuICAndWNpcmMnOjI1MSwgXG4gICd1dW1sJzoyNTIsIFxuICAneWFjdXRlJzoyNTMsIFxuICAndGhvcm4nOjI1NCwgXG4gICd5dW1sJzoyNTUsIFxuICAnZm5vZic6NDAyLCBcbiAgJ0FscGhhJzo5MTMsIFxuICAnQmV0YSc6OTE0LCBcbiAgJ0dhbW1hJzo5MTUsIFxuICAnRGVsdGEnOjkxNiwgXG4gICdFcHNpbG9uJzo5MTcsIFxuICAnWmV0YSc6OTE4LCBcbiAgJ0V0YSc6OTE5LCBcbiAgJ1RoZXRhJzo5MjAsIFxuICAnSW90YSc6OTIxLCBcbiAgJ0thcHBhJzo5MjIsIFxuICAnTGFtYmRhJzo5MjMsIFxuICAnTXUnOjkyNCwgXG4gICdOdSc6OTI1LCBcbiAgJ1hpJzo5MjYsIFxuICAnT21pY3Jvbic6OTI3LCBcbiAgJ1BpJzo5MjgsIFxuICAnUmhvJzo5MjksIFxuICAnU2lnbWEnOjkzMSwgXG4gICdUYXUnOjkzMiwgXG4gICdVcHNpbG9uJzo5MzMsIFxuICAnUGhpJzo5MzQsIFxuICAnQ2hpJzo5MzUsIFxuICAnUHNpJzo5MzYsIFxuICAnT21lZ2EnOjkzNywgXG4gICdhbHBoYSc6OTQ1LCBcbiAgJ2JldGEnOjk0NiwgXG4gICdnYW1tYSc6OTQ3LCBcbiAgJ2RlbHRhJzo5NDgsIFxuICAnZXBzaWxvbic6OTQ5LCBcbiAgJ3pldGEnOjk1MCwgXG4gICdldGEnOjk1MSwgXG4gICd0aGV0YSc6OTUyLCBcbiAgJ2lvdGEnOjk1MywgXG4gICdrYXBwYSc6OTU0LCBcbiAgJ2xhbWJkYSc6OTU1LCBcbiAgJ211Jzo5NTYsIFxuICAnbnUnOjk1NywgXG4gICd4aSc6OTU4LCBcbiAgJ29taWNyb24nOjk1OSwgXG4gICdwaSc6OTYwLCBcbiAgJ3Jobyc6OTYxLCBcbiAgJ3NpZ21hZic6OTYyLCBcbiAgJ3NpZ21hJzo5NjMsIFxuICAndGF1Jzo5NjQsIFxuICAndXBzaWxvbic6OTY1LCBcbiAgJ3BoaSc6OTY2LCBcbiAgJ2NoaSc6OTY3LCBcbiAgJ3BzaSc6OTY4LCBcbiAgJ29tZWdhJzo5NjksIFxuICAndGhldGFzeW0nOjk3NywgXG4gICd1cHNpaCc6OTc4LCBcbiAgJ3Bpdic6OTgyLCBcbiAgJ2J1bGwnOjgyMjYsIFxuICAnaGVsbGlwJzo4MjMwLCBcbiAgJ3ByaW1lJzo4MjQyLCBcbiAgJ1ByaW1lJzo4MjQzLCBcbiAgJ29saW5lJzo4MjU0LCBcbiAgJ2ZyYXNsJzo4MjYwLCBcbiAgJ3dlaWVycCc6ODQ3MiwgXG4gICdpbWFnZSc6ODQ2NSwgXG4gICdyZWFsJzo4NDc2LCBcbiAgJ3RyYWRlJzo4NDgyLCBcbiAgJ2FsZWZzeW0nOjg1MDEsIFxuICAnbGFycic6ODU5MiwgXG4gICd1YXJyJzo4NTkzLCBcbiAgJ3JhcnInOjg1OTQsIFxuICAnZGFycic6ODU5NSwgXG4gICdoYXJyJzo4NTk2LCBcbiAgJ2NyYXJyJzo4NjI5LCBcbiAgJ2xBcnInOjg2NTYsIFxuICAndUFycic6ODY1NywgXG4gICdyQXJyJzo4NjU4LCBcbiAgJ2RBcnInOjg2NTksIFxuICAnaEFycic6ODY2MCwgXG4gICdmb3JhbGwnOjg3MDQsIFxuICAncGFydCc6ODcwNiwgXG4gICdleGlzdCc6ODcwNywgXG4gICdlbXB0eSc6ODcwOSwgXG4gICduYWJsYSc6ODcxMSwgXG4gICdpc2luJzo4NzEyLCBcbiAgJ25vdGluJzo4NzEzLCBcbiAgJ25pJzo4NzE1LCBcbiAgJ3Byb2QnOjg3MTksIFxuICAnc3VtJzo4NzIxLCBcbiAgJ21pbnVzJzo4NzIyLCBcbiAgJ2xvd2FzdCc6ODcyNywgXG4gICdyYWRpYyc6ODczMCwgXG4gICdwcm9wJzo4NzMzLCBcbiAgJ2luZmluJzo4NzM0LCBcbiAgJ2FuZyc6ODczNiwgXG4gICdhbmQnOjg3NDMsIFxuICAnb3InOjg3NDQsIFxuICAnY2FwJzo4NzQ1LCBcbiAgJ2N1cCc6ODc0NiwgXG4gICdpbnQnOjg3NDcsIFxuICAndGhlcmU0Jzo4NzU2LCBcbiAgJ3NpbSc6ODc2NCwgXG4gICdjb25nJzo4NzczLCBcbiAgJ2FzeW1wJzo4Nzc2LCBcbiAgJ25lJzo4ODAwLCBcbiAgJ2VxdWl2Jzo4ODAxLCBcbiAgJ2xlJzo4ODA0LCBcbiAgJ2dlJzo4ODA1LCBcbiAgJ3N1Yic6ODgzNCwgXG4gICdzdXAnOjg4MzUsIFxuICAnbnN1Yic6ODgzNiwgXG4gICdzdWJlJzo4ODM4LCBcbiAgJ3N1cGUnOjg4MzksIFxuICAnb3BsdXMnOjg4NTMsIFxuICAnb3RpbWVzJzo4ODU1LCBcbiAgJ3BlcnAnOjg4NjksIFxuICAnc2RvdCc6ODkwMSwgXG4gICdsY2VpbCc6ODk2OCwgXG4gICdyY2VpbCc6ODk2OSwgXG4gICdsZmxvb3InOjg5NzAsIFxuICAncmZsb29yJzo4OTcxLCBcbiAgJ2xhbmcnOjkwMDEsIFxuICAncmFuZyc6OTAwMiwgXG4gICdsb3onOjk2NzQsIFxuICAnc3BhZGVzJzo5ODI0LCBcbiAgJ2NsdWJzJzo5ODI3LCBcbiAgJ2hlYXJ0cyc6OTgyOSwgXG4gICdkaWFtcyc6OTgzMCwgXG4gICdPRWxpZyc6MzM4LCBcbiAgJ29lbGlnJzozMzksIFxuICAnU2Nhcm9uJzozNTIsIFxuICAnc2Nhcm9uJzozNTMsIFxuICAnWXVtbCc6Mzc2LCBcbiAgJ2NpcmMnOjcxMCwgXG4gICd0aWxkZSc6NzMyLCBcbiAgJ2Vuc3AnOjgxOTQsIFxuICAnZW1zcCc6ODE5NSwgXG4gICd0aGluc3AnOjgyMDEsIFxuICAnenduaic6ODIwNCwgXG4gICd6d2onOjgyMDUsIFxuICAnbHJtJzo4MjA2LCBcbiAgJ3JsbSc6ODIwNywgXG4gICduZGFzaCc6ODIxMSwgXG4gICdtZGFzaCc6ODIxMiwgXG4gICdsc3F1byc6ODIxNiwgXG4gICdyc3F1byc6ODIxNywgXG4gICdzYnF1byc6ODIxOCwgXG4gICdsZHF1byc6ODIyMCwgXG4gICdyZHF1byc6ODIyMSwgXG4gICdiZHF1byc6ODIyMiwgXG4gICdkYWdnZXInOjgyMjQsIFxuICAnRGFnZ2VyJzo4MjI1LCBcbiAgJ3Blcm1pbCc6ODI0MCwgXG4gICdsc2FxdW8nOjgyNDksIFxuICAncnNhcXVvJzo4MjUwLCBcbiAgJ2V1cm8nOjgzNjRcbn1cblxuXG5cbm1vZHVsZS5leHBvcnRzICA9IGVudGl0aWVzOyIsIi8vIHNpbXBsZXN0IGV2ZW50IGVtaXR0ZXIgNjAgbGluZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbnZhciBfID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG52YXIgQVBJID0ge1xuICAkb246IGZ1bmN0aW9uKGV2ZW50LCBmbiwgZGVzYykge1xuICAgIGlmKHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCl7XG4gICAgICBmb3IgKHZhciBpIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuJG9uKGksIGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBkZXNjID0gZGVzYyB8fCB7fTtcbiAgICAgIC8vIEBwYXRjaDogZm9yIGxpc3RcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIHZhciBoYW5kbGVzID0gY29udGV4dC5faGFuZGxlcyB8fCAoY29udGV4dC5faGFuZGxlcyA9IHt9KSxcbiAgICAgICAgY2FsbHMgPSBoYW5kbGVzW2V2ZW50XSB8fCAoaGFuZGxlc1tldmVudF0gPSBbXSk7XG4gICAgICB2YXIgcmVhbEZuO1xuICAgICAgaWYoZGVzYy5vbmNlKXtcbiAgICAgICAgcmVhbEZuID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICB0aGlzLiRvZmYoZXZlbnQsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBmbi5yZWFsID0gcmVhbEZuO1xuICAgICAgfVxuICAgICAgY2FsbHMucHVzaChyZWFsRm4gfHwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgJG9mZjogZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIGlmKCFjb250ZXh0Ll9oYW5kbGVzKSByZXR1cm47XG4gICAgaWYoIWV2ZW50KSB0aGlzLl9oYW5kbGVzID0ge307XG4gICAgdmFyIGhhbmRsZXMgPSBjb250ZXh0Ll9oYW5kbGVzLFxuICAgICAgY2FsbHM7XG5cbiAgICBpZiAoY2FsbHMgPSBoYW5kbGVzW2V2ZW50XSkge1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICBoYW5kbGVzW2V2ZW50XSA9IFtdO1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGZuID0gZm4ucmVhbCB8fCBmbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZm4gPT09IGNhbGxzW2ldKSB7XG4gICAgICAgICAgY2FsbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xuICB9LFxuICAvLyBidWJibGUgZXZlbnRcbiAgJGVtaXQ6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAvLyBAcGF0Y2g6IGZvciBsaXN0XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIHZhciBoYW5kbGVzID0gY29udGV4dC5faGFuZGxlcywgY2FsbHMsIGFyZ3MsIHR5cGU7XG4gICAgaWYoIWV2ZW50KSByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBfLnNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIHR5cGUgPSBldmVudDtcblxuICAgIGlmKCFoYW5kbGVzKSByZXR1cm4gY29udGV4dDtcbiAgICBpZihjYWxscyA9IGhhbmRsZXNbdHlwZS5zbGljZSgxKV0pe1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGNhbGxzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGNhbGxzW2pdLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghKGNhbGxzID0gaGFuZGxlc1t0eXBlXSkpIHJldHVybiBjb250ZXh0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbHNbaV0uYXBwbHkoY29udGV4dCwgYXJncylcbiAgICB9XG4gICAgLy8gaWYoY2FsbHMubGVuZ3RoKSBjb250ZXh0LiR1cGRhdGUoKTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSxcbiAgLy8gY2FwdHVyZSAgZXZlbnRcbiAgJG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gICAgdmFyIGFyZ3MgPSBfLnNsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy5wdXNoKHtvbmNlOiB0cnVlfSlcbiAgICByZXR1cm4gdGhpcy4kb24uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn1cbi8vIGNvbnRhaW5lciBjbGFzc1xuZnVuY3Rpb24gRXZlbnQoKSB7fVxuXy5leHRlbmQoRXZlbnQucHJvdG90eXBlLCBBUEkpXG5cbkV2ZW50Lm1peFRvID0gZnVuY3Rpb24ob2JqKXtcbiAgb2JqID0gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID8gb2JqLnByb3RvdHlwZSA6IG9iajtcbiAgXy5leHRlbmQob2JqLCBBUEkpXG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50OyIsIi8vIChjKSAyMDEwLTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gaHR0cDovL2JhY2tib25lanMub3JnXG5cbi8vIGtsYXNzOiBhIGNsYXNzaWNhbCBKUyBPT1AgZmHDp2FkZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlZC9rbGFzc1xuLy8gTGljZW5zZSBNSVQgKGMpIER1c3RpbiBEaWF6IDIwMTRcbiAgXG4vLyBpbnNwaXJlZCBieSBiYWNrYm9uZSdzIGV4dGVuZCBhbmQga2xhc3NcbnZhciBfID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gIGZuVGVzdCA9IC94eS8udGVzdChmdW5jdGlvbigpe1wieHlcIjt9KSA/IC9cXGJzdXByXFxiLzovLiovLFxuICBpc0ZuID0gZnVuY3Rpb24obyl7cmV0dXJuIHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCJ9O1xuXG52YXIgaG9va3MgPSB7XG4gIGV2ZW50czogZnVuY3Rpb24oIHByb3BlcnR5VmFsdWUsIHByb3RvICl7XG4gICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gcHJvdG8uX2V2ZW50TGlzdGVuZXJzIHx8IFtdO1xuICAgIHZhciBub3JtZWRFdmVudHMgPSBfLm5vcm1MaXN0ZW5lcihwcm9wZXJ0eVZhbHVlKTtcblxuICAgIGlmKG5vcm1lZEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIHByb3RvLl9ldmVudExpc3RlbmVycyA9IGV2ZW50TGlzdGVuZXJzLmNvbmNhdCggbm9ybWVkRXZlbnRzICk7XG4gICAgfVxuICAgIGRlbGV0ZSBwcm90by5ldmVudHMgO1xuICB9XG59XG5cblxuZnVuY3Rpb24gd3JhcCggaywgZm4sIHN1cHJvICkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bXAgPSB0aGlzLnN1cHI7XG4gICAgdGhpcy5zdXByID0gc3Vwcm9ba107XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdXByID0gdG1wO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzcyggd2hhdCwgbywgc3Vwcm8gKSB7XG4gIGZvciAoIHZhciBrIGluIG8gKSB7XG4gICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgIGlmKGhvb2tzW2tdKSB7XG4gICAgICAgIGhvb2tzW2tdKG9ba10sIHdoYXQsIHN1cHJvKVxuICAgICAgfVxuICAgICAgd2hhdFtrXSA9IGlzRm4oIG9ba10gKSAmJiBpc0ZuKCBzdXByb1trXSApICYmIFxuICAgICAgICBmblRlc3QudGVzdCggb1trXSApID8gd3JhcChrLCBvW2tdLCBzdXBybykgOiBvW2tdO1xuICAgIH1cbiAgfVxufVxuXG4vLyBpZiB0aGUgcHJvcGVydHkgaXMgW1wiZXZlbnRzXCIsIFwiZGF0YVwiLCBcImNvbXB1dGVkXCJdICwgd2Ugc2hvdWxkIG1lcmdlIHRoZW1cbnZhciBtZXJnZWQgPSBbXCJkYXRhXCIsIFwiY29tcHV0ZWRcIl0sIG1sZW4gPSBtZXJnZWQubGVuZ3RoO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQobyl7XG4gIG8gPSBvIHx8IHt9O1xuICB2YXIgc3VwciA9IHRoaXMsIHByb3RvLFxuICAgIHN1cHJvID0gc3VwciAmJiBzdXByLnByb3RvdHlwZSB8fCB7fTtcblxuICBpZih0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgcHJvdG8gPSBvLnByb3RvdHlwZTtcbiAgICBvLmltcGxlbWVudCA9IGltcGxlbWVudDtcbiAgICBvLmV4dGVuZCA9IGV4dGVuZDtcbiAgICByZXR1cm4gbztcbiAgfSBcbiAgXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHN1cHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHByb3RvID0gXy5jcmVhdGVQcm90byhmbiwgc3Vwcm8pO1xuXG4gIGZ1bmN0aW9uIGltcGxlbWVudChvKXtcbiAgICAvLyB3ZSBuZWVkIG1lcmdlIHRoZSBtZXJnZWQgcHJvcGVydHlcbiAgICB2YXIgbGVuID0gbWxlbjtcbiAgICBmb3IoO2xlbi0tOyl7XG4gICAgICB2YXIgcHJvcCA9IG1lcmdlZFtsZW5dO1xuICAgICAgaWYocHJvdG9bcHJvcF0gJiYgby5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwcm90by5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7XG4gICAgICAgIF8uZXh0ZW5kKHByb3RvW3Byb3BdLCBvW3Byb3BdLCB0cnVlKSBcbiAgICAgICAgZGVsZXRlIG9bcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBwcm9jZXNzKHByb3RvLCBvLCBzdXBybyk7IFxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblxuXG4gIGZuLmltcGxlbWVudCA9IGltcGxlbWVudFxuICBmbi5pbXBsZW1lbnQobylcbiAgaWYoc3Vwci5fX2FmdGVyX18pIHN1cHIuX19hZnRlcl9fLmNhbGwoZm4sIHN1cHIsIG8pO1xuICBmbi5leHRlbmQgPSBleHRlbmQ7XG4gIHJldHVybiBmbjtcbn1cblxuIiwiXG52YXIgZiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGpzb246ICB0d28gd2F5IFxuLy8gIC0gZ2V0OiBKU09OLnN0cmluZ2lmeVxuLy8gIC0gc2V0OiBKU09OLnBhcnNlXG4vLyAgLSBleGFtcGxlOiBgeyB0aXRsZXxqc29uIH1gXG5mLmpzb24gPSB7XG4gIGdldDogZnVuY3Rpb24oIHZhbHVlICl7XG4gICAgcmV0dXJuIHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJz8gSlNPTi5zdHJpbmdpZnkodmFsdWUpOiB2YWx1ZTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKXtcbiAgICByZXR1cm4gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlO1xuICB9XG59XG5cbi8vIGxhc3Q6IG9uZS13YXlcbi8vICAtIGdldDogcmV0dXJuIHRoZSBsYXN0IGl0ZW0gaW4gbGlzdFxuLy8gIC0gZXhhbXBsZTogYHsgbGlzdHxsYXN0IH1gXG5mLmxhc3QgPSBmdW5jdGlvbihhcnIpe1xuICByZXR1cm4gYXJyICYmIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbi8vIGF2ZXJhZ2U6IG9uZS13YXlcbi8vICAtIGdldDogY29wdXRlIHRoZSBhdmVyYWdlIG9mIHRoZSBsaXN0XG4vLyAgLSBleGFtcGxlOiBgeyBsaXN0fCBhdmVyYWdlOiBcInNjb3JlXCIgfWBcbmYuYXZlcmFnZSA9IGZ1bmN0aW9uKGFycmF5LCBrZXkpe1xuICBhcnJheSA9IGFycmF5IHx8IFtdO1xuICByZXR1cm4gYXJyYXkubGVuZ3RoPyBmLnRvdGFsKGFycmF5LCBrZXkpLyBhcnJheS5sZW5ndGggOiAwO1xufVxuXG5cbi8vIHRvdGFsOiBvbmUtd2F5XG4vLyAgLSBnZXQ6IGNvcHV0ZSB0aGUgdG90YWwgb2YgdGhlIGxpc3Rcbi8vICAtIGV4YW1wbGU6IGB7IGxpc3R8IHRvdGFsOiBcInNjb3JlXCIgfWBcbmYudG90YWwgPSBmdW5jdGlvbihhcnJheSwga2V5KXtcbiAgdmFyIHRvdGFsID0gMDtcbiAgaWYoIWFycmF5KSByZXR1cm47XG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24oIGl0ZW0gKXtcbiAgICB0b3RhbCArPSBrZXk/IGl0ZW1ba2V5XSA6IGl0ZW07XG4gIH0pXG4gIHJldHVybiB0b3RhbDtcbn1cblxuLy8gdmFyIGJhc2ljU29ydEZuID0gZnVuY3Rpb24oYSwgYil7cmV0dXJuIGIgLSBhfVxuXG4vLyBmLnNvcnQgPSBmdW5jdGlvbihhcnJheSwga2V5LCByZXZlcnNlKXtcbi8vICAgdmFyIHR5cGUgPSB0eXBlb2Yga2V5LCBzb3J0Rm47IFxuLy8gICBzd2l0Y2godHlwZSl7XG4vLyAgICAgY2FzZSAnZnVuY3Rpb24nOiBzb3J0Rm4gPSBrZXk7IGJyZWFrO1xuLy8gICAgIGNhc2UgJ3N0cmluZyc6IHNvcnRGbiA9IGZ1bmN0aW9uKGEsIGIpe307YnJlYWs7XG4vLyAgICAgZGVmYXVsdDpcbi8vICAgICAgIHNvcnRGbiA9IGJhc2ljU29ydEZuO1xuLy8gICB9XG4vLyAgIC8vIG5lZWQgb3RoZXIgcmVmZXJuY2UuXG4vLyAgIHJldHVybiBhcnJheS5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXtcbi8vICAgICByZXR1cm4gcmV2ZXJzZT8gLXNvcnRGbihhLCBiKTogc29ydEZuKGEsIGIpO1xuLy8gICB9KVxuLy8gICByZXR1cm4gYXJyYXlcbi8vIH1cblxuXG4iLCJ2YXIgZXhwckNhY2hlID0gcmVxdWlyZSgnLi4vZW52JykuZXhwckNhY2hlO1xudmFyIF8gPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi4vcGFyc2VyL1BhcnNlclwiKTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHByZXNzaW9uOiBmdW5jdGlvbihleHByLCBzaW1wbGUpe1xuICAgIC8vIEBUT0RPIGNhY2hlXG4gICAgaWYoIHR5cGVvZiBleHByID09PSAnc3RyaW5nJyAmJiAoIGV4cHIgPSBleHByLnRyaW0oKSApICl7XG4gICAgICBleHByID0gZXhwckNhY2hlLmdldCggZXhwciApIHx8IGV4cHJDYWNoZS5zZXQoIGV4cHIsIG5ldyBQYXJzZXIoIGV4cHIsIHsgbW9kZTogMiwgZXhwcmVzc2lvbjogdHJ1ZSB9ICkuZXhwcmVzc2lvbigpIClcbiAgICB9XG4gICAgaWYoZXhwcikgcmV0dXJuIGV4cHI7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbih0ZW1wbGF0ZSl7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXIodGVtcGxhdGUpLnBhcnNlKCk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgZXM1XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciB0c3RyID0gKHt9KS50b1N0cmluZztcblxuZnVuY3Rpb24gZXh0ZW5kKG8xLCBvMiApe1xuICBmb3IodmFyIGkgaW4gbzIpIGlmKCBvMVtpXSA9PT0gdW5kZWZpbmVkKXtcbiAgICBvMVtpXSA9IG8yW2ldXG4gIH1cbiAgcmV0dXJuIG8yO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgLy8gU3RyaW5nIHByb3RvIDtcbiAgZXh0ZW5kKFN0cmluZy5wcm90b3R5cGUsIHtcbiAgICB0cmltOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgIH1cbiAgfSk7XG5cblxuICAvLyBBcnJheSBwcm90bztcbiAgZXh0ZW5kKEFycmF5LnByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKG9iaiwgZnJvbSl7XG4gICAgICBmcm9tID0gZnJvbSB8fCAwO1xuICAgICAgZm9yICh2YXIgaSA9IGZyb20sIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXNbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICAvLyBwb2x5ZmlsbCBmcm9tIE1ETiBcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIGN0eCl7XG4gICAgICB2YXIgayA9IDA7XG5cbiAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nIHRoZSB8dGhpc3wgdmFsdWUgYXMgdGhlIGFyZ3VtZW50LlxuICAgICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XG5cbiAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDsgXG5cbiAgICAgIGlmICggdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIGNhbGxiYWNrICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIiApO1xuICAgICAgfVxuXG4gICAgICAvLyA3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cbiAgICAgIHdoaWxlKCBrIDwgbGVuICkge1xuXG4gICAgICAgIHZhciBrVmFsdWU7XG5cbiAgICAgICAgaWYgKCBrIGluIE8gKSB7XG5cbiAgICAgICAgICBrVmFsdWUgPSBPWyBrIF07XG5cbiAgICAgICAgICBjYWxsYmFjay5jYWxsKCBjdHgsIGtWYWx1ZSwgaywgTyApO1xuICAgICAgICB9XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgLy8gIHdpbGwgYmUgcmVtb3ZlZCBhdCAwLjUuMFxuICAgIGZpbHRlcjogZnVuY3Rpb24oZnVuLCBjb250ZXh0KXtcblxuICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB7XG4gICAgICAgIGlmIChpIGluIHQpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdmFsID0gdFtpXTtcbiAgICAgICAgICBpZiAoZnVuLmNhbGwoY29udGV4dCwgdmFsLCBpLCB0KSlcbiAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZ1bmN0aW9uIHByb3RvO1xuICBleHRlbmQoRnVuY3Rpb24ucHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24oY29udGV4dCl7XG4gICAgICB2YXIgZm4gPSB0aGlzO1xuICAgICAgdmFyIHByZUFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFyZ3MgPSBwcmVBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvL0BGSVhJVFxuICAgIF9fYmluZF9fOiBmdW5jdGlvbihjb250ZXh0KXtcbiAgICAgIGlmKHRoaXMuX19iaW5kaW5nX18pe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2JpbmRpbmdfX1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiAodGhpcy5fX2JpbmRpbmdfXyA9IHRoaXMuYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIEFycmF5XG4gIGV4dGVuZChBcnJheSwge1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uKGFycil7XG4gICAgICByZXR1cm4gdHN0ci5jYWxsKGFycikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9XG4gIH0pXG59XG5cbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHBhcnNlRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4vcGFyc2UnKS5leHByZXNzaW9uO1xudmFyIGRpZmYgPSByZXF1aXJlKCcuL2RpZmYnKTtcbnZhciBkaWZmQXJyYXkgPSBkaWZmLmRpZmZBcnJheTtcbnZhciBkaWZmT2JqZWN0ID0gZGlmZi5kaWZmT2JqZWN0O1xuXG5mdW5jdGlvbiBXYXRjaGVyKCl7fVxuXG52YXIgbWV0aG9kcyA9IHtcbiAgJHdhdGNoOiBmdW5jdGlvbihleHByLCBmbiwgb3B0aW9ucyl7XG4gICAgdmFyIGdldCwgb25jZSwgdGVzdCwgcmxlbiwgZXh0cmEgPSB0aGlzLl9fZXh0X187IC8vcmVjb3JkcyBsZW5ndGhcbiAgICBpZighdGhpcy5fd2F0Y2hlcnMpIHRoaXMuX3dhdGNoZXJzID0gW107XG4gICAgaWYoIXRoaXMuX3dhdGNoZXJzRm9yU3RhYmxlKSB0aGlzLl93YXRjaGVyc0ZvclN0YWJsZSA9IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYob3B0aW9ucyA9PT0gdHJ1ZSl7XG4gICAgICAgb3B0aW9ucyA9IHsgZGVlcDogdHJ1ZSB9XG4gICAgfVxuICAgIHZhciB1aWQgPSBfLnVpZCgnd18nKTtcbiAgICBpZihBcnJheS5pc0FycmF5KGV4cHIpKXtcbiAgICAgIHZhciB0ZXN0cyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMCxsZW4gPSBleHByLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICB0ZXN0cy5wdXNoKHRoaXMuJGV4cHJlc3Npb24oZXhwcltpXSkuZ2V0KVxuICAgICAgfVxuICAgICAgdmFyIHByZXYgPSBbXTtcbiAgICAgIHRlc3QgPSBmdW5jdGlvbihjb250ZXh0KXtcbiAgICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yKHZhciBpID0wLCBsZW4gPSB0ZXN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgdmFyIHNwbGljZSA9IHRlc3RzW2ldKGNvbnRleHQsIGV4dHJhKTtcbiAgICAgICAgICBpZighXy5lcXVhbHMoc3BsaWNlLCBwcmV2W2ldKSl7XG4gICAgICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICBwcmV2W2ldID0gXy5jbG9uZShzcGxpY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWw/IGZhbHNlOiBwcmV2O1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgaWYodHlwZW9mIGV4cHIgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICBnZXQgPSBleHByLmJpbmQodGhpcyk7ICAgICAgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXhwciA9IHRoaXMuJGV4cHJlc3Npb24oZXhwcik7XG4gICAgICAgIGdldCA9IGV4cHIuZ2V0O1xuICAgICAgICBvbmNlID0gZXhwci5vbmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3YXRjaGVyID0ge1xuICAgICAgaWQ6IHVpZCwgXG4gICAgICBnZXQ6IGdldCwgXG4gICAgICBmbjogZm4sIFxuICAgICAgb25jZTogb25jZSwgXG4gICAgICBmb3JjZTogb3B0aW9ucy5mb3JjZSxcbiAgICAgIC8vIGRvbid0IHVzZSBsZCB0byByZXNvbHZlIGFycmF5IGRpZmZcbiAgICAgIGRpZmY6IG9wdGlvbnMuZGlmZixcbiAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICBkZWVwOiBvcHRpb25zLmRlZXAsXG4gICAgICBsYXN0OiBvcHRpb25zLnN5bmM/IGdldCh0aGlzKTogb3B0aW9ucy5sYXN0XG4gICAgfVxuXG5cbiAgICB0aGlzW29wdGlvbnMuc3RhYmxlPyAnX3dhdGNoZXJzRm9yU3RhYmxlJzogJ193YXRjaGVycyddLnB1c2god2F0Y2hlcik7XG4gICAgXG4gICAgcmxlbiA9IHRoaXMuX3JlY29yZHMgJiYgdGhpcy5fcmVjb3Jkcy5sZW5ndGg7XG4gICAgaWYocmxlbikgdGhpcy5fcmVjb3Jkc1tybGVuLTFdLnB1c2god2F0Y2hlcilcbiAgICAvLyBpbml0IHN0YXRlLlxuICAgIGlmKG9wdGlvbnMuaW5pdCA9PT0gdHJ1ZSl7XG4gICAgICB2YXIgcHJlcGhhc2UgPSB0aGlzLiRwaGFzZTtcbiAgICAgIHRoaXMuJHBoYXNlID0gJ2RpZ2VzdCc7XG4gICAgICB0aGlzLl9jaGVja1NpbmdsZVdhdGNoKCB3YXRjaGVyKTtcbiAgICAgIHRoaXMuJHBoYXNlID0gcHJlcGhhc2U7XG4gICAgfVxuICAgIHJldHVybiB3YXRjaGVyO1xuICB9LFxuICAkdW53YXRjaDogZnVuY3Rpb24oIHdhdGNoZXIgKXtcbiAgICBpZighdGhpcy5fd2F0Y2hlcnMgfHwgIXdhdGNoZXIpIHJldHVybjtcbiAgICB2YXIgd2F0Y2hlcnMgPSB0aGlzLl93YXRjaGVycztcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB3YXRjaGVyO1xuXG4gICAgaWYodHlwZSA9PT0gJ29iamVjdCcpe1xuICAgICAgdmFyIGxlbiA9IHdhdGNoZXIubGVuZ3RoO1xuICAgICAgaWYoIWxlbil7XG4gICAgICAgIHdhdGNoZXIucmVtb3ZlZCA9IHRydWVcbiAgICAgIH1lbHNle1xuICAgICAgICB3aGlsZSggKGxlbi0tKSA+PSAwICl7XG4gICAgICAgICAgdGhpcy4kdW53YXRjaCh3YXRjaGVyW2xlbl0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0eXBlID09PSAnbnVtYmVyJyl7XG4gICAgICB2YXIgaWQgPSB3YXRjaGVyO1xuICAgICAgd2F0Y2hlciA9ICBfLmZpbmRJdGVtKCB3YXRjaGVycywgZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgIHJldHVybiBpdGVtLmlkID09PSBpZDtcbiAgICAgIH0gKTtcbiAgICAgIGlmKCF3YXRjaGVyKSB3YXRjaGVyID0gXy5maW5kSXRlbSh0aGlzLl93YXRjaGVyc0ZvclN0YWJsZSwgZnVuY3Rpb24oIGl0ZW0gKXtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IGlkXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXMuJHVud2F0Y2god2F0Y2hlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAkZXhwcmVzc2lvbjogZnVuY3Rpb24odmFsdWUpe1xuICAgIHJldHVybiB0aGlzLl90b3VjaEV4cHIocGFyc2VFeHByZXNzaW9uKHZhbHVlKSlcbiAgfSxcbiAgLyoqXG4gICAqIHRoZSB3aG9sZSBkaWdlc3QgbG9vcCAsanVzdCBsaWtlIGFuZ3VsYXIsIGl0IGp1c3QgYSBkaXJ0eS1jaGVjayBsb29wO1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggIG5vdyByZWd1bGFyIHByb2Nlc3MgYSBwdXJlIGRpcnR5LWNoZWNrIGxvb3AsIGJ1dCBpbiBwYXJzZSBwaGFzZSwgXG4gICAqICAgICAgICAgICAgICAgICAgUmVndWxhcidzIHBhcnNlciBleHRyYWN0IHRoZSBkZXBlbmRlbmNpZXMsIGluIGZ1dHVyZSBtYXliZSBpdCB3aWxsIGNoYW5nZSB0byBkaXJ0eS1jaGVjayBjb21iaW5lIHdpdGggcGF0aC1hd2FyZSB1cGRhdGU7XG4gICAqIEByZXR1cm4ge1ZvaWR9ICAgXG4gICAqL1xuXG4gICRkaWdlc3Q6IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy4kcGhhc2UgPT09ICdkaWdlc3QnIHx8IHRoaXMuX211dGUpIHJldHVybjtcbiAgICB0aGlzLiRwaGFzZSA9ICdkaWdlc3QnO1xuICAgIHZhciBkaXJ0eSA9IGZhbHNlLCBuID0wO1xuICAgIHdoaWxlKGRpcnR5ID0gdGhpcy5fZGlnZXN0KCkpe1xuXG4gICAgICBpZigoKytuKSA+IDIwKXsgLy8gbWF4IGxvb3BcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3RoZXJlIG1heSBhIGNpcmN1bGFyIGRlcGVuZGVuY2llcyByZWFjaGVzJylcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3RhYmxlIHdhdGNoIGlzIGRpcnR5XG4gICAgdmFyIHN0YWJsZURpcnR5ID0gIHRoaXMuX2RpZ2VzdCh0cnVlKTtcblxuICAgIGlmKCAobiA+IDAgfHwgc3RhYmxlRGlydHkpICYmIHRoaXMuJGVtaXQpIHtcbiAgICAgIHRoaXMuJGVtaXQoXCIkdXBkYXRlXCIpO1xuICAgICAgaWYgKHRoaXMuZGV2dG9vbHMpIHtcbiAgICAgICAgdGhpcy5kZXZ0b29scy5lbWl0KFwiZmx1c2hcIiwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4kcGhhc2UgPSBudWxsO1xuICB9LFxuICAvLyBwcml2YXRlIGRpZ2VzdCBsb2dpY1xuICBfZGlnZXN0OiBmdW5jdGlvbihzdGFibGUpe1xuICAgIGlmKHRoaXMuX211dGUpIHJldHVybjtcbiAgICB2YXIgd2F0Y2hlcnMgPSAhc3RhYmxlPyB0aGlzLl93YXRjaGVyczogdGhpcy5fd2F0Y2hlcnNGb3JTdGFibGU7XG4gICAgdmFyIGRpcnR5ID0gZmFsc2UsIGNoaWxkcmVuLCB3YXRjaGVyLCB3YXRjaGVyRGlydHk7XG4gICAgdmFyIGxlbiA9IHdhdGNoZXJzICYmIHdhdGNoZXJzLmxlbmd0aDtcbiAgICBpZihsZW4pe1xuICAgICAgdmFyIG1hcmsgPSAwLCBuZWVkUmVtb3ZlZD0wO1xuICAgICAgZm9yKHZhciBpID0wOyBpIDwgbGVuOyBpKysgKXtcbiAgICAgICAgd2F0Y2hlciA9IHdhdGNoZXJzW2ldO1xuICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gIXdhdGNoZXIgfHwgIHdhdGNoZXIucmVtb3ZlZDtcbiAgICAgICAgaWYoIHNob3VsZFJlbW92ZSApe1xuICAgICAgICAgIG5lZWRSZW1vdmVkICs9IDE7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHdhdGNoZXJEaXJ0eSA9IHRoaXMuX2NoZWNrU2luZ2xlV2F0Y2god2F0Y2hlcik7XG4gICAgICAgICAgaWYod2F0Y2hlckRpcnR5KSBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHdoZW4gZW5jb3VudGVyIGZpcnN0IHVubW92ZWQgaXRlbSBvciB0b3VjaCB0aGUgZW5kXG4gICAgICAgIGlmKCAhc2hvdWxkUmVtb3ZlIHx8IGkgPT09IGxlbi0xICl7XG4gICAgICAgICAgaWYoIG5lZWRSZW1vdmVkICl7XG4gICAgICAgICAgICB3YXRjaGVycy5zcGxpY2UobWFyaywgbmVlZFJlbW92ZWQgKTsgICAgICAgICAgXG4gICAgICAgICAgICBsZW4gLT0gbmVlZFJlbW92ZWQ7XG4gICAgICAgICAgICBpIC09IG5lZWRSZW1vdmVkO1xuICAgICAgICAgICAgbmVlZFJlbW92ZWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrID0gaSsxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGNoaWxkcmVuJ3MgZGlydHkuXG4gICAgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBpZihjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpe1xuICAgICAgZm9yKHZhciBtID0gMCwgbWxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgbSA8IG1sZW47IG0rKyl7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW21dO1xuICAgICAgICBpZihjaGlsZCAmJiBjaGlsZC5fZGlnZXN0KHN0YWJsZSkpIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcnR5O1xuICB9LFxuICAvLyBjaGVjayBhIHNpbmdsZSBvbmUgd2F0Y2hlciBcbiAgX2NoZWNrU2luZ2xlV2F0Y2g6IGZ1bmN0aW9uKHdhdGNoZXIpe1xuICAgIHZhciBkaXJ0eSA9IGZhbHNlO1xuICAgIGlmKCF3YXRjaGVyKSByZXR1cm47XG5cbiAgICB2YXIgbm93LCBsYXN0LCB0bGFzdCwgdG5vdywgIGVxLCBkaWZmO1xuXG4gICAgaWYoIXdhdGNoZXIudGVzdCl7XG5cbiAgICAgIG5vdyA9IHdhdGNoZXIuZ2V0KHRoaXMpO1xuICAgICAgbGFzdCA9IHdhdGNoZXIubGFzdDtcblxuICAgICAgaWYobm93ICE9PSBsYXN0IHx8IHdhdGNoZXIuZm9yY2Upe1xuICAgICAgICB0bGFzdCA9IF8udHlwZU9mKGxhc3QpO1xuICAgICAgICB0bm93ID0gXy50eXBlT2Yobm93KTtcbiAgICAgICAgZXEgPSB0cnVlOyBcblxuICAgICAgICAvLyAhT2JqZWN0XG4gICAgICAgIGlmKCAhKHRub3cgPT09ICdvYmplY3QnICYmIHRsYXN0PT09J29iamVjdCcgJiYgd2F0Y2hlci5kZWVwKSApe1xuICAgICAgICAgIC8vIEFycmF5XG4gICAgICAgICAgaWYoIHRub3cgPT09ICdhcnJheScgJiYgKCB0bGFzdD09J3VuZGVmaW5lZCcgfHwgdGxhc3QgPT09ICdhcnJheScpICl7XG4gICAgICAgICAgICBkaWZmID0gZGlmZkFycmF5KG5vdywgd2F0Y2hlci5sYXN0IHx8IFtdLCB3YXRjaGVyLmRpZmYpXG4gICAgICAgICAgICBpZiggdGxhc3QgIT09ICdhcnJheScgfHwgZGlmZiA9PT0gdHJ1ZSB8fCBkaWZmLmxlbmd0aCApIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGVxID0gXy5lcXVhbHMoIG5vdywgbGFzdCApO1xuICAgICAgICAgICAgaWYoICFlcSB8fCB3YXRjaGVyLmZvcmNlICl7XG4gICAgICAgICAgICAgIHdhdGNoZXIuZm9yY2UgPSBudWxsO1xuICAgICAgICAgICAgICBkaXJ0eSA9IHRydWU7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgZGlmZiA9ICBkaWZmT2JqZWN0KCBub3csIGxhc3QsIHdhdGNoZXIuZGlmZiApO1xuICAgICAgICAgIGlmKCBkaWZmID09PSB0cnVlIHx8IGRpZmYubGVuZ3RoICkgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2V7XG4gICAgICAvLyBAVE9ETyDmmK/lkKbmiorlpJrph43mlLnmjolcbiAgICAgIHZhciByZXN1bHQgPSB3YXRjaGVyLnRlc3QodGhpcyk7XG4gICAgICBpZihyZXN1bHQpe1xuICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIHdhdGNoZXIuZm4uYXBwbHkodGhpcywgcmVzdWx0KVxuICAgICAgfVxuICAgIH1cbiAgICBpZihkaXJ0eSAmJiAhd2F0Y2hlci50ZXN0KXtcbiAgICAgIGlmKHRub3cgPT09ICdvYmplY3QnICYmIHdhdGNoZXIuZGVlcCB8fCB0bm93ID09PSAnYXJyYXknKXtcbiAgICAgICAgd2F0Y2hlci5sYXN0ID0gXy5jbG9uZShub3cpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHdhdGNoZXIubGFzdCA9IG5vdztcbiAgICAgIH1cbiAgICAgIHdhdGNoZXIuZm4uY2FsbCh0aGlzLCBub3csIGxhc3QsIGRpZmYpXG4gICAgICBpZih3YXRjaGVyLm9uY2UpIHRoaXMuJHVud2F0Y2god2F0Y2hlcilcbiAgICB9XG5cbiAgICByZXR1cm4gZGlydHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqICoqdGlwcyoqOiB3aGF0ZXZlciBwYXJhbSB5b3UgcGFzc2VkIGluICR1cGRhdGUsIGFmdGVyIHRoZSBmdW5jdGlvbiBjYWxsZWQsIGRpcnR5LWNoZWNrKGRpZ2VzdCkgcGhhc2Ugd2lsbCBlbnRlcjtcbiAgICogXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufFN0cmluZ3xFeHByZXNzaW9ufSBwYXRoICBcbiAgICogQHBhcmFtICB7V2hhdGV2ZXJ9IHZhbHVlIG9wdGlvbmFsLCB3aGVuIHBhdGggaXMgRnVuY3Rpb24sIHRoZSB2YWx1ZSBpcyBpZ25vcmVkXG4gICAqIEByZXR1cm4ge3RoaXN9ICAgICB0aGlzIFxuICAgKi9cbiAgJHNldDogZnVuY3Rpb24ocGF0aCwgdmFsdWUpe1xuICAgIGlmKHBhdGggIT0gbnVsbCl7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiAocGF0aCk7XG4gICAgICBpZiggdHlwZSA9PT0gJ3N0cmluZycgfHwgcGF0aC50eXBlID09PSAnZXhwcmVzc2lvbicgKXtcbiAgICAgICAgcGF0aCA9IHRoaXMuJGV4cHJlc3Npb24ocGF0aCk7XG4gICAgICAgIHBhdGguc2V0KHRoaXMsIHZhbHVlKTtcbiAgICAgIH1lbHNlIGlmKHR5cGUgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICBwYXRoLmNhbGwodGhpcywgdGhpcy5kYXRhKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBmb3IodmFyIGkgaW4gcGF0aCkge1xuICAgICAgICAgIHRoaXMuJHNldChpLCBwYXRoW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyAxLiBleHByIGNhbmJlIHN0cmluZyBvciBhIEV4cHJlc3Npb25cbiAgLy8gMi4gZGV0ZWN0OiBpZiB0cnVlLCBpZiBleHByIGlzIGEgc3RyaW5nIHdpbGwgZGlyZWN0bHkgcmV0dXJuO1xuICAkZ2V0OiBmdW5jdGlvbihleHByLCBkZXRlY3QpICB7XG4gICAgaWYoZGV0ZWN0ICYmIHR5cGVvZiBleHByID09PSAnc3RyaW5nJykgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuJGV4cHJlc3Npb24oZXhwcikuZ2V0KHRoaXMpO1xuICB9LFxuICAkdXBkYXRlOiBmdW5jdGlvbigpe1xuICAgIHZhciByb290UGFyZW50ID0gdGhpcztcbiAgICBkb3tcbiAgICAgIGlmKHJvb3RQYXJlbnQuZGF0YS5pc29sYXRlIHx8ICFyb290UGFyZW50LiRwYXJlbnQpIGJyZWFrO1xuICAgICAgcm9vdFBhcmVudCA9IHJvb3RQYXJlbnQuJHBhcmVudDtcbiAgICB9IHdoaWxlKHJvb3RQYXJlbnQpXG5cbiAgICB2YXIgcHJlcGhhc2UgPXJvb3RQYXJlbnQuJHBoYXNlO1xuICAgIHJvb3RQYXJlbnQuJHBoYXNlID0gJ2RpZ2VzdCdcblxuICAgIHRoaXMuJHNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgcm9vdFBhcmVudC4kcGhhc2UgPSBwcmVwaGFzZVxuXG4gICAgcm9vdFBhcmVudC4kZGlnZXN0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGF1dG8gY29sbGVjdCB3YXRjaGVycyBmb3IgbG9naWMtY29udHJvbC5cbiAgX3JlY29yZDogZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5fcmVjb3JkcykgdGhpcy5fcmVjb3JkcyA9IFtdO1xuICAgIHRoaXMuX3JlY29yZHMucHVzaChbXSk7XG4gIH0sXG4gIF9yZWxlYXNlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9yZWNvcmRzLnBvcCgpO1xuICB9XG59XG5cblxuXy5leHRlbmQoV2F0Y2hlci5wcm90b3R5cGUsIG1ldGhvZHMpXG5cblxuV2F0Y2hlci5taXhUbyA9IGZ1bmN0aW9uKG9iail7XG4gIG9iaiA9IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/IG9iai5wcm90b3R5cGUgOiBvYmo7XG4gIHJldHVybiBfLmV4dGVuZChvYmosIG1ldGhvZHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2F0Y2hlcjtcbiIsInZhciBlbnYgPSAgcmVxdWlyZShcIi4vZW52XCIpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTsgXG52YXIgUmVndWxhciA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVuZGVyL2NsaWVudFwiKTtcbnZhciBQYXJzZXIgPSBSZWd1bGFyLlBhcnNlcjtcbnZhciBMZXhlciA9IFJlZ3VsYXIuTGV4ZXI7XG5cbi8vIGlmKGVudi5icm93c2VyKXtcbiAgICByZXF1aXJlKFwiLi9kaXJlY3RpdmUvYmFzZVwiKTtcbiAgICByZXF1aXJlKFwiLi9kaXJlY3RpdmUvYW5pbWF0aW9uXCIpO1xuICAgIHJlcXVpcmUoXCIuL21vZHVsZS90aW1lb3V0XCIpO1xuICAgIFJlZ3VsYXIuZG9tID0gcmVxdWlyZShcIi4vZG9tXCIpO1xuLy8gfVxuUmVndWxhci5lbnYgPSBlbnY7XG5SZWd1bGFyLnV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuUmVndWxhci5wYXJzZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmKG9wdGlvbnMuQkVHSU4gfHwgb3B0aW9ucy5FTkQpe1xuICAgIGlmKG9wdGlvbnMuQkVHSU4pIGNvbmZpZy5CRUdJTiA9IG9wdGlvbnMuQkVHSU47XG4gICAgaWYob3B0aW9ucy5FTkQpIGNvbmZpZy5FTkQgPSBvcHRpb25zLkVORDtcbiAgICBMZXhlci5zZXR1cCgpO1xuICB9XG4gIHZhciBhc3QgPSBuZXcgUGFyc2VyKHN0cikucGFyc2UoKTtcbiAgcmV0dXJuICFvcHRpb25zLnN0cmluZ2lmeT8gYXN0IDogSlNPTi5zdHJpbmdpZnkoYXN0KTtcbn1cblJlZ3VsYXIuQ3Vyc29yID1yZXF1aXJlKCcuL2hlbHBlci9jdXJzb3InKSBcblxuUmVndWxhci5pc1NlcnZlciA9IGVudi5ub2RlO1xuUmVndWxhci5pc1JlZ3VsYXIgPSBmdW5jdGlvbiggQ29tcCApe1xuICByZXR1cm4gIENvbXAucHJvdG90eXBlIGluc3RhbmNlb2YgUmVndWxhcjtcbn1cblxuXG4iLCJ2YXIgUmVndWxhciA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvY2xpZW50XCIpO1xuXG4vKipcbiAqIFRpbWVvdXQgTW9kdWxlXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gQ29tcG9uZW50IFxuICovXG5mdW5jdGlvbiBUaW1lb3V0TW9kdWxlKENvbXBvbmVudCl7XG5cbiAgQ29tcG9uZW50LmltcGxlbWVudCh7XG4gICAgLyoqXG4gICAgICoganVzdCBsaWtlIHNldFRpbWVvdXQsIGJ1dCB3aWxsIGVudGVyIGRpZ2VzdCBhdXRvbWF0ZWx5XG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgIFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBkZWxheSBcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgdGltZW91dGlkXG4gICAgICovXG4gICAgJHRpbWVvdXQ6IGZ1bmN0aW9uKGZuLCBkZWxheSl7XG4gICAgICBkZWxheSA9IGRlbGF5IHx8IDA7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLiR1cGRhdGUoKTsgLy9lbnRlciBkaWdlc3RcbiAgICAgIH0uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICoganVzdCBsaWtlIHNldEludGVydmFsLCBidXQgd2lsbCBlbnRlciBkaWdlc3QgYXV0b21hdGVseVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaW50ZXJ2YWwgXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgIGludGVydmFsaWRcbiAgICAgKi9cbiAgICAkaW50ZXJ2YWw6IGZ1bmN0aW9uKGZuLCBpbnRlcnZhbCl7XG4gICAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDEwMDAvNjA7XG4gICAgICByZXR1cm4gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlKCk7IC8vZW50ZXIgZGlnZXN0XG4gICAgICB9LmJpbmQodGhpcyksIGludGVydmFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblJlZ3VsYXIucGx1Z2luKCd0aW1lb3V0JywgVGltZW91dE1vZHVsZSk7XG5SZWd1bGFyLnBsdWdpbignJHRpbWVvdXQnLCBUaW1lb3V0TW9kdWxlKTsiLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbi8vIHNvbWUgY3VzdG9tIHRhZyAgd2lsbCBjb25mbGljdCB3aXRoIHRoZSBMZXhlciBwcm9ncmVzc1xudmFyIGNvbmZsaWN0VGFnID0ge1wifVwiOiBcIntcIiwgXCJdXCI6IFwiW1wifSwgbWFwMSwgbWFwMjtcbi8vIHNvbWUgbWFjcm8gZm9yIGxleGVyXG52YXIgbWFjcm8gPSB7XG4gICdOQU1FJzogLyg/Ols6X0EtWmEtel1bLVxcLjpfMC05QS1aYS16XSopLyxcbiAgJ0lERU5UJzogL1tcXCRfQS1aYS16XVtfMC05QS1aYS16XFwkXSovLFxuICAnU1BBQ0UnOiAvW1xcclxcblxcdFxcZiBdL1xufVxuXG5cbnZhciB0ZXN0ID0gL2F8KGIpLy5leGVjKFwiYVwiKTtcbnZhciB0ZXN0U3ViQ2FwdXJlID0gdGVzdCAmJiB0ZXN0WzFdID09PSB1bmRlZmluZWQ/IFxuICBmdW5jdGlvbihzdHIpeyByZXR1cm4gc3RyICE9PSB1bmRlZmluZWQgfVxuICA6ZnVuY3Rpb24oc3RyKXtyZXR1cm4gISFzdHJ9O1xuXG5mdW5jdGlvbiB3cmFwSGFuZGVyKGhhbmRsZXIpe1xuICByZXR1cm4gZnVuY3Rpb24oYWxsKXtcbiAgICByZXR1cm4ge3R5cGU6IGhhbmRsZXIsIHZhbHVlOiBhbGwgfVxuICB9XG59XG5cbmZ1bmN0aW9uIExleGVyKGlucHV0LCBvcHRzKXtcbiAgaWYoY29uZmxpY3RUYWdbY29uZmlnLkVORF0pe1xuICAgIHRoaXMubWFya1N0YXJ0ID0gY29uZmxpY3RUYWdbY29uZmlnLkVORF07XG4gICAgdGhpcy5tYXJrRW5kID0gY29uZmlnLkVORDtcbiAgfVxuXG4gIHRoaXMuaW5wdXQgPSAoaW5wdXR8fFwiXCIpLnRyaW0oKTtcbiAgdGhpcy5vcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tYXAgPSB0aGlzLm9wdHMubW9kZSAhPT0gMj8gIG1hcDE6IG1hcDI7XG4gIHRoaXMuc3RhdGVzID0gW1wiSU5JVFwiXTtcbiAgaWYob3B0cyAmJiBvcHRzLmV4cHJlc3Npb24pe1xuICAgICB0aGlzLnN0YXRlcy5wdXNoKFwiSlNUXCIpO1xuICAgICB0aGlzLmV4cHJlc3Npb24gPSB0cnVlO1xuICB9XG59XG5cbnZhciBsbyA9IExleGVyLnByb3RvdHlwZVxuXG5cbmxvLmxleCA9IGZ1bmN0aW9uKHN0cil7XG4gIHN0ciA9IChzdHIgfHwgdGhpcy5pbnB1dCkudHJpbSgpO1xuICB2YXIgdG9rZW5zID0gW10sIHNwbGl0LCB0ZXN0LG1sZW4sIHRva2VuLCBzdGF0ZTtcbiAgdGhpcy5pbnB1dCA9IHN0ciwgXG4gIHRoaXMubWFya3MgPSAwO1xuICAvLyBpbml0IHRoZSBwb3MgaW5kZXhcbiAgdGhpcy5pbmRleD0wO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKHN0cil7XG4gICAgaSsrXG4gICAgc3RhdGUgPSB0aGlzLnN0YXRlKCk7XG4gICAgc3BsaXQgPSB0aGlzLm1hcFtzdGF0ZV0gXG4gICAgdGVzdCA9IHNwbGl0LlRSVU5LLmV4ZWMoc3RyKTtcbiAgICBpZighdGVzdCl7XG4gICAgICB0aGlzLmVycm9yKCdVbnJlY29naW5pemVkIFRva2VuJyk7XG4gICAgfVxuICAgIG1sZW4gPSB0ZXN0WzBdLmxlbmd0aDtcbiAgICBzdHIgPSBzdHIuc2xpY2UobWxlbilcbiAgICB0b2tlbiA9IHRoaXMuX3Byb2Nlc3MuY2FsbCh0aGlzLCB0ZXN0LCBzcGxpdCwgc3RyKVxuICAgIGlmKHRva2VuKSB0b2tlbnMucHVzaCh0b2tlbilcbiAgICB0aGlzLmluZGV4ICs9IG1sZW47XG4gICAgLy8gaWYoc3RhdGUgPT0gJ1RBRycgfHwgc3RhdGUgPT0gJ0pTVCcpIHN0ciA9IHRoaXMuc2tpcHNwYWNlKHN0cik7XG4gIH1cblxuICB0b2tlbnMucHVzaCh7dHlwZTogJ0VPRid9KTtcblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5sby5lcnJvciA9IGZ1bmN0aW9uKG1zZyl7XG4gIHRocm93ICBFcnJvcihcIlBhcnNlIEVycm9yOiBcIiArIG1zZyArICAnOlxcbicgKyBfLnRyYWNrRXJyb3JQb3ModGhpcy5pbnB1dCwgdGhpcy5pbmRleCkpO1xufVxuXG5sby5fcHJvY2VzcyA9IGZ1bmN0aW9uKGFyZ3MsIHNwbGl0LHN0cil7XG4gIC8vIGNvbnNvbGUubG9nKGFyZ3Muam9pbihcIixcIiksIHRoaXMuc3RhdGUoKSlcbiAgdmFyIGxpbmtzID0gc3BsaXQubGlua3MsIG1hcmNoZWQgPSBmYWxzZSwgdG9rZW47XG5cbiAgZm9yKHZhciBsZW4gPSBsaW5rcy5sZW5ndGgsIGk9MDtpPGxlbiA7aSsrKXtcbiAgICB2YXIgbGluayA9IGxpbmtzW2ldLFxuICAgICAgaGFuZGxlciA9IGxpbmtbMl0sXG4gICAgICBpbmRleCA9IGxpbmtbMF07XG4gICAgLy8gaWYoYXJnc1s2XSA9PT0gJz4nICYmIGluZGV4ID09PSA2KSBjb25zb2xlLmxvZygnaGFoYScpXG4gICAgaWYodGVzdFN1YkNhcHVyZShhcmdzW2luZGV4XSkpIHtcbiAgICAgIG1hcmNoZWQgPSB0cnVlO1xuICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgIHRva2VuID0gaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKGluZGV4LCBpbmRleCArIGxpbmtbMV0pKVxuICAgICAgICBpZih0b2tlbikgIHRva2VuLnBvcyA9IHRoaXMuaW5kZXg7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYoIW1hcmNoZWQpeyAvLyBpbiBpZSBsdDggLiBzdWIgY2FwdHVyZSBpcyBcIlwiIGJ1dCBvbnQgXG4gICAgc3dpdGNoKHN0ci5jaGFyQXQoMCkpe1xuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgdGhpcy5lbnRlcihcIlRBR1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVudGVyKFwiSlNUXCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufVxubG8uZW50ZXIgPSBmdW5jdGlvbihzdGF0ZSl7XG4gIHRoaXMuc3RhdGVzLnB1c2goc3RhdGUpXG4gIHJldHVybiB0aGlzO1xufVxuXG5sby5zdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzdGF0ZXMgPSB0aGlzLnN0YXRlcztcbiAgcmV0dXJuIHN0YXRlc1tzdGF0ZXMubGVuZ3RoLTFdO1xufVxuXG5sby5sZWF2ZSA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICBpZighc3RhdGUgfHwgc3RhdGVzW3N0YXRlcy5sZW5ndGgtMV0gPT09IHN0YXRlKSBzdGF0ZXMucG9wKClcbn1cblxuXG5MZXhlci5zZXR1cCA9IGZ1bmN0aW9uKCl7XG4gIG1hY3JvLkVORCA9IGNvbmZpZy5FTkQ7XG4gIG1hY3JvLkJFR0lOID0gY29uZmlnLkJFR0lOO1xuICBcbiAgLy8gbGl2aW5nIHRlbXBsYXRlIGxleGVyXG4gIG1hcDEgPSBnZW5NYXAoW1xuICAgIC8vIElOSVRcbiAgICBydWxlcy5FTlRFUl9KU1QsXG4gICAgcnVsZXMuRU5URVJfVEFHLFxuICAgIHJ1bGVzLlRFWFQsXG5cbiAgICAvL1RBR1xuICAgIHJ1bGVzLlRBR19OQU1FLFxuICAgIHJ1bGVzLlRBR19PUEVOLFxuICAgIHJ1bGVzLlRBR19DTE9TRSxcbiAgICBydWxlcy5UQUdfUFVOQ0hPUixcbiAgICBydWxlcy5UQUdfRU5URVJfSlNULFxuICAgIHJ1bGVzLlRBR19VTlFfVkFMVUUsXG4gICAgcnVsZXMuVEFHX1NUUklORyxcbiAgICBydWxlcy5UQUdfU1BBQ0UsXG4gICAgcnVsZXMuVEFHX0NPTU1FTlQsXG5cbiAgICAvLyBKU1RcbiAgICBydWxlcy5KU1RfT1BFTixcbiAgICBydWxlcy5KU1RfQ0xPU0UsXG4gICAgcnVsZXMuSlNUX0NPTU1FTlQsXG4gICAgcnVsZXMuSlNUX0VYUFJfT1BFTixcbiAgICBydWxlcy5KU1RfSURFTlQsXG4gICAgcnVsZXMuSlNUX1NQQUNFLFxuICAgIHJ1bGVzLkpTVF9MRUFWRSxcbiAgICBydWxlcy5KU1RfTlVNQkVSLFxuICAgIHJ1bGVzLkpTVF9QVU5DSE9SLFxuICAgIHJ1bGVzLkpTVF9TVFJJTkcsXG4gICAgcnVsZXMuSlNUX0NPTU1FTlRcbiAgICBdKVxuXG4gIC8vIGlnbm9yZWQgdGhlIHRhZy1yZWxhdGl2ZSB0b2tlblxuICBtYXAyID0gZ2VuTWFwKFtcbiAgICAvLyBJTklUIG5vIDwgcmVzdHJpY3RcbiAgICBydWxlcy5FTlRFUl9KU1QyLFxuICAgIHJ1bGVzLlRFWFQsXG4gICAgLy8gSlNUXG4gICAgcnVsZXMuSlNUX0NPTU1FTlQsXG4gICAgcnVsZXMuSlNUX09QRU4sXG4gICAgcnVsZXMuSlNUX0NMT1NFLFxuICAgIHJ1bGVzLkpTVF9FWFBSX09QRU4sXG4gICAgcnVsZXMuSlNUX0lERU5ULFxuICAgIHJ1bGVzLkpTVF9TUEFDRSxcbiAgICBydWxlcy5KU1RfTEVBVkUsXG4gICAgcnVsZXMuSlNUX05VTUJFUixcbiAgICBydWxlcy5KU1RfUFVOQ0hPUixcbiAgICBydWxlcy5KU1RfU1RSSU5HLFxuICAgIHJ1bGVzLkpTVF9DT01NRU5UXG4gICAgXSlcbn1cblxuXG5mdW5jdGlvbiBnZW5NYXAocnVsZXMpe1xuICB2YXIgcnVsZSwgbWFwID0ge30sIHNpZ247XG4gIGZvcih2YXIgaSA9IDAsIGxlbiA9IHJ1bGVzLmxlbmd0aDsgaSA8IGxlbiA7IGkrKyl7XG4gICAgcnVsZSA9IHJ1bGVzW2ldO1xuICAgIHNpZ24gPSBydWxlWzJdIHx8ICdJTklUJztcbiAgICAoIG1hcFtzaWduXSB8fCAobWFwW3NpZ25dID0ge3J1bGVzOltdLCBsaW5rczpbXX0pICkucnVsZXMucHVzaChydWxlKTtcbiAgfVxuICByZXR1cm4gc2V0dXAobWFwKTtcbn1cblxuZnVuY3Rpb24gc2V0dXAobWFwKXtcbiAgdmFyIHNwbGl0LCBydWxlcywgdHJ1bmtzLCBoYW5kbGVyLCByZWcsIHJldGFpbiwgcnVsZTtcbiAgZnVuY3Rpb24gcmVwbGFjZUZuKGFsbCwgb25lKXtcbiAgICByZXR1cm4gdHlwZW9mIG1hY3JvW29uZV0gPT09ICdzdHJpbmcnPyBcbiAgICAgIF8uZXNjYXBlUmVnRXhwKG1hY3JvW29uZV0pIFxuICAgICAgOiBTdHJpbmcobWFjcm9bb25lXSkuc2xpY2UoMSwtMSk7XG4gIH1cblxuICBmb3IodmFyIGkgaW4gbWFwKXtcblxuICAgIHNwbGl0ID0gbWFwW2ldO1xuICAgIHNwbGl0LmN1ckluZGV4ID0gMTtcbiAgICBydWxlcyA9IHNwbGl0LnJ1bGVzO1xuICAgIHRydW5rcyA9IFtdO1xuXG4gICAgZm9yKHZhciBqID0gMCxsZW4gPSBydWxlcy5sZW5ndGg7IGo8bGVuOyBqKyspe1xuICAgICAgcnVsZSA9IHJ1bGVzW2pdOyBcbiAgICAgIHJlZyA9IHJ1bGVbMF07XG4gICAgICBoYW5kbGVyID0gcnVsZVsxXTtcblxuICAgICAgaWYodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgaGFuZGxlciA9IHdyYXBIYW5kZXIoaGFuZGxlcik7XG4gICAgICB9XG4gICAgICBpZihfLnR5cGVPZihyZWcpID09PSAncmVnZXhwJykgcmVnID0gcmVnLnRvU3RyaW5nKCkuc2xpY2UoMSwgLTEpO1xuXG4gICAgICByZWcgPSByZWcucmVwbGFjZSgvXFx7KFxcdyspXFx9L2csIHJlcGxhY2VGbilcbiAgICAgIHJldGFpbiA9IF8uZmluZFN1YkNhcHR1cmUocmVnKSArIDE7IFxuICAgICAgc3BsaXQubGlua3MucHVzaChbc3BsaXQuY3VySW5kZXgsIHJldGFpbiwgaGFuZGxlcl0pOyBcbiAgICAgIHNwbGl0LmN1ckluZGV4ICs9IHJldGFpbjtcbiAgICAgIHRydW5rcy5wdXNoKHJlZyk7XG4gICAgfVxuICAgIHNwbGl0LlRSVU5LID0gbmV3IFJlZ0V4cChcIl4oPzooXCIgKyB0cnVua3Muam9pbihcIil8KFwiKSArIFwiKSlcIilcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG52YXIgcnVsZXMgPSB7XG5cbiAgLy8gMS4gSU5JVFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBtb2RlMSdzIEpTVCBFTlRFUiBSVUxFXG4gIEVOVEVSX0pTVDogWy9bXlxceDAwPF0qPyg/PXtCRUdJTn0pLywgZnVuY3Rpb24oYWxsKXtcbiAgICB0aGlzLmVudGVyKCdKU1QnKTtcbiAgICBpZihhbGwpIHJldHVybiB7dHlwZTogJ1RFWFQnLCB2YWx1ZTogYWxsfVxuICB9XSxcblxuICAvLyBtb2RlMidzIEpTVCBFTlRFUiBSVUxFXG4gIEVOVEVSX0pTVDI6IFsvW15cXHgwMF0qPyg/PXtCRUdJTn0pLywgZnVuY3Rpb24oYWxsKXtcbiAgICB0aGlzLmVudGVyKCdKU1QnKTtcbiAgICBpZihhbGwpIHJldHVybiB7dHlwZTogJ1RFWFQnLCB2YWx1ZTogYWxsfVxuICB9XSxcblxuICBFTlRFUl9UQUc6IFsvW15cXHgwMF0qPyg/PTxbXFx3XFwvXFwhXSkvLCBmdW5jdGlvbihhbGwpeyBcbiAgICB0aGlzLmVudGVyKCdUQUcnKTtcbiAgICBpZihhbGwpIHJldHVybiB7dHlwZTogJ1RFWFQnLCB2YWx1ZTogYWxsfVxuICB9XSxcblxuICBURVhUOiBbL1teXFx4MDBdKy8sICdURVhUJyBdLFxuXG4gIC8vIDIuIFRBR1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBUQUdfTkFNRTogWy97TkFNRX0vLCAnTkFNRScsICdUQUcnXSxcbiAgVEFHX1VOUV9WQUxVRTogWy9bXlxce30mXCInPT48YFxcclxcblxcZlxcdCBdKy8sICdVTlEnLCAnVEFHJ10sXG5cbiAgVEFHX09QRU46IFsvPCh7TkFNRX0pXFxzKi8sIGZ1bmN0aW9uKGFsbCwgb25lKXsgLy9cIlxuICAgIHJldHVybiB7dHlwZTogJ1RBR19PUEVOJywgdmFsdWU6IG9uZX1cbiAgfSwgJ1RBRyddLFxuICBUQUdfQ0xPU0U6IFsvPFxcLyh7TkFNRX0pW1xcclxcblxcZlxcdCBdKj4vLCBmdW5jdGlvbihhbGwsIG9uZSl7XG4gICAgdGhpcy5sZWF2ZSgpO1xuICAgIHJldHVybiB7dHlwZTogJ1RBR19DTE9TRScsIHZhbHVlOiBvbmUgfVxuICB9LCAnVEFHJ10sXG5cbiAgICAvLyBtb2RlMidzIEpTVCBFTlRFUiBSVUxFXG4gIFRBR19FTlRFUl9KU1Q6IFsvKD89e0JFR0lOfSkvLCBmdW5jdGlvbigpe1xuICAgIHRoaXMuZW50ZXIoJ0pTVCcpO1xuICB9LCAnVEFHJ10sXG5cblxuICBUQUdfUFVOQ0hPUjogWy9bXFw+XFwvPSZdLywgZnVuY3Rpb24oYWxsKXtcbiAgICBpZihhbGwgPT09ICc+JykgdGhpcy5sZWF2ZSgpO1xuICAgIHJldHVybiB7dHlwZTogYWxsLCB2YWx1ZTogYWxsIH1cbiAgfSwgJ1RBRyddLFxuICBUQUdfU1RSSU5HOiAgWyAvJyhbXiddKiknfFwiKFteXCJdKilcXFwiLywgLyonKi8gIGZ1bmN0aW9uKGFsbCwgb25lLCB0d28peyBcbiAgICB2YXIgdmFsdWUgPSBvbmUgfHwgdHdvIHx8IFwiXCI7XG5cbiAgICByZXR1cm4ge3R5cGU6ICdTVFJJTkcnLCB2YWx1ZTogdmFsdWV9XG4gIH0sICdUQUcnXSxcblxuICBUQUdfU1BBQ0U6IFsve1NQQUNFfSsvLCBudWxsLCAnVEFHJ10sXG4gIFRBR19DT01NRU5UOiBbLzxcXCEtLShbXlxceDAwXSo/KS0tXFw+LywgZnVuY3Rpb24oYWxsKXtcbiAgICB0aGlzLmxlYXZlKClcbiAgICAvLyB0aGlzLmxlYXZlKCdUQUcnKVxuICB9ICwnVEFHJ10sXG5cbiAgLy8gMy4gSlNUXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBKU1RfT1BFTjogWyd7QkVHSU59I3tTUEFDRX0qKHtJREVOVH0pJywgZnVuY3Rpb24oYWxsLCBuYW1lKXtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ09QRU4nLFxuICAgICAgdmFsdWU6IG5hbWVcbiAgICB9XG4gIH0sICdKU1QnXSxcbiAgSlNUX0xFQVZFOiBbL3tFTkR9LywgZnVuY3Rpb24oYWxsKXtcbiAgICBpZih0aGlzLm1hcmtFbmQgPT09IGFsbCAmJiB0aGlzLmV4cHJlc3Npb24pIHJldHVybiB7dHlwZTogdGhpcy5tYXJrRW5kLCB2YWx1ZTogdGhpcy5tYXJrRW5kfTtcbiAgICBpZighdGhpcy5tYXJrRW5kIHx8ICF0aGlzLm1hcmtzICl7XG4gICAgICB0aGlzLmZpcnN0RW50ZXJTdGFydCA9IGZhbHNlO1xuICAgICAgdGhpcy5sZWF2ZSgnSlNUJyk7XG4gICAgICByZXR1cm4ge3R5cGU6ICdFTkQnfVxuICAgIH1lbHNle1xuICAgICAgdGhpcy5tYXJrcy0tO1xuICAgICAgcmV0dXJuIHt0eXBlOiB0aGlzLm1hcmtFbmQsIHZhbHVlOiB0aGlzLm1hcmtFbmR9XG4gICAgfVxuICB9LCAnSlNUJ10sXG4gIEpTVF9DTE9TRTogWy97QkVHSU59XFxzKlxcLyh7SURFTlR9KVxccyp7RU5EfS8sIGZ1bmN0aW9uKGFsbCwgb25lKXtcbiAgICB0aGlzLmxlYXZlKCdKU1QnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0NMT1NFJyxcbiAgICAgIHZhbHVlOiBvbmVcbiAgICB9XG4gIH0sICdKU1QnXSxcbiAgSlNUX0NPTU1FTlQ6IFsve0JFR0lOfVxcIShbXlxceDAwXSo/KVxcIXtFTkR9LywgZnVuY3Rpb24oKXtcbiAgICB0aGlzLmxlYXZlKCk7XG4gIH0sICdKU1QnXSxcbiAgSlNUX0VYUFJfT1BFTjogWyd7QkVHSU59JyxmdW5jdGlvbihhbGwsIG9uZSl7XG4gICAgaWYoYWxsID09PSB0aGlzLm1hcmtTdGFydCl7XG4gICAgICBpZih0aGlzLmV4cHJlc3Npb24pIHJldHVybiB7IHR5cGU6IHRoaXMubWFya1N0YXJ0LCB2YWx1ZTogdGhpcy5tYXJrU3RhcnQgfTtcbiAgICAgIGlmKHRoaXMuZmlyc3RFbnRlclN0YXJ0IHx8IHRoaXMubWFya3Mpe1xuICAgICAgICB0aGlzLm1hcmtzKytcbiAgICAgICAgdGhpcy5maXJzdEVudGVyU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdGhpcy5tYXJrU3RhcnQsIHZhbHVlOiB0aGlzLm1hcmtTdGFydCB9O1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuZmlyc3RFbnRlclN0YXJ0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdFWFBSX09QRU4nLFxuICAgICAgZXNjYXBlOiBmYWxzZVxuICAgIH1cblxuICB9LCAnSlNUJ10sXG4gIEpTVF9JREVOVDogWyd7SURFTlR9JywgJ0lERU5UJywgJ0pTVCddLFxuICBKU1RfU1BBQ0U6IFsvWyBcXHJcXG5cXGZdKy8sIG51bGwsICdKU1QnXSxcbiAgSlNUX1BVTkNIT1I6IFsvWz0hXT89PXxbLT0+PCsqXFwvJVxcIV0/XFw9fFxcfFxcfHwmJnxcXEBcXCh8XFwuXFwufFs8XFw+XFxbXFxdXFwoXFwpXFwtXFx8XFx7fVxcK1xcKlxcLyU/OlxcLiEsXS8sIGZ1bmN0aW9uKGFsbCl7XG4gICAgcmV0dXJuIHsgdHlwZTogYWxsLCB2YWx1ZTogYWxsIH1cbiAgfSwnSlNUJ10sXG5cbiAgSlNUX1NUUklORzogIFsgLycoW14nXSopJ3xcIihbXlwiXSopXCIvLCBmdW5jdGlvbihhbGwsIG9uZSwgdHdvKXsgLy9cIidcbiAgICByZXR1cm4ge3R5cGU6ICdTVFJJTkcnLCB2YWx1ZTogb25lIHx8IHR3byB8fCBcIlwifVxuICB9LCAnSlNUJ10sXG4gIEpTVF9OVU1CRVI6IFsvKD86WzAtOV0qXFwuWzAtOV0rfFswLTldKykoZVxcZCspPy8sIGZ1bmN0aW9uKGFsbCl7XG4gICAgcmV0dXJuIHt0eXBlOiAnTlVNQkVSJywgdmFsdWU6IHBhcnNlRmxvYXQoYWxsLCAxMCl9O1xuICB9LCAnSlNUJ11cbn1cblxuXG4vLyBzZXR1cCB3aGVuIGZpcnN0IGNvbmZpZ1xuTGV4ZXIuc2V0dXAoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gTGV4ZXI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBub2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcbnZhciBMZXhlciA9IHJlcXVpcmUoXCIuL0xleGVyXCIpO1xudmFyIHZhck5hbWUgPSBfLnZhck5hbWU7XG52YXIgY3R4TmFtZSA9IF8uY3R4TmFtZTtcbnZhciBleHROYW1lID0gXy5leHROYW1lO1xudmFyIGlzUGF0aCA9IF8ubWFrZVByZWRpY2F0ZShcIlNUUklORyBJREVOVCBOVU1CRVJcIik7XG52YXIgaXNLZXlXb3JkID0gXy5tYWtlUHJlZGljYXRlKFwidHJ1ZSBmYWxzZSB1bmRlZmluZWQgbnVsbCB0aGlzIEFycmF5IERhdGUgSlNPTiBNYXRoIE5hTiBSZWdFeHAgZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCBlbmNvZGVVUkkgZW5jb2RlVVJJQ29tcG9uZW50IHBhcnNlRmxvYXQgcGFyc2VJbnQgT2JqZWN0XCIpO1xudmFyIGlzSW52YWxpZFRhZyA9IF8ubWFrZVByZWRpY2F0ZShcInNjcmlwdCBzdHlsZVwiKTtcbnZhciBpc0xhc3RCaW5kID0gL1xcLmJpbmQkLztcblxuXG5cbmZ1bmN0aW9uIFBhcnNlcihpbnB1dCwgb3B0cyl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgdGhpcy50b2tlbnMgPSBuZXcgTGV4ZXIoaW5wdXQsIG9wdHMpLmxleCgpO1xuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMubGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xufVxuXG5cbnZhciBvcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxub3AucGFyc2UgPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvcyA9IDA7XG4gIHZhciByZXM9IHRoaXMucHJvZ3JhbSgpO1xuICBpZih0aGlzLmxsKCkudHlwZSA9PT0gJ1RBR19DTE9TRScpe1xuICAgIHRoaXMuZXJyb3IoXCJZb3UgbWF5IGdvdCBhIHVuY2xvc2VkIFRhZ1wiKVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbm9wLmxsID0gIGZ1bmN0aW9uKGspe1xuICBrID0gayB8fCAxO1xuICBpZihrIDwgMCkgayA9IGsgKyAxO1xuICB2YXIgcG9zID0gdGhpcy5wb3MgKyBrIC0gMTtcbiAgaWYocG9zID4gdGhpcy5sZW5ndGggLSAxKXtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmxlbmd0aC0xXTtcbiAgfVxuICByZXR1cm4gdGhpcy50b2tlbnNbcG9zXTtcbn1cbiAgLy8gbG9va2FoZWFkXG5vcC5sYSA9IGZ1bmN0aW9uKGspe1xuICByZXR1cm4gKHRoaXMubGwoaykgfHwgJycpLnR5cGU7XG59XG5cbm9wLm1hdGNoID0gZnVuY3Rpb24odHlwZSwgdmFsdWUpe1xuICB2YXIgbGw7XG4gIGlmKCEobGwgPSB0aGlzLmVhdCh0eXBlLCB2YWx1ZSkpKXtcbiAgICBsbCAgPSB0aGlzLmxsKCk7XG4gICAgdGhpcy5lcnJvcignZXhwZWN0IFsnICsgdHlwZSArICh2YWx1ZSA9PSBudWxsPyAnJzonOicrIHZhbHVlKSArICddXCIgLT4gZ290IFwiWycgKyBsbC50eXBlICsgKHZhbHVlPT1udWxsPyAnJzonOicrbGwudmFsdWUpICsgJ10nLCBsbC5wb3MpXG4gIH1lbHNle1xuICAgIHJldHVybiBsbDtcbiAgfVxufVxuXG5vcC5lcnJvciA9IGZ1bmN0aW9uKG1zZywgcG9zKXtcbiAgbXNnID0gIFwiXFxu44CQIHBhcnNlIGZhaWxlZCDjgJEgXCIgKyBtc2cgKyAgJzpcXG5cXG4nICsgXy50cmFja0Vycm9yUG9zKHRoaXMuaW5wdXQsIHR5cGVvZiBwb3MgPT09ICdudW1iZXInPyBwb3M6IHRoaXMubGwoKS5wb3N8fDApO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxub3AubmV4dCA9IGZ1bmN0aW9uKGspe1xuICBrID0gayB8fCAxO1xuICB0aGlzLnBvcyArPSBrO1xufVxub3AuZWF0ID0gZnVuY3Rpb24odHlwZSwgdmFsdWUpe1xuICB2YXIgbGwgPSB0aGlzLmxsKCk7XG4gIGlmKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyl7XG4gICAgZm9yKHZhciBsZW4gPSB0eXBlLmxlbmd0aCA7IGxlbi0tOyl7XG4gICAgICBpZihsbC50eXBlID09PSB0eXBlW2xlbl0pIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiBsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1lbHNle1xuICAgIGlmKCBsbC50eXBlID09PSB0eXBlICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IGxsLnZhbHVlID09PSB2YWx1ZSkgKXtcbiAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICByZXR1cm4gbGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcHJvZ3JhbVxuLy8gIDpFT0Zcbi8vICB8IChzdGF0ZW1lbnQpKiBFT0Zcbm9wLnByb2dyYW0gPSBmdW5jdGlvbigpe1xuICB2YXIgc3RhdGVtZW50cyA9IFtdLCAgbGwgPSB0aGlzLmxsKCk7XG4gIHdoaWxlKGxsLnR5cGUgIT09ICdFT0YnICYmIGxsLnR5cGUgIT09J1RBR19DTE9TRScpe1xuXG4gICAgc3RhdGVtZW50cy5wdXNoKHRoaXMuc3RhdGVtZW50KCkpO1xuICAgIGxsID0gdGhpcy5sbCgpO1xuICB9XG4gIC8vIGlmKGxsLnR5cGUgPT09ICdUQUdfQ0xPU0UnKSB0aGlzLmVycm9yKFwiWW91IG1heSBoYXZlIHVubWF0Y2hlZCBUYWdcIilcbiAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5cbi8vIHN0YXRlbWVudFxuLy8gIDogeG1sXG4vLyAgfCBqc3Rcbi8vICB8IHRleHRcbnZhciByUk4gPSAvXFxyXFxuL2c7XG5vcC5zdGF0ZW1lbnQgPSBmdW5jdGlvbigpe1xuICB2YXIgbGwgPSB0aGlzLmxsKCk7XG4gIHN3aXRjaChsbC50eXBlKXtcbiAgICBjYXNlICdOQU1FJzpcbiAgICBjYXNlICdURVhUJzpcbiAgICAgIHZhciB0ZXh0ID0gbGwudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHdoaWxlKGxsID0gdGhpcy5lYXQoWydOQU1FJywgJ1RFWFQnXSkpe1xuICAgICAgICB0ZXh0ICs9IGxsLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUudGV4dCh0ZXh0LnJlcGxhY2UoclJOLCAnXFxuJykpO1xuICAgIGNhc2UgJ1RBR19PUEVOJzpcbiAgICAgIHJldHVybiB0aGlzLnhtbCgpO1xuICAgIGNhc2UgJ09QRU4nOiBcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGl2ZSgpO1xuICAgIGNhc2UgJ0VYUFJfT1BFTic6XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnBsYXRpb24oKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5lcnJvcignVW5leHBlY3RlZCB0b2tlbjogJysgdGhpcy5sYSgpKVxuICB9XG59XG5cbi8vIHhtbCBcbi8vIHN0YWcgc3RhdGVtZW50KiBUQUdfQ0xPU0U/KGlmIHNlbGYtY2xvc2VkIHRhZylcbm9wLnhtbCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBuYW1lLCBhdHRycywgY2hpbGRyZW4sIHNlbGZDbG9zZWQ7XG4gIG5hbWUgPSB0aGlzLm1hdGNoKCdUQUdfT1BFTicpLnZhbHVlO1xuXG4gIGlmKCBpc0ludmFsaWRUYWcobmFtZSkpe1xuICAgIHRoaXMuZXJyb3IoJ0ludmFsaWQgVGFnOiAnICsgbmFtZSk7XG4gIH1cbiAgYXR0cnMgPSB0aGlzLmF0dHJzKCk7XG4gIHNlbGZDbG9zZWQgPSB0aGlzLmVhdCgnLycpXG4gIHRoaXMubWF0Y2goJz4nKTtcbiAgaWYoICFzZWxmQ2xvc2VkICYmICFfLmlzVm9pZFRhZyhuYW1lKSApe1xuICAgIGNoaWxkcmVuID0gdGhpcy5wcm9ncmFtKCk7XG4gICAgaWYoIXRoaXMuZWF0KCdUQUdfQ0xPU0UnLCBuYW1lKSkgdGhpcy5lcnJvcignZXhwZWN0IDwvJytuYW1lKyc+IGdvdCcrICdubyBtYXRjaGVkIGNsb3NlVGFnJylcbiAgfVxuICByZXR1cm4gbm9kZS5lbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZHJlbik7XG59XG5cbi8vIHhlbnRpdHlcbi8vICAtcnVsZSh3cmFwIGF0dHJpYnV0ZSlcbi8vICAtYXR0cmlidXRlXG4vL1xuLy8gX19leGFtcGxlX19cbi8vICBuYW1lID0gMSB8ICBcbi8vICBuZy1oaWRlIHxcbi8vICBvbi1jbGljaz17e319IHwgXG4vLyAge3sjaWYgbmFtZX19b24tY2xpY2s9e3t4eH19e3sjZWxzZX19b24tdGFwPXt7fX17ey9pZn19XG5cbm9wLnhlbnRpdHkgPSBmdW5jdGlvbihsbCl7XG4gIHZhciBuYW1lID0gbGwudmFsdWUsIHZhbHVlLCBtb2RpZmllcjtcbiAgaWYobGwudHlwZSA9PT0gJ05BTUUnKXtcbiAgICAvL0Agb25seSBmb3IgdGVzdFxuICAgIGlmKH5uYW1lLmluZGV4T2YoJy4nKSl7XG4gICAgICB2YXIgdG1wID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgbmFtZSA9IHRtcFswXTtcbiAgICAgIG1vZGlmaWVyID0gdG1wWzFdXG5cbiAgICB9XG4gICAgaWYoIHRoaXMuZWF0KFwiPVwiKSApIHZhbHVlID0gdGhpcy5hdHR2YWx1ZShtb2RpZmllcik7XG4gICAgcmV0dXJuIG5vZGUuYXR0cmlidXRlKCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXIgKTtcbiAgfWVsc2V7XG4gICAgaWYoIG5hbWUgIT09ICdpZicpIHRoaXMuZXJyb3IoXCJjdXJyZW50IHZlcnNpb24uIE9OTFkgUlVMRSAjaWYgI2Vsc2UgI2Vsc2VpZiBpcyB2YWxpZCBpbiB0YWcsIHRoZSBydWxlICNcIiArIG5hbWUgKyAnIGlzIGludmFsaWQnKTtcbiAgICByZXR1cm4gdGhpc1snaWYnXSh0cnVlKTtcbiAgfVxuXG59XG5cbi8vIHN0YWcgICAgIDo6PSAgICAnPCcgTmFtZSAoUyBhdHRyKSogUz8gJz4nICBcbi8vIGF0dHIgICAgOjo9ICAgICBOYW1lIEVxIGF0dHZhbHVlXG5vcC5hdHRycyA9IGZ1bmN0aW9uKGlzQXR0cmlidXRlKXtcbiAgdmFyIGVhdFxuICBpZighaXNBdHRyaWJ1dGUpe1xuICAgIGVhdCA9IFtcIk5BTUVcIiwgXCJPUEVOXCJdXG4gIH1lbHNle1xuICAgIGVhdCA9IFtcIk5BTUVcIl1cbiAgfVxuXG4gIHZhciBhdHRycyA9IFtdLCBsbDtcbiAgd2hpbGUgKGxsID0gdGhpcy5lYXQoZWF0KSl7XG4gICAgYXR0cnMucHVzaCh0aGlzLnhlbnRpdHkoIGxsICkpXG4gIH1cbiAgcmV0dXJuIGF0dHJzO1xufVxuXG4vLyBhdHR2YWx1ZVxuLy8gIDogU1RSSU5HICBcbi8vICB8IE5BTUVcbm9wLmF0dHZhbHVlID0gZnVuY3Rpb24obWRmKXtcbiAgdmFyIGxsID0gdGhpcy5sbCgpO1xuICBzd2l0Y2gobGwudHlwZSl7XG4gICAgY2FzZSBcIk5BTUVcIjpcbiAgICBjYXNlIFwiVU5RXCI6XG4gICAgY2FzZSBcIlNUUklOR1wiOlxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgdmFsdWUgPSBsbC52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlIFwiRVhQUl9PUEVOXCI6XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnBsYXRpb24oKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5lcnJvcignVW5leHBlY3RlZCB0b2tlbjogJysgdGhpcy5sYSgpKVxuICB9XG59XG5cblxuLy8ge3sjfX1cbm9wLmRpcmVjdGl2ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBuYW1lID0gdGhpcy5sbCgpLnZhbHVlO1xuICB0aGlzLm5leHQoKTtcbiAgaWYodHlwZW9mIHRoaXNbbmFtZV0gPT09ICdmdW5jdGlvbicpe1xuICAgIHJldHVybiB0aGlzW25hbWVdKClcbiAgfWVsc2V7XG4gICAgdGhpcy5lcnJvcignVW5kZWZpbmVkIGRpcmVjdGl2ZVsnKyBuYW1lICsnXScpO1xuICB9XG59XG5cblxuXG5cblxuLy8ge3t9fVxub3AuaW50ZXJwbGF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5tYXRjaCgnRVhQUl9PUEVOJyk7XG4gIHZhciByZXMgPSB0aGlzLmV4cHJlc3Npb24odHJ1ZSk7XG4gIHRoaXMubWF0Y2goJ0VORCcpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vLyB7e359fVxub3AuaW5jID0gb3AuaW5jbHVkZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy5leHByZXNzaW9uKCk7XG4gIHRoaXMubWF0Y2goJ0VORCcpO1xuICByZXR1cm4gbm9kZS50ZW1wbGF0ZShjb250ZW50KTtcbn1cblxuLy8ge3sjaWZ9fVxub3BbXCJpZlwiXSA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciB0ZXN0ID0gdGhpcy5leHByZXNzaW9uKCk7XG4gIHZhciBjb25zZXF1ZW50ID0gW10sIGFsdGVybmF0ZT1bXTtcblxuICB2YXIgY29udGFpbmVyID0gY29uc2VxdWVudDtcbiAgdmFyIHN0YXRlbWVudCA9ICF0YWc/IFwic3RhdGVtZW50XCIgOiBcImF0dHJzXCI7XG5cbiAgdGhpcy5tYXRjaCgnRU5EJyk7XG5cbiAgdmFyIGxsLCBjbG9zZTtcbiAgd2hpbGUoICEgKGNsb3NlID0gdGhpcy5lYXQoJ0NMT1NFJykpICl7XG4gICAgbGwgPSB0aGlzLmxsKCk7XG4gICAgaWYoIGxsLnR5cGUgPT09ICdPUEVOJyApe1xuICAgICAgc3dpdGNoKCBsbC52YWx1ZSApe1xuICAgICAgICBjYXNlICdlbHNlJzpcbiAgICAgICAgICBjb250YWluZXIgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdGhpcy5tYXRjaCggJ0VORCcgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZWxzZWlmJzpcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBhbHRlcm5hdGUucHVzaCggdGhpc1tcImlmXCJdKHRhZykgKTtcbiAgICAgICAgICByZXR1cm4gbm9kZVsnaWYnXSggdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29udGFpbmVyLnB1c2goIHRoaXNbc3RhdGVtZW50XSh0cnVlKSApO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgY29udGFpbmVyLnB1c2godGhpc1tzdGF0ZW1lbnRdKHRydWUpKTtcbiAgICB9XG4gIH1cbiAgLy8gaWYgc3RhdGVtZW50IG5vdCBtYXRjaGVkXG4gIGlmKGNsb3NlLnZhbHVlICE9PSBcImlmXCIpIHRoaXMuZXJyb3IoJ1VubWF0Y2hlZCBpZiBkaXJlY3RpdmUnKVxuICByZXR1cm4gbm9kZVtcImlmXCJdKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG59XG5cblxuLy8gQG1hcmsgICBtdXN0YWNoZSBzeW50YXggaGF2ZSBuYXRydXJlIGRpcywgY2Fub3Qgd2l0aCBleHByZXNzaW9uXG4vLyB7eyNsaXN0fX1cbm9wLmxpc3QgPSBmdW5jdGlvbigpe1xuICAvLyBzZXF1ZW5jZSBjYW4gYmUgYSBsaXN0IG9yIGhhc2hcbiAgdmFyIHNlcXVlbmNlID0gdGhpcy5leHByZXNzaW9uKCksIHZhcmlhYmxlLCBsbCwgdHJhY2s7XG4gIHZhciBjb25zZXF1ZW50ID0gW10sIGFsdGVybmF0ZT1bXTtcbiAgdmFyIGNvbnRhaW5lciA9IGNvbnNlcXVlbnQ7XG5cbiAgdGhpcy5tYXRjaCgnSURFTlQnLCAnYXMnKTtcblxuICB2YXJpYWJsZSA9IHRoaXMubWF0Y2goJ0lERU5UJykudmFsdWU7XG5cbiAgaWYodGhpcy5lYXQoJ0lERU5UJywgJ2J5Jykpe1xuICAgIGlmKHRoaXMuZWF0KCdJREVOVCcsdmFyaWFibGUgKyAnX2luZGV4Jykpe1xuICAgICAgdHJhY2sgPSB0cnVlO1xuICAgIH1lbHNle1xuICAgICAgdHJhY2sgPSB0aGlzLmV4cHJlc3Npb24oKTtcbiAgICAgIGlmKHRyYWNrLmNvbnN0YW50KXtcbiAgICAgICAgLy8gdHJ1ZSBpcyBtZWFucyBjb25zdGFudCwgd2UgaGFuZGxlIGl0IGp1c3QgbGlrZSB4eHhfaW5kZXguXG4gICAgICAgIHRyYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLm1hdGNoKCdFTkQnKTtcblxuICB3aGlsZSggIShsbCA9IHRoaXMuZWF0KCdDTE9TRScpKSApe1xuICAgIGlmKHRoaXMuZWF0KCdPUEVOJywgJ2Vsc2UnKSl7XG4gICAgICBjb250YWluZXIgPSAgYWx0ZXJuYXRlO1xuICAgICAgdGhpcy5tYXRjaCgnRU5EJyk7XG4gICAgfWVsc2V7XG4gICAgICBjb250YWluZXIucHVzaCh0aGlzLnN0YXRlbWVudCgpKTtcbiAgICB9XG4gIH1cbiAgXG4gIGlmKGxsLnZhbHVlICE9PSAnbGlzdCcpIHRoaXMuZXJyb3IoJ2V4cGVjdCAnICsgJ2xpc3QgZ290ICcgKyAnLycgKyBsbC52YWx1ZSArICcgJywgbGwucG9zICk7XG4gIHJldHVybiBub2RlLmxpc3Qoc2VxdWVuY2UsIHZhcmlhYmxlLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIHRyYWNrKTtcbn1cblxuXG5vcC5leHByZXNzaW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIGV4cHJlc3Npb247XG4gIGlmKHRoaXMuZWF0KCdAKCcpKXsgLy9vbmNlIGJpbmRcbiAgICBleHByZXNzaW9uID0gdGhpcy5leHByKCk7XG4gICAgZXhwcmVzc2lvbi5vbmNlID0gdHJ1ZTtcbiAgICB0aGlzLm1hdGNoKCcpJylcbiAgfWVsc2V7XG4gICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcigpO1xuICB9XG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5vcC5leHByID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5kZXBlbmQgPSBbXTtcblxuICB2YXIgYnVmZmVyID0gdGhpcy5maWx0ZXIoKVxuXG4gIHZhciBib2R5ID0gYnVmZmVyLmdldCB8fCBidWZmZXI7XG4gIHZhciBzZXRib2R5ID0gYnVmZmVyLnNldDtcbiAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbihib2R5LCBzZXRib2R5LCAhdGhpcy5kZXBlbmQubGVuZ3RoLCBidWZmZXIuZmlsdGVycyk7XG59XG5cblxuLy8gZmlsdGVyXG4vLyBhc3NpZ24gKCd8JyBmaWx0ZXJuYW1lWyc6JyBhcmdzXSkgKiBcbm9wLmZpbHRlciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBsZWZ0ID0gdGhpcy5hc3NpZ24oKTtcbiAgdmFyIGxsID0gdGhpcy5lYXQoJ3wnKTtcbiAgdmFyIGJ1ZmZlciA9IFtdLCBmaWx0ZXJzLHNldEJ1ZmZlciwgcHJlZml4LFxuICAgIGF0dHIgPSBcInRcIiwgXG4gICAgc2V0ID0gbGVmdC5zZXQsIGdldCwgXG4gICAgdG1wID0gXCJcIjtcblxuICBpZihsbCl7XG4gICAgaWYoc2V0KSB7XG4gICAgICBzZXRCdWZmZXIgPSBbXTtcbiAgICAgIGZpbHRlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBwcmVmaXggPSBcIihmdW5jdGlvbihcIiArIGF0dHIgKyBcIil7XCI7XG5cbiAgICBkb3tcbiAgICAgIHZhciBmaWx0ZXJOYW1lID0gdGhpcy5tYXRjaCgnSURFTlQnKS52YWx1ZTtcbiAgICAgIHRtcCA9IGF0dHIgKyBcIiA9IFwiICsgY3R4TmFtZSArIFwiLl9mXygnXCIgKyBmaWx0ZXJOYW1lICsgXCInICkuZ2V0LmNhbGwoIFwiK18uY3R4TmFtZSArXCIsXCIgKyBhdHRyIDtcbiAgICAgIGlmKHRoaXMuZWF0KCc6Jykpe1xuICAgICAgICB0bXAgKz1cIiwgXCIrIHRoaXMuYXJndW1lbnRzKFwifFwiKS5qb2luKFwiLFwiKSArIFwiKTtcIlxuICAgICAgfWVsc2V7XG4gICAgICAgIHRtcCArPSAnKTsnXG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaCh0bXApO1xuICAgICAgXG4gICAgICBpZihzZXQpe1xuICAgICAgICAvLyBvbmx5IGluIHJ1bnRpbWUgLHdlIGNhbiBkZXRlY3QgIHdoZXRoZXIgIHRoZSBmaWx0ZXIgaGFzIGEgc2V0IGZ1bmN0aW9uLiBcbiAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlck5hbWUpO1xuICAgICAgICBzZXRCdWZmZXIudW5zaGlmdCggdG1wLnJlcGxhY2UoXCIgKS5nZXQuY2FsbFwiLCBcIiApLnNldC5jYWxsXCIpICk7XG4gICAgICB9XG5cbiAgICB9d2hpbGUobGwgPSB0aGlzLmVhdCgnfCcpKTtcbiAgICBidWZmZXIucHVzaChcInJldHVybiBcIiArIGF0dHIgKTtcbiAgICBzZXRCdWZmZXIgJiYgc2V0QnVmZmVyLnB1c2goXCJyZXR1cm4gXCIgKyBhdHRyKTtcblxuICAgIGdldCA9ICBwcmVmaXggKyBidWZmZXIuam9pbihcIlwiKSArIFwifSkoXCIrbGVmdC5nZXQrXCIpXCI7XG4gICAgLy8gd2UgY2FsbCBiYWNrIHRvIHZhbHVlLlxuICAgIGlmKHNldEJ1ZmZlcil7XG4gICAgICAvLyBjaGFuZ2UgX3NzX18obmFtZSwgX3BfKSB0byBfc19fKG5hbWUsIGZpbHRlckZuKF9wXykpO1xuICAgICAgc2V0ID0gc2V0LnJlcGxhY2UoXy5zZXROYW1lLCBcbiAgICAgICAgcHJlZml4ICsgc2V0QnVmZmVyLmpvaW4oXCJcIikgKyBcIn0pKFwiK+OAgF8uc2V0TmFtZeOAgCtcIilcIiApO1xuXG4gICAgfVxuICAgIC8vIHRoZSBzZXQgZnVuY3Rpb24gaXMgZGVwZW5kIG9uIHRoZSBmaWx0ZXIgZGVmaW5pdGlvbi4gaWYgaXQgaGF2ZSBzZXQgbWV0aG9kLCB0aGUgc2V0IHdpbGwgd29ya1xuICAgIHZhciByZXQgPSBnZXRzZXQoZ2V0LCBzZXQpO1xuICAgIHJldC5maWx0ZXJzID0gZmlsdGVycztcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHJldHVybiBsZWZ0O1xufVxuXG4vLyBhc3NpZ25cbi8vIGxlZnQtaGFuZC1leHByID0gY29uZGl0aW9uXG5vcC5hc3NpZ24gPSBmdW5jdGlvbigpe1xuICB2YXIgbGVmdCA9IHRoaXMuY29uZGl0aW9uKCksIGxsO1xuICBpZihsbCA9IHRoaXMuZWF0KFsnPScsICcrPScsICctPScsICcqPScsICcvPScsICclPSddKSl7XG4gICAgaWYoIWxlZnQuc2V0KSB0aGlzLmVycm9yKCdpbnZhbGlkIGxlZnRoYW5kIGV4cHJlc3Npb24gaW4gYXNzaWdubWVudCBleHByZXNzaW9uJyk7XG4gICAgcmV0dXJuIGdldHNldCggbGVmdC5zZXQucmVwbGFjZSggXCIsXCIgKyBfLnNldE5hbWUsIFwiLFwiICsgdGhpcy5jb25kaXRpb24oKS5nZXQgKS5yZXBsYWNlKFwiJz0nXCIsIFwiJ1wiK2xsLnR5cGUrXCInXCIpLCBsZWZ0LnNldCk7XG4gICAgLy8gcmV0dXJuIGdldHNldCgnKCcgKyBsZWZ0LmdldCArIGxsLnR5cGUgICsgdGhpcy5jb25kaXRpb24oKS5nZXQgKyAnKScsIGxlZnQuc2V0KTtcbiAgfVxuICByZXR1cm4gbGVmdDtcbn1cblxuLy8gb3Jcbi8vIG9yID8gYXNzaWduIDogYXNzaWduXG5vcC5jb25kaXRpb24gPSBmdW5jdGlvbigpe1xuXG4gIHZhciB0ZXN0ID0gdGhpcy5vcigpO1xuICBpZih0aGlzLmVhdCgnPycpKXtcbiAgICByZXR1cm4gZ2V0c2V0KFt0ZXN0LmdldCArIFwiP1wiLCBcbiAgICAgIHRoaXMuYXNzaWduKCkuZ2V0LCBcbiAgICAgIHRoaXMubWF0Y2goXCI6XCIpLnR5cGUsIFxuICAgICAgdGhpcy5hc3NpZ24oKS5nZXRdLmpvaW4oXCJcIikpO1xuICB9XG5cbiAgcmV0dXJuIHRlc3Q7XG59XG5cbi8vIGFuZFxuLy8gYW5kICYmIG9yXG5vcC5vciA9IGZ1bmN0aW9uKCl7XG5cbiAgdmFyIGxlZnQgPSB0aGlzLmFuZCgpO1xuXG4gIGlmKHRoaXMuZWF0KCd8fCcpKXtcbiAgICByZXR1cm4gZ2V0c2V0KGxlZnQuZ2V0ICsgJ3x8JyArIHRoaXMub3IoKS5nZXQpO1xuICB9XG5cbiAgcmV0dXJuIGxlZnQ7XG59XG4vLyBlcXVhbFxuLy8gZXF1YWwgJiYgYW5kXG5vcC5hbmQgPSBmdW5jdGlvbigpe1xuXG4gIHZhciBsZWZ0ID0gdGhpcy5lcXVhbCgpO1xuXG4gIGlmKHRoaXMuZWF0KCcmJicpKXtcbiAgICByZXR1cm4gZ2V0c2V0KGxlZnQuZ2V0ICsgJyYmJyArIHRoaXMuYW5kKCkuZ2V0KTtcbiAgfVxuICByZXR1cm4gbGVmdDtcbn1cbi8vIHJlbGF0aW9uXG4vLyBcbi8vIGVxdWFsID09IHJlbGF0aW9uXG4vLyBlcXVhbCAhPSByZWxhdGlvblxuLy8gZXF1YWwgPT09IHJlbGF0aW9uXG4vLyBlcXVhbCAhPT0gcmVsYXRpb25cbm9wLmVxdWFsID0gZnVuY3Rpb24oKXtcbiAgdmFyIGxlZnQgPSB0aGlzLnJlbGF0aW9uKCksIGxsO1xuICAvLyBAcGVyZjtcbiAgaWYoIGxsID0gdGhpcy5lYXQoWyc9PScsJyE9JywgJz09PScsICchPT0nXSkpe1xuICAgIHJldHVybiBnZXRzZXQobGVmdC5nZXQgKyBsbC50eXBlICsgdGhpcy5lcXVhbCgpLmdldCk7XG4gIH1cbiAgcmV0dXJuIGxlZnRcbn1cbi8vIHJlbGF0aW9uIDwgYWRkaXRpdmVcbi8vIHJlbGF0aW9uID4gYWRkaXRpdmVcbi8vIHJlbGF0aW9uIDw9IGFkZGl0aXZlXG4vLyByZWxhdGlvbiA+PSBhZGRpdGl2ZVxuLy8gcmVsYXRpb24gaW4gYWRkaXRpdmVcbm9wLnJlbGF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIGxlZnQgPSB0aGlzLmFkZGl0aXZlKCksIGxsO1xuICAvLyBAcGVyZlxuICBpZihsbCA9ICh0aGlzLmVhdChbJzwnLCAnPicsICc+PScsICc8PSddKSB8fCB0aGlzLmVhdCgnSURFTlQnLCAnaW4nKSApKXtcbiAgICByZXR1cm4gZ2V0c2V0KGxlZnQuZ2V0ICsgbGwudmFsdWUgKyB0aGlzLnJlbGF0aW9uKCkuZ2V0KTtcbiAgfVxuICByZXR1cm4gbGVmdFxufVxuLy8gYWRkaXRpdmUgOlxuLy8gbXVsdGl2ZVxuLy8gYWRkaXRpdmUgKyBtdWx0aXZlXG4vLyBhZGRpdGl2ZSAtIG11bHRpdmVcbm9wLmFkZGl0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGxlZnQgPSB0aGlzLm11bHRpdmUoKSAsbGw7XG4gIGlmKGxsPSB0aGlzLmVhdChbJysnLCctJ10pICl7XG4gICAgcmV0dXJuIGdldHNldChsZWZ0LmdldCArIGxsLnZhbHVlICsgdGhpcy5hZGRpdGl2ZSgpLmdldCk7XG4gIH1cbiAgcmV0dXJuIGxlZnRcbn1cbi8vIG11bHRpdmUgOlxuLy8gdW5hcnlcbi8vIG11bHRpdmUgKiB1bmFyeVxuLy8gbXVsdGl2ZSAvIHVuYXJ5XG4vLyBtdWx0aXZlICUgdW5hcnlcbm9wLm11bHRpdmUgPSBmdW5jdGlvbigpe1xuICB2YXIgbGVmdCA9IHRoaXMucmFuZ2UoKSAsbGw7XG4gIGlmKCBsbCA9IHRoaXMuZWF0KFsnKicsICcvJyAsJyUnXSkgKXtcbiAgICByZXR1cm4gZ2V0c2V0KGxlZnQuZ2V0ICsgbGwudHlwZSArIHRoaXMubXVsdGl2ZSgpLmdldCk7XG4gIH1cbiAgcmV0dXJuIGxlZnQ7XG59XG5cbm9wLnJhbmdlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGxlZnQgPSB0aGlzLnVuYXJ5KCksIGxsLCByaWdodDtcblxuICBpZihsbCA9IHRoaXMuZWF0KCcuLicpKXtcbiAgICByaWdodCA9IHRoaXMudW5hcnkoKTtcbiAgICB2YXIgYm9keSA9IFxuICAgICAgXCIoZnVuY3Rpb24oc3RhcnQsZW5kKXt2YXIgcmVzID0gW10sc3RlcD1lbmQ+c3RhcnQ/MTotMTsgZm9yKHZhciBpID0gc3RhcnQ7IGVuZD5zdGFydD9pIDw9IGVuZDogaT49ZW5kOyBpPWkrc3RlcCl7cmVzLnB1c2goaSk7IH0gcmV0dXJuIHJlcyB9KShcIitsZWZ0LmdldCtcIixcIityaWdodC5nZXQrXCIpXCJcbiAgICByZXR1cm4gZ2V0c2V0KGJvZHkpO1xuICB9XG5cbiAgcmV0dXJuIGxlZnQ7XG59XG5cblxuXG4vLyBsZWZ0aGFuZFxuLy8gKyB1bmFyeVxuLy8gLSB1bmFyeVxuLy8gfiB1bmFyeVxuLy8gISB1bmFyeVxub3AudW5hcnkgPSBmdW5jdGlvbigpe1xuICB2YXIgbGw7XG4gIGlmKGxsID0gdGhpcy5lYXQoWycrJywnLScsJ34nLCAnISddKSl7XG4gICAgcmV0dXJuIGdldHNldCgnKCcgKyBsbC50eXBlICsgdGhpcy51bmFyeSgpLmdldCArICcpJykgO1xuICB9ZWxzZXtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXIoKVxuICB9XG59XG5cbi8vIGNhbGxbbGVmdGhhbmRdIDpcbi8vIG1lbWJlciBhcmdzXG4vLyBtZW1iZXIgWyBleHByZXNzaW9uIF1cbi8vIG1lbWJlciAuIGlkZW50ICBcblxub3AubWVtYmVyID0gZnVuY3Rpb24oYmFzZSwgbGFzdCwgcGF0aGVzLCBwcmV2QmFzZSl7XG4gIHZhciBsbCwgcGF0aDtcblxuXG4gIHZhciBvbmx5U2ltcGxlQWNjZXNzb3IgPSBmYWxzZTtcbiAgaWYoIWJhc2UpeyAvL2ZpcnN0XG4gICAgcGF0aCA9IHRoaXMucHJpbWFyeSgpO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHBhdGg7XG4gICAgaWYodHlwZSA9PT0gJ3N0cmluZycpeyBcbiAgICAgIHBhdGhlcyA9IFtdO1xuICAgICAgcGF0aGVzLnB1c2goIHBhdGggKTtcbiAgICAgIGxhc3QgPSBwYXRoO1xuICAgICAgYmFzZSA9IGN0eE5hbWUgKyBcIi5fc2dfKCdcIiArIHBhdGggKyBcIicsIFwiICsgdmFyTmFtZSArIFwiLCBcIiArIGV4dE5hbWUgKyBcIilcIjtcbiAgICAgIG9ubHlTaW1wbGVBY2Nlc3NvciA9IHRydWU7XG4gICAgfWVsc2V7IC8vUHJpbWF0aXZlIFR5cGVcbiAgICAgIGlmKHBhdGguZ2V0ID09PSAndGhpcycpe1xuICAgICAgICBiYXNlID0gY3R4TmFtZTtcbiAgICAgICAgcGF0aGVzID0gWyd0aGlzJ107XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcGF0aGVzID0gbnVsbDtcbiAgICAgICAgYmFzZSA9IHBhdGguZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgfWVsc2V7IC8vIG5vdCBmaXJzdCBlbnRlclxuICAgIGlmKHR5cGVvZiBsYXN0ID09PSAnc3RyaW5nJyAmJiBpc1BhdGgoIGxhc3QpICl7IC8vIGlzIHZhbGlkIHBhdGhcbiAgICAgIHBhdGhlcy5wdXNoKGxhc3QpO1xuICAgIH1lbHNle1xuICAgICAgaWYocGF0aGVzICYmIHBhdGhlcy5sZW5ndGgpIHRoaXMuZGVwZW5kLnB1c2gocGF0aGVzKTtcbiAgICAgIHBhdGhlcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmKGxsID0gdGhpcy5lYXQoWydbJywgJy4nLCAnKCddKSl7XG4gICAgc3dpdGNoKGxsLnR5cGUpe1xuICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgLy8gbWVtYmVyKG9iamVjdCwgcHJvcGVydHksIGNvbXB1dGVkKVxuICAgICAgICB2YXIgdG1wTmFtZSA9IHRoaXMubWF0Y2goJ0lERU5UJykudmFsdWU7XG4gICAgICAgIHByZXZCYXNlID0gYmFzZTtcbiAgICAgICAgaWYoIHRoaXMubGEoKSAhPT0gXCIoXCIgKXsgXG4gICAgICAgICAgYmFzZSA9IGN0eE5hbWUgKyBcIi5fc2dfKCdcIiArIHRtcE5hbWUgKyBcIicsIFwiICsgYmFzZSArIFwiKVwiO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBiYXNlICs9IFwiLlwiICsgdG1wTmFtZSA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyKCBiYXNlLCB0bXBOYW1lLCBwYXRoZXMsICBwcmV2QmFzZSk7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgICAvLyBtZW1iZXIob2JqZWN0LCBwcm9wZXJ0eSwgY29tcHV0ZWQpXG4gICAgICAgIHBhdGggPSB0aGlzLmFzc2lnbigpO1xuICAgICAgICBwcmV2QmFzZSA9IGJhc2U7XG4gICAgICAgIGlmKCB0aGlzLmxhKCkgIT09IFwiKFwiICl7IFxuICAgICAgICAvLyBtZWFucyBmdW5jdGlvbiBjYWxsLCB3ZSBuZWVkIHRocm93IHVuZGVmaW5lZCBlcnJvciB3aGVuIGNhbGwgZnVuY3Rpb25cbiAgICAgICAgLy8gYW5kIGNvbmZpcm0gdGhhdCB0aGUgZnVuY3Rpb24gY2FsbCB3b250IGxvc2UgaXRzIGNvbnRleHRcbiAgICAgICAgICBiYXNlID0gY3R4TmFtZSArIFwiLl9zZ18oXCIgKyBwYXRoLmdldCArIFwiLCBcIiArIGJhc2UgKyBcIilcIjtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgYmFzZSArPSBcIltcIiArIHBhdGguZ2V0ICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRjaCgnXScpXG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcihiYXNlLCBwYXRoLCBwYXRoZXMsIHByZXZCYXNlKTtcbiAgICAgIGNhc2UgJygnOlxuICAgICAgICAvLyBjYWxsKGNhbGxlZSwgYXJncylcblxuICAgICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKGlzTGFzdEJpbmQsICcuX19iaW5kX18nKVxuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJndW1lbnRzKCkuam9pbignLCcpO1xuXG4gICAgICAgIGJhc2UgPSAgYmFzZStcIihcIiArIGFyZ3MgK1wiKVwiO1xuICAgICAgICB0aGlzLm1hdGNoKCcpJylcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyKGJhc2UsIG51bGwsIHBhdGhlcyk7XG4gICAgfVxuICB9XG4gIGlmKCBwYXRoZXMgJiYgcGF0aGVzLmxlbmd0aCApIHRoaXMuZGVwZW5kLnB1c2goIHBhdGhlcyApO1xuICB2YXIgcmVzID0gIHtnZXQ6IGJhc2V9O1xuICBpZihsYXN0KXtcbiAgICByZXMuc2V0ID0gY3R4TmFtZSArIFwiLl9zc18oXCIgKyBcbiAgICAgICAgKGxhc3QuZ2V0PyBsYXN0LmdldCA6IFwiJ1wiKyBsYXN0ICsgXCInXCIpICsgXG4gICAgICAgIFwiLFwiKyBfLnNldE5hbWUgKyBcIixcIisgXG4gICAgICAgIChwcmV2QmFzZT9wcmV2QmFzZTpfLnZhck5hbWUpICsgXG4gICAgICAgIFwiLCAnPScsIFwiKyAoIG9ubHlTaW1wbGVBY2Nlc3Nvcj8gMSA6IDAgKSArIFwiKVwiO1xuICBcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFxuICovXG5vcC5hcmd1bWVudHMgPSBmdW5jdGlvbihlbmQpe1xuICBlbmQgPSBlbmQgfHwgJyknXG4gIHZhciBhcmdzID0gW107XG4gIGRve1xuICAgIGlmKHRoaXMubGEoKSAhPT0gZW5kKXtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLmFzc2lnbigpLmdldClcbiAgICB9XG4gIH13aGlsZSggdGhpcy5lYXQoJywnKSk7XG4gIHJldHVybiBhcmdzXG59XG5cblxuLy8gcHJpbWFyeSA6XG4vLyB0aGlzIFxuLy8gaWRlbnRcbi8vIGxpdGVyYWxcbi8vIGFycmF5XG4vLyBvYmplY3Rcbi8vICggZXhwcmVzc2lvbiApXG5cbm9wLnByaW1hcnkgPSBmdW5jdGlvbigpe1xuICB2YXIgbGwgPSB0aGlzLmxsKCk7XG4gIHN3aXRjaChsbC50eXBlKXtcbiAgICBjYXNlIFwie1wiOlxuICAgICAgcmV0dXJuIHRoaXMub2JqZWN0KCk7XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KCk7XG4gICAgY2FzZSBcIihcIjpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVuKCk7XG4gICAgLy8gbGl0ZXJhbCBvciBpZGVudFxuICAgIGNhc2UgJ1NUUklORyc6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhciB2YWx1ZSA9IFwiXCIgKyBsbC52YWx1ZTtcbiAgICAgIHZhciBxdW90YSA9IH52YWx1ZS5pbmRleE9mKFwiJ1wiKT8gXCJcXFwiXCI6IFwiJ1wiIDtcbiAgICAgIHJldHVybiBnZXRzZXQocXVvdGEgKyB2YWx1ZSArIHF1b3RhKTtcbiAgICBjYXNlICdOVU1CRVInOlxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gZ2V0c2V0KCBcIlwiICsgbGwudmFsdWUgKTtcbiAgICBjYXNlIFwiSURFTlRcIjpcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYoaXNLZXlXb3JkKGxsLnZhbHVlKSl7XG4gICAgICAgIHJldHVybiBnZXRzZXQoIGxsLnZhbHVlICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGwudmFsdWU7XG4gICAgZGVmYXVsdDogXG4gICAgICB0aGlzLmVycm9yKCdVbmV4cGVjdGVkIFRva2VuOiAnICsgbGwudHlwZSk7XG4gIH1cbn1cblxuLy8gb2JqZWN0XG4vLyAge3Byb3BBc3NpZ24gWywgcHJvcEFzc2lnbl0gKiBbLF19XG5cbi8vIHByb3BBc3NpZ25cbi8vICBwcm9wIDogYXNzaWduXG5cbi8vIHByb3Bcbi8vICBTVFJJTkdcbi8vICBJREVOVFxuLy8gIE5VTUJFUlxuXG5vcC5vYmplY3QgPSBmdW5jdGlvbigpe1xuICB2YXIgY29kZSA9IFt0aGlzLm1hdGNoKCd7JykudHlwZV07XG5cbiAgdmFyIGxsID0gdGhpcy5lYXQoIFsnU1RSSU5HJywgJ0lERU5UJywgJ05VTUJFUiddICk7XG4gIHdoaWxlKGxsKXtcbiAgICBjb2RlLnB1c2goXCInXCIgKyBsbC52YWx1ZSArIFwiJ1wiICsgdGhpcy5tYXRjaCgnOicpLnR5cGUpO1xuICAgIHZhciBnZXQgPSB0aGlzLmFzc2lnbigpLmdldDtcbiAgICBjb2RlLnB1c2goZ2V0KTtcbiAgICBsbCA9IG51bGw7XG4gICAgaWYodGhpcy5lYXQoXCIsXCIpICYmIChsbCA9IHRoaXMuZWF0KFsnU1RSSU5HJywgJ0lERU5UJywgJ05VTUJFUiddKSkgKSBjb2RlLnB1c2goXCIsXCIpO1xuICB9XG4gIGNvZGUucHVzaCh0aGlzLm1hdGNoKCd9JykudHlwZSk7XG4gIHJldHVybiB7Z2V0OiBjb2RlLmpvaW4oXCJcIil9XG59XG5cbi8vIGFycmF5XG4vLyBbIGFzc2lnblssYXNzaWduXSpdXG5vcC5hcnJheSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjb2RlID0gW3RoaXMubWF0Y2goJ1snKS50eXBlXSwgaXRlbTtcbiAgaWYoIHRoaXMuZWF0KFwiXVwiKSApe1xuXG4gICAgIGNvZGUucHVzaChcIl1cIik7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUoaXRlbSA9IHRoaXMuYXNzaWduKCkpe1xuICAgICAgY29kZS5wdXNoKGl0ZW0uZ2V0KTtcbiAgICAgIGlmKHRoaXMuZWF0KCcsJykpIGNvZGUucHVzaChcIixcIik7XG4gICAgICBlbHNlIGJyZWFrO1xuICAgIH1cbiAgICBjb2RlLnB1c2godGhpcy5tYXRjaCgnXScpLnR5cGUpO1xuICB9XG4gIHJldHVybiB7Z2V0OiBjb2RlLmpvaW4oXCJcIil9O1xufVxuXG4vLyAnKCcgZXhwcmVzc2lvbiAnKSdcbm9wLnBhcmVuID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5tYXRjaCgnKCcpO1xuICB2YXIgcmVzID0gdGhpcy5maWx0ZXIoKVxuICByZXMuZ2V0ID0gJygnICsgcmVzLmdldCArICcpJztcbiAgcmVzLnNldCA9IHJlcy5zZXQ7XG4gIHRoaXMubWF0Y2goJyknKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0c2V0KGdldCwgc2V0KXtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBzZXQ6IHNldFxuICB9XG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBlbGVtZW50OiBmdW5jdGlvbihuYW1lLCBhdHRycywgY2hpbGRyZW4pe1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICB0YWc6IG5hbWUsXG4gICAgICBhdHRyczogYXR0cnMsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9XG4gIH0sXG4gIGF0dHJpYnV0ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIG1kZil7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG1kZjogbWRmXG4gICAgfVxuICB9LFxuICBcImlmXCI6IGZ1bmN0aW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdpZicsXG4gICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudCxcbiAgICAgIGFsdGVybmF0ZTogYWx0ZXJuYXRlXG4gICAgfVxuICB9LFxuICBsaXN0OiBmdW5jdGlvbihzZXF1ZW5jZSwgdmFyaWFibGUsIGJvZHksIGFsdGVybmF0ZSwgdHJhY2spe1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgICBhbHRlcm5hdGU6IGFsdGVybmF0ZSxcbiAgICAgIHZhcmlhYmxlOiB2YXJpYWJsZSxcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICB0cmFjazogdHJhY2tcbiAgICB9XG4gIH0sXG4gIGV4cHJlc3Npb246IGZ1bmN0aW9uKCBib2R5LCBzZXRib2R5LCBjb25zdGFudCwgZmlsdGVycyApe1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImV4cHJlc3Npb25cIixcbiAgICAgIGJvZHk6IGJvZHksXG4gICAgICBjb25zdGFudDogY29uc3RhbnQgfHwgZmFsc2UsXG4gICAgICBzZXRib2R5OiBzZXRib2R5IHx8IGZhbHNlLFxuICAgICAgZmlsdGVyczogZmlsdGVyc1xuICAgIH1cbiAgfSxcbiAgdGV4dDogZnVuY3Rpb24odGV4dCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogdGV4dFxuICAgIH1cbiAgfSxcbiAgdGVtcGxhdGU6IGZ1bmN0aW9uKHRlbXBsYXRlKXtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RlbXBsYXRlJyxcbiAgICAgIGNvbnRlbnQ6IHRlbXBsYXRlXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIHJlbmRlciBmb3IgY29tcG9uZW50IGluIGJyb3dzZXJzXG4gKi9cblxudmFyIGVudiA9IHJlcXVpcmUoJy4uL2VudicpO1xudmFyIExleGVyID0gcmVxdWlyZSgnLi4vcGFyc2VyL0xleGVyJyk7XG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi4vcGFyc2VyL1BhcnNlcicpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xudmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vaGVscGVyL2V4dGVuZCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XG52YXIgY29tYmluZSA9IHt9O1xuaWYoZW52LmJyb3dzZXIpe1xuICB2YXIgZG9tID0gcmVxdWlyZShcIi4uL2RvbVwiKTtcbiAgdmFyIHdhbGtlcnMgPSByZXF1aXJlKCcuLi93YWxrZXJzJyk7XG4gIHZhciBHcm91cCA9IHJlcXVpcmUoJy4uL2dyb3VwJyk7XG4gIHZhciBkb2MgPSBkb20uZG9jO1xuICBjb21iaW5lID0gcmVxdWlyZSgnLi4vaGVscGVyL2NvbWJpbmUnKTtcbn1cbnZhciBldmVudHMgPSByZXF1aXJlKCcuLi9oZWxwZXIvZXZlbnQnKTtcbnZhciBXYXRjaGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3dhdGNoZXInKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL2hlbHBlci9wYXJzZScpO1xudmFyIGZpbHRlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9maWx0ZXInKTtcbnZhciBFUlJPUiA9IHJlcXVpcmUoJy4uL2NvbnN0JykuRVJST1I7XG52YXIgbm9kZUN1cnNvciA9IHJlcXVpcmUoJy4uL2hlbHBlci9jdXJzb3InKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xudmFyIE5PT1AgPSBmdW5jdGlvbigpe307XG5cblxuLyoqXG4qIGBSZWd1bGFyYCBpcyByZWd1bGFyanMncyBOYW1lU3BhY2UgYW5kIEJhc2VDbGFzcy4gRXZlcnkgQ29tcG9uZW50IGlzIGluaGVyaXRlZCBmcm9tIGl0XG4qIFxuKiBAY2xhc3MgUmVndWxhclxuKiBAbW9kdWxlIFJlZ3VsYXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNwZWNpZmljYXRpb24gb2YgdGhlIGNvbXBvbmVudFxuKi9cbnZhciBSZWd1bGFyID0gZnVuY3Rpb24oZGVmaW5pdGlvbiwgb3B0aW9ucyl7XG4gIHZhciBwcmV2UnVubmluZyA9IGVudi5pc1J1bm5pbmc7XG4gIGVudi5pc1J1bm5pbmcgPSB0cnVlO1xuICB2YXIgbm9kZSwgdGVtcGxhdGUsIGN1cnNvciwgY29udGV4dCA9IHRoaXMsIGJvZHksIG1vdW50Tm9kZTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGRlZmluaXRpb24gPSBkZWZpbml0aW9uIHx8IHt9O1xuXG5cblxuICB2YXIgZHRlbXBsYXRlID0gZGVmaW5pdGlvbi50ZW1wbGF0ZTtcblxuICBpZihlbnYuYnJvd3Nlcikge1xuXG4gICAgaWYoIG5vZGUgPSB0cnlHZXRTZWxlY3RvciggZHRlbXBsYXRlICkgKXtcbiAgICAgIGR0ZW1wbGF0ZSA9IG5vZGU7XG4gICAgfVxuICAgIGlmKCBkdGVtcGxhdGUgJiYgZHRlbXBsYXRlLm5vZGVUeXBlICl7XG4gICAgICBkZWZpbml0aW9uLnRlbXBsYXRlID0gZHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH1cbiAgICBcbiAgICBtb3VudE5vZGUgPSBkZWZpbml0aW9uLm1vdW50Tm9kZTtcbiAgICBpZih0eXBlb2YgbW91bnROb2RlID09PSAnc3RyaW5nJyl7XG4gICAgICBtb3VudE5vZGUgPSBkb20uZmluZCggbW91bnROb2RlICk7XG4gICAgICBpZighbW91bnROb2RlKSB0aHJvdyBFcnJvcignbW91bnROb2RlICcgKyBtb3VudE5vZGUgKyAnIGlzIG5vdCBmb3VuZCcpXG4gICAgfSBcblxuICAgIGlmKG1vdW50Tm9kZSl7XG4gICAgICBjdXJzb3IgPSBub2RlQ3Vyc29yKG1vdW50Tm9kZS5maXJzdENoaWxkKVxuICAgICAgZGVsZXRlIGRlZmluaXRpb24ubW91bnROb2RlXG4gICAgfWVsc2V7XG4gICAgICBjdXJzb3IgPSBvcHRpb25zLmN1cnNvclxuICAgIH1cbiAgfVxuXG5cblxuICB0ZW1wbGF0ZSA9IHNoYXJlZC5pbml0RGVmaW5pdGlvbihjb250ZXh0LCBkZWZpbml0aW9uKVxuICBcblxuICBpZihjb250ZXh0LiRwYXJlbnQpe1xuICAgICBjb250ZXh0LiRwYXJlbnQuX2FwcGVuZChjb250ZXh0KTtcbiAgfVxuICBjb250ZXh0Ll9jaGlsZHJlbiA9IFtdO1xuICBjb250ZXh0LiRyZWZzID0ge307XG5cbiAgdmFyIGV4dHJhID0gb3B0aW9ucy5leHRyYTtcbiAgdmFyIG9sZE1vZGlmeSA9IGV4dHJhICYmIGV4dHJhLiQkbW9kaWZ5O1xuXG4gIGlmKCBvbGRNb2RpZnkgKXtcbiAgICBvbGRNb2RpZnkodGhpcyk7XG4gIH1cbiAgY29udGV4dC4kcm9vdCA9IGNvbnRleHQuJHJvb3QgfHwgY29udGV4dDtcbiAgXG4gIHZhciBuZXdFeHRyYTtcbiAgaWYoIGJvZHkgPSBjb250ZXh0Ll9ib2R5ICl7XG4gICAgY29udGV4dC5fYm9keSA9IG51bGxcbiAgICB2YXIgbW9kaWZ5Qm9keUNvbXBvbmVudCA9IGNvbnRleHQubW9kaWZ5Qm9keUNvbXBvbmVudDtcbiAgICBpZiggdHlwZW9mIG1vZGlmeUJvZHlDb21wb25lbnQgID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIG1vZGlmeUJvZHlDb21wb25lbnQgPSBtb2RpZnlCb2R5Q29tcG9uZW50LmJpbmQodGhpcylcbiAgICAgIG5ld0V4dHJhID0gXy5jcmVhdGVPYmplY3QoZXh0cmEpO1xuICAgICAgbmV3RXh0cmEuJCRtb2RpZnkgPSBmdW5jdGlvbiggY29tcCApe1xuICAgICAgICByZXR1cm4gbW9kaWZ5Qm9keUNvbXBvbmVudChjb21wLCBvbGRNb2RpZnk/IG9sZE1vZGlmeTogTk9PUClcbiAgICAgIH1cbiAgICB9ZWxzZXsgLy9ARklYSVQ6IG11bHRpcGx5IG1vZGlmaWVyXG4gICAgICBuZXdFeHRyYSA9IGV4dHJhXG4gICAgfVxuICAgIGlmKGJvZHkuYXN0ICYmIGJvZHkuYXN0Lmxlbmd0aCl7XG4gICAgICBjb250ZXh0LiRib2R5ID0gXy5nZXRDb21waWxlRm4oYm9keS5hc3QsIGJvZHkuY3R4ICwge1xuICAgICAgICBvdXRlcjogY29udGV4dCxcbiAgICAgICAgbmFtZXNwYWNlOiBvcHRpb25zLm5hbWVzcGFjZSxcbiAgICAgICAgZXh0cmE6IG5ld0V4dHJhLFxuICAgICAgICByZWNvcmQ6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGNvbXB1dGVkXG4gIGlmKHRlbXBsYXRlKXtcbiAgICB2YXIgY3BsT3B0ID0ge1xuICAgICAgbmFtZXNwYWNlOiBvcHRpb25zLm5hbWVzcGFjZSxcbiAgICAgIGN1cnNvcjogY3Vyc29yXG4gICAgfVxuICAgIC8vIGlmKGV4dHJhICYmIGV4dHJhLiQkbW9kaWZ5KXtcbiAgICAgIGNwbE9wdC5leHRyYSA9IHskJG1vZGlmeSA6IGV4dHJhJiYgZXh0cmEuJCRtb2RpZnl9XG4gICAgLy8gfVxuICAgIGNvbnRleHQuZ3JvdXAgPSBjb250ZXh0LiRjb21waWxlKHRlbXBsYXRlLCBjcGxPcHQpO1xuICAgIGNvbWJpbmUubm9kZShjb250ZXh0KTtcbiAgfVxuXG5cbiAgLy8gdGhpcyBpcyBvdXRlc3QgY29tcG9uZW50XG4gIGlmKCAhY29udGV4dC4kcGFyZW50ICkgY29udGV4dC4kdXBkYXRlKCk7XG4gIGNvbnRleHQuJHJlYWR5ID0gdHJ1ZTtcblxuICBjb250ZXh0LiRlbWl0KFwiJGluaXRcIik7XG4gIGlmKCBjb250ZXh0LmluaXQgKSBjb250ZXh0LmluaXQoIGNvbnRleHQuZGF0YSApO1xuICBjb250ZXh0LiRlbWl0KFwiJGFmdGVySW5pdFwiKTtcblxuICBlbnYuaXNSdW5uaW5nID0gcHJldlJ1bm5pbmc7XG5cbiAgLy8gY2hpbGRyZW4gaXMgbm90IHJlcXVpcmVkO1xuICBcbiAgaWYgKHRoaXMuZGV2dG9vbHMpIHtcbiAgICB0aGlzLmRldnRvb2xzLmVtaXQoXCJpbml0XCIsIHRoaXMpXG4gIH1cbn1cblxuLy8gY2hlY2sgaWYgcmVndWxhciBkZXZ0b29scyBob29rIGV4aXN0c1xuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpe1xuICB2YXIgZGV2dG9vbHMgPSB3aW5kb3cuX19SRUdVTEFSX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChkZXZ0b29scykge1xuICAgIFJlZ3VsYXIucHJvdG90eXBlLmRldnRvb2xzID0gZGV2dG9vbHM7XG4gIH1cbn1cblxud2Fsa2VycyAmJiAod2Fsa2Vycy5SZWd1bGFyID0gUmVndWxhcik7XG5cblxuLy8gZGVzY3JpcHRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDEuIFJlZ3VsYXIgYW5kIGRlcml2ZWQgQ2xhc3MgdXNlIHNhbWUgZmlsdGVyXG5fLmV4dGVuZChSZWd1bGFyLCB7XG4gIC8vIHByaXZhdGUgZGF0YSBzdHVmZlxuICBfZGlyZWN0aXZlczogeyBfX3JlZ2V4cF9fOltdIH0sXG4gIF9wbHVnaW5zOiB7fSxcbiAgX3Byb3RvSW5oZXJpdENhY2hlOiBbICdkaXJlY3RpdmUnLCAndXNlJ10gLFxuICBfX2FmdGVyX186IGZ1bmN0aW9uKHN1cHIsIG8pIHtcblxuICAgIHZhciB0ZW1wbGF0ZTtcbiAgICB0aGlzLl9fYWZ0ZXJfXyA9IHN1cHIuX19hZnRlcl9fO1xuXG4gICAgLy8gdXNlIG5hbWUgbWFrZSB0aGUgY29tcG9uZW50IGdsb2JhbC5cbiAgICBpZihvLm5hbWUpIFJlZ3VsYXIuY29tcG9uZW50KG8ubmFtZSwgdGhpcyk7XG4gICAgLy8gdGhpcy5wcm90b3R5cGUudGVtcGxhdGUgPSBkb20uaW5pdFRlbXBsYXRlKG8pXG4gICAgaWYodGVtcGxhdGUgPSBvLnRlbXBsYXRlKXtcbiAgICAgIHZhciBub2RlLCBuYW1lO1xuICAgICAgaWYoIGVudi5icm93c2VyICl7XG4gICAgICAgIGlmKCBub2RlID0gdHJ5R2V0U2VsZWN0b3IodGVtcGxhdGUpICkgdGVtcGxhdGUgPSBub2RlIDtcbiAgICAgICAgaWYoIHRlbXBsYXRlICYmIHRlbXBsYXRlLm5vZGVUeXBlICl7XG5cbiAgICAgICAgICBpZihuYW1lID0gZG9tLmF0dHIodGVtcGxhdGUsICduYW1lJykpIFJlZ3VsYXIuY29tcG9uZW50KG5hbWUsIHRoaXMpO1xuXG4gICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICAgIH0gXG4gICAgICB9XG5cbiAgICAgIGlmKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKXtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUudGVtcGxhdGUgPSBjb25maWcuUFJFQ09NUElMRT8gbmV3IFBhcnNlcih0ZW1wbGF0ZSkucGFyc2UoKTogdGVtcGxhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoby5jb21wdXRlZCkgdGhpcy5wcm90b3R5cGUuY29tcHV0ZWQgPSBzaGFyZWQuaGFuZGxlQ29tcHV0ZWQoby5jb21wdXRlZCk7XG4gICAgLy8gaW5oZXJpdCBkaXJlY3RpdmUgYW5kIG90aGVyIGNvbmZpZyBmcm9tIHN1cHJcbiAgICBSZWd1bGFyLl9pbmhlcml0Q29uZmlnKHRoaXMsIHN1cHIpO1xuXG4gIH0sXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBkaXJlY3RpdmVcbiAgICpcbiAgICogQG1ldGhvZCBkaXJlY3RpdmVcbiAgICogQHJldHVybiB7T2JqZWN0fSBDb3B5IG9mIC4uLlxuICAgKi8gIFxuICBkaXJlY3RpdmU6IGZ1bmN0aW9uKG5hbWUsIGNmZyl7XG4gICAgaWYoIW5hbWUpIHJldHVybjtcblxuICAgIHZhciB0eXBlID0gdHlwZW9mIG5hbWU7XG4gICAgaWYodHlwZSA9PT0gJ29iamVjdCcgJiYgIWNmZyl7XG4gICAgICBmb3IodmFyIGsgaW4gbmFtZSl7XG4gICAgICAgIGlmKG5hbWUuaGFzT3duUHJvcGVydHkoaykpIHRoaXMuZGlyZWN0aXZlKGssIG5hbWVba10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5fZGlyZWN0aXZlcywgZGlyZWN0aXZlO1xuICAgIGlmKGNmZyA9PSBudWxsKXtcbiAgICAgIGlmKCB0eXBlID09PSAnc3RyaW5nJyApe1xuICAgICAgICBpZihkaXJlY3RpdmUgPSBkaXJlY3RpdmVzW25hbWVdKSByZXR1cm4gZGlyZWN0aXZlO1xuICAgICAgICBlbHNle1xuXG4gICAgICAgICAgdmFyIHJlZ2V4cCA9IGRpcmVjdGl2ZXMuX19yZWdleHBfXztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSByZWdleHAubGVuZ3RoOyBpIDwgbGVuIDsgaSsrKXtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHJlZ2V4cFtpXTtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gZGlyZWN0aXZlLnJlZ2V4cC50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgaWYodGVzdCkgcmV0dXJuIGRpcmVjdGl2ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIGlmKCB0eXBlb2YgY2ZnID09PSAnZnVuY3Rpb24nKSBjZmcgPSB7IGxpbms6IGNmZyB9IFxuICAgICAgaWYoIHR5cGUgPT09ICdzdHJpbmcnICkgZGlyZWN0aXZlc1tuYW1lXSA9IGNmZztcbiAgICAgIGVsc2V7XG4gICAgICAgIGNmZy5yZWdleHAgPSBuYW1lO1xuICAgICAgICBkaXJlY3RpdmVzLl9fcmVnZXhwX18ucHVzaChjZmcpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfSxcbiAgcGx1Z2luOiBmdW5jdGlvbihuYW1lLCBmbil7XG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuICAgIGlmKGZuID09IG51bGwpIHJldHVybiBwbHVnaW5zW25hbWVdO1xuICAgIHBsdWdpbnNbbmFtZV0gPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXNlOiBmdW5jdGlvbihmbil7XG4gICAgaWYodHlwZW9mIGZuID09PSBcInN0cmluZ1wiKSBmbiA9IFJlZ3VsYXIucGx1Z2luKGZuKTtcbiAgICBpZih0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXM7XG4gICAgZm4odGhpcywgUmVndWxhcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGNvbmZpZyB0aGUgUmVndWxhcmpzJ3MgZ2xvYmFsXG4gIGNvbmZpZzogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuICAgIHZhciBuZWVkR2VuTGV4ZXIgPSBmYWxzZTtcbiAgICBpZih0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIil7XG4gICAgICBmb3IodmFyIGkgaW4gbmFtZSl7XG4gICAgICAgIC8vIGlmIHlvdSBjb25maWdcbiAgICAgICAgaWYoIGkgPT09XCJFTkRcIiB8fCBpPT09J0JFR0lOJyApICBuZWVkR2VuTGV4ZXIgPSB0cnVlO1xuICAgICAgICBjb25maWdbaV0gPSBuYW1lW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihuZWVkR2VuTGV4ZXIpIExleGVyLnNldHVwKCk7XG4gIH0sXG4gIGV4cHJlc3Npb246IHBhcnNlLmV4cHJlc3Npb24sXG4gIFBhcnNlcjogUGFyc2VyLFxuICBMZXhlcjogTGV4ZXIsXG4gIF9hZGRQcm90b0luaGVyaXRDYWNoZTogZnVuY3Rpb24obmFtZSwgdHJhbnNmb3JtKXtcbiAgICBpZiggQXJyYXkuaXNBcnJheSggbmFtZSApICl7XG4gICAgICByZXR1cm4gbmFtZS5mb3JFYWNoKFJlZ3VsYXIuX2FkZFByb3RvSW5oZXJpdENhY2hlKTtcbiAgICB9XG4gICAgdmFyIGNhY2hlS2V5ID0gXCJfXCIgKyBuYW1lICsgXCJzXCJcbiAgICBSZWd1bGFyLl9wcm90b0luaGVyaXRDYWNoZS5wdXNoKG5hbWUpXG4gICAgUmVndWxhcltjYWNoZUtleV0gPSB7fTtcbiAgICBpZihSZWd1bGFyW25hbWVdKSByZXR1cm47XG4gICAgUmVndWxhcltuYW1lXSA9IGZ1bmN0aW9uKGtleSwgY2ZnKXtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXNbY2FjaGVLZXldO1xuXG4gICAgICBpZih0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKXtcbiAgICAgICAgZm9yKHZhciBpIGluIGtleSl7XG4gICAgICAgICAgaWYoa2V5Lmhhc093blByb3BlcnR5KGkpKSB0aGlzW25hbWVdKGksIGtleVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZihjZmcgPT0gbnVsbCkgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICBjYWNoZVtrZXldID0gdHJhbnNmb3JtPyB0cmFuc2Zvcm0oY2ZnKSA6IGNmZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSxcbiAgX2luaGVyaXRDb25maWc6IGZ1bmN0aW9uKHNlbGYsIHN1cHIpe1xuXG4gICAgLy8gcHJvdG90eXBlIGluaGVyaXQgc29tZSBSZWd1bGFyIHByb3BlcnR5XG4gICAgLy8gc28gZXZlcnkgQ29tcG9uZW50IHdpbGwgaGF2ZSBvd24gY29udGFpbmVyIHRvIHNlcnZlIGRpcmVjdGl2ZSwgZmlsdGVyIGV0Yy4uXG4gICAgdmFyIGRlZnMgPSBSZWd1bGFyLl9wcm90b0luaGVyaXRDYWNoZTtcbiAgICB2YXIga2V5cyA9IF8uc2xpY2UoZGVmcyk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgICBzZWxmW2tleV0gPSBzdXByW2tleV07XG4gICAgICB2YXIgY2FjaGVLZXkgPSAnXycgKyBrZXkgKyAncyc7XG4gICAgICBpZihzdXByW2NhY2hlS2V5XSkgc2VsZltjYWNoZUtleV0gPSBfLmNyZWF0ZU9iamVjdChzdXByW2NhY2hlS2V5XSk7XG4gICAgfSlcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG59KTtcblxuZXh0ZW5kKFJlZ3VsYXIpO1xuXG5SZWd1bGFyLl9hZGRQcm90b0luaGVyaXRDYWNoZShcImNvbXBvbmVudFwiKVxuXG5SZWd1bGFyLl9hZGRQcm90b0luaGVyaXRDYWNoZShcImZpbHRlclwiLCBmdW5jdGlvbihjZmcpe1xuICByZXR1cm4gdHlwZW9mIGNmZyA9PT0gXCJmdW5jdGlvblwiPyB7Z2V0OiBjZmd9OiBjZmc7XG59KVxuXG5cbmV2ZW50cy5taXhUbyhSZWd1bGFyKTtcbldhdGNoZXIubWl4VG8oUmVndWxhcik7XG5cblJlZ3VsYXIuaW1wbGVtZW50KHtcbiAgaW5pdDogZnVuY3Rpb24oKXt9LFxuICBjb25maWc6IGZ1bmN0aW9uKCl7fSxcbiAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAvLyBkZXN0cm95IGV2ZW50IHdvbnQgcHJvcGdhdGlvbjtcbiAgICB0aGlzLiRlbWl0KFwiJGRlc3Ryb3lcIik7XG4gICAgdGhpcy5fd2F0Y2hlcnMgPSBudWxsO1xuICAgIHRoaXMuX3dhdGNoZXJzRm9yU3RhYmxlID0gbnVsbDtcbiAgICB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLmdyb3VwID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLiRyb290ID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVzID0gbnVsbDtcbiAgICB0aGlzLiRyZWZzID0gbnVsbDtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIGlmKHBhcmVudCAmJiBwYXJlbnQuX2NoaWxkcmVuKXtcbiAgICAgIHZhciBpbmRleCA9IHBhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHBhcmVudC5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LDEpO1xuICAgIH1cbiAgICB0aGlzLiRwYXJlbnQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZGV2dG9vbHMpIHtcbiAgICAgIHRoaXMuZGV2dG9vbHMuZW1pdChcImRlc3Ryb3lcIiwgdGhpcylcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlcyA9IG51bGw7XG4gICAgdGhpcy4kcGhhc2UgPSBcImRlc3Ryb3llZFwiO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjb21waWxlIGEgYmxvY2sgYXN0IDsgcmV0dXJuIGEgZ3JvdXA7XG4gICAqIEBwYXJhbSAge0FycmF5fSBwYXJzZWQgYXN0XG4gICAqIEBwYXJhbSAge1t0eXBlXX0gcmVjb3JkXG4gICAqIEByZXR1cm4ge1t0eXBlXX1cbiAgICovXG4gICRjb21waWxlOiBmdW5jdGlvbihhc3QsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKXtcbiAgICAgIGFzdCA9IG5ldyBQYXJzZXIoYXN0KS5wYXJzZSgpXG4gICAgfVxuICAgIHZhciBwcmVFeHQgPSB0aGlzLl9fZXh0X18sXG4gICAgICByZWNvcmQgPSBvcHRpb25zLnJlY29yZCwgXG4gICAgICByZWNvcmRzO1xuXG4gICAgaWYob3B0aW9ucy5leHRyYSkgdGhpcy5fX2V4dF9fID0gb3B0aW9ucy5leHRyYTtcblxuXG4gICAgaWYocmVjb3JkKSB0aGlzLl9yZWNvcmQoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl93YWxrKGFzdCwgb3B0aW9ucyk7XG4gICAgaWYocmVjb3JkKXtcbiAgICAgIHJlY29yZHMgPSB0aGlzLl9yZWxlYXNlKCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiggcmVjb3Jkcy5sZW5ndGggKXtcbiAgICAgICAgLy8gYXV0byBkZXN0cm95IGFsbCB3YXRoZXI7XG4gICAgICAgIGdyb3VwLm9uZGVzdHJveSA9IGZ1bmN0aW9uKCl7IHNlbGYuJHVud2F0Y2gocmVjb3Jkcyk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYob3B0aW9ucy5leHRyYSkgdGhpcy5fX2V4dF9fID0gcHJlRXh0O1xuICAgIHJldHVybiBncm91cDtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjcmVhdGUgdHdvLXdheSBiaW5kaW5nIHdpdGggYW5vdGhlciBjb21wb25lbnQ7XG4gICAqICp3YXJuKjogXG4gICAqICAgZXhwcjEgYW5kIGV4cHIyIG11c3QgY2FuIG9wZXJhdGUgc2V0JmdldCwgZm9yIGV4YW1wbGU6IHRoZSAnYS5iJyBvciAnYVtiICsgMV0nIGlzIHNldC1hYmxlLCBidXQgJ2EuYiArIDEnIGlzIG5vdCwgXG4gICAqICAgYmVhY3VzZSBSZWd1bGFyIGRvbnQga25vdyBob3cgdG8gaW52ZXJzZSBzZXQgdGhyb3VnaCB0aGUgZXhwcmVzc2lvbjtcbiAgICogICBcbiAgICogICBpZiBiZWZvcmUgJGJpbmQsIHR3byBjb21wb25lbnQncyBzdGF0ZSBpcyBub3Qgc3luYywgdGhlIGNvbXBvbmVudChwYXNzZWQgcGFyYW0pIHdpbGwgc3luYyB3aXRoIHRoZSBjYWxsZWQgY29tcG9uZW50O1xuICAgKlxuICAgKiAqZXhhbXBsZTogKlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIGluIHRoaXMgZXhhbXBsZSwgd2UgbmVlZCB0byBsaW5rIHR3byBwYWdlciBjb21wb25lbnRcbiAgICogdmFyIHBhZ2VyID0gbmV3IFBhZ2VyKHt9KSAvLyBwYWdlciBjb21wb2VubnRcbiAgICogdmFyIHBhZ2VyMiA9IG5ldyBQYWdlcih7fSkgLy8gYW5vdGhlciBwYWdlciBjb21wb25lbnRcbiAgICogcGFnZXIuJGJpbmQocGFnZXIyLCAnY3VycmVudCcpOyAvLyB0d28gd2F5IGJpbmQgdGhyb3cgdHdvIGNvbXBvbmVudFxuICAgKiBwYWdlci4kYmluZChwYWdlcjIsICd0b3RhbCcpOyAgIC8vIFxuICAgKiAvLyBvciBqdXN0XG4gICAqIHBhZ2VyLiRiaW5kKHBhZ2VyMiwge1wiY3VycmVudFwiOiBcImN1cnJlbnRcIiwgXCJ0b3RhbFwiOiBcInRvdGFsXCJ9KSBcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcGFyYW0gIHtSZWd1bGFyfSBjb21wb25lbnQgdGhlXG4gICAqIEBwYXJhbSAge1N0cmluZ3xFeHByZXNzaW9ufSBleHByMSAgICAgcmVxdWlyZWQsIHNlbGYgZXhwcjEgdG8gb3BlcmF0ZSBiaW5kaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ3xFeHByZXNzaW9ufSBleHByMiAgICAgb3B0aW9uYWwsIG90aGVyIGNvbXBvbmVudCdzIGV4cHIgdG8gYmluZCB3aXRoLCBpZiBub3QgcGFzc2VkLCB0aGUgZXhwcjIgd2lsbCB1c2UgdGhlIGV4cHIxO1xuICAgKiBAcmV0dXJuICAgICAgICAgIHRoaXM7XG4gICAqL1xuICAkYmluZDogZnVuY3Rpb24oY29tcG9uZW50LCBleHByMSwgZXhwcjIpe1xuICAgIHZhciB0eXBlID0gXy50eXBlT2YoZXhwcjEpO1xuICAgIGlmKCBleHByMS50eXBlID09PSAnZXhwcmVzc2lvbicgfHwgdHlwZSA9PT0gJ3N0cmluZycgKXtcbiAgICAgIHRoaXMuX2JpbmQoY29tcG9uZW50LCBleHByMSwgZXhwcjIpXG4gICAgfWVsc2UgaWYoIHR5cGUgPT09IFwiYXJyYXlcIiApeyAvLyBtdWx0aXBseSBzYW1lIHBhdGggYmluZGluZyB0aHJvdWdoIGFycmF5XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBleHByMS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIHRoaXMuX2JpbmQoY29tcG9uZW50LCBleHByMVtpXSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYodHlwZSA9PT0gXCJvYmplY3RcIil7XG4gICAgICBmb3IodmFyIGkgaW4gZXhwcjEpIGlmKGV4cHIxLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgICAgdGhpcy5fYmluZChjb21wb25lbnQsIGksIGV4cHIxW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZGlnZXN0XG4gICAgY29tcG9uZW50LiR1cGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIHVuYmluZCBvbmUgY29tcG9uZW50KCBzZWUgJGJpbmQgYWxzbylcbiAgICpcbiAgICogdW5iaW5kIHdpbGwgdW5iaW5kIGFsbCByZWxhdGlvbiBiZXR3ZWVuIHR3byBjb21wb25lbnRcbiAgICogXG4gICAqIEBwYXJhbSAge1JlZ3VsYXJ9IGNvbXBvbmVudCBbZGVzY3JpcHRpb25lZ3VsYXJcbiAgICogQHJldHVybiB7VGhpc30gICAgdGhpc1xuICAgKi9cbiAgJHVuYmluZDogZnVuY3Rpb24oKXtcbiAgICAvLyB0b2RvXG4gIH0sXG4gICRpbmplY3Q6IGNvbWJpbmUuaW5qZWN0LFxuICAkbXV0ZTogZnVuY3Rpb24oaXNNdXRlKXtcblxuICAgIGlzTXV0ZSA9ICEhaXNNdXRlO1xuXG4gICAgdmFyIG5lZWR1cGRhdGUgPSBpc011dGUgPT09IGZhbHNlICYmIHRoaXMuX211dGU7XG5cbiAgICB0aGlzLl9tdXRlID0gISFpc011dGU7XG5cbiAgICBpZihuZWVkdXBkYXRlKSB0aGlzLiR1cGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcHJpdmF0ZSBiaW5kIGxvZ2ljXG4gIF9iaW5kOiBmdW5jdGlvbihjb21wb25lbnQsIGV4cHIxLCBleHByMil7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gYmFzaWMgYmluZGluZ1xuXG4gICAgaWYoIWNvbXBvbmVudCB8fCAhKGNvbXBvbmVudCBpbnN0YW5jZW9mIFJlZ3VsYXIpKSB0aHJvdyBcIiRiaW5kKCkgc2hvdWxkIHBhc3MgUmVndWxhciBjb21wb25lbnQgYXMgZmlyc3QgYXJndW1lbnRcIjtcbiAgICBpZighZXhwcjEpIHRocm93IFwiJGJpbmQoKSBzaG91bGQgIHBhc3MgYXMgbGVhc3Qgb25lIGV4cHJlc3Npb24gdG8gYmluZFwiO1xuXG4gICAgaWYoIWV4cHIyKSBleHByMiA9IGV4cHIxO1xuXG4gICAgZXhwcjEgPSBwYXJzZS5leHByZXNzaW9uKCBleHByMSApO1xuICAgIGV4cHIyID0gcGFyc2UuZXhwcmVzc2lvbiggZXhwcjIgKTtcblxuICAgIC8vIHNldCBpcyBuZWVkIHRvIG9wZXJhdGUgc2V0dGluZyA7XG4gICAgaWYoZXhwcjIuc2V0KXtcbiAgICAgIHZhciB3aWQxID0gdGhpcy4kd2F0Y2goIGV4cHIxLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIGNvbXBvbmVudC4kdXBkYXRlKGV4cHIyLCB2YWx1ZSlcbiAgICAgIH0pO1xuICAgICAgY29tcG9uZW50LiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLiR1bndhdGNoKHdpZDEpXG4gICAgICB9KVxuICAgIH1cbiAgICBpZihleHByMS5zZXQpe1xuICAgICAgdmFyIHdpZDIgPSBjb21wb25lbnQuJHdhdGNoKGV4cHIyLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIHNlbGYuJHVwZGF0ZShleHByMSwgdmFsdWUpXG4gICAgICB9KTtcbiAgICAgIC8vIHdoZW4gYnJvdGhlciBkZXN0cm95LCB3ZSB1bmxpbmsgdGhpcyB3YXRjaGVyXG4gICAgICB0aGlzLiRvbignJGRlc3Ryb3knLCBjb21wb25lbnQuJHVud2F0Y2guYmluZChjb21wb25lbnQsd2lkMikpXG4gICAgfVxuICAgIC8vIHN5bmMgdGhlIGNvbXBvbmVudCdzIHN0YXRlIHRvIGNhbGxlZCdzIHN0YXRlXG4gICAgZXhwcjIuc2V0KGNvbXBvbmVudCwgZXhwcjEuZ2V0KHRoaXMpKTtcbiAgfSxcbiAgX3dhbGs6IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucyl7XG4gICAgaWYoIEFycmF5LmlzQXJyYXkoYXN0KSApe1xuICAgICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBhc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy5fd2Fsayhhc3RbaV0sIG9wdGlvbnMpO1xuICAgICAgICBpZihyZXQgJiYgcmV0LmNvZGUgPT09IEVSUk9SLlVOTUFUQ0hFRF9BU1Qpe1xuICAgICAgICAgIGFzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9ZWxzZSByZXMucHVzaCggcmV0ICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEdyb3VwKHJlcyk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKSByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKGFzdClcbiAgICByZXR1cm4gd2Fsa2Vyc1thc3QudHlwZSB8fCBcImRlZmF1bHRcIl0uY2FsbCh0aGlzLCBhc3QsIG9wdGlvbnMpO1xuICB9LFxuICBfYXBwZW5kOiBmdW5jdGlvbihjb21wb25lbnQpe1xuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQuJHBhcmVudCA9IHRoaXM7XG4gIH0sXG4gIF9oYW5kbGVFdmVudDogZnVuY3Rpb24oZWxlbSwgdHlwZSwgdmFsdWUsIGF0dHJzKXtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgIGZpcmUgPSB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIj8gXy5oYW5kbGVFdmVudC5jYWxsKCB0aGlzLCB2YWx1ZSwgdHlwZSApIDogdmFsdWUsXG4gICAgICBoYW5kbGVyID0gQ29tcG9uZW50LmV2ZW50KHR5cGUpLCBkZXN0cm95O1xuXG4gICAgaWYgKCBoYW5kbGVyICkge1xuICAgICAgZGVzdHJveSA9IGhhbmRsZXIuY2FsbCh0aGlzLCBlbGVtLCBmaXJlLCBhdHRycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbS5vbihlbGVtLCB0eXBlLCBmaXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIgPyBkZXN0cm95IDogZnVuY3Rpb24oKSB7XG4gICAgICBkb20ub2ZmKGVsZW0sIHR5cGUsIGZpcmUpO1xuICAgIH1cbiAgfSxcbiAgLy8gMS4g55So5p2l5aSE55CGZXhwckJvZHkgLT4gRnVuY3Rpb25cbiAgLy8gMi4gbGlzdOmHjOeahOW+queOr1xuICBfdG91Y2hFeHByOiBmdW5jdGlvbihleHByLCBleHQpe1xuICAgIHZhciByYXdnZXQsIGV4dCA9IHRoaXMuX19leHRfXywgdG91Y2hlZCA9IHt9O1xuICAgIGlmKGV4cHIudHlwZSAhPT0gJ2V4cHJlc3Npb24nIHx8IGV4cHIudG91Y2hlZCkgcmV0dXJuIGV4cHI7XG5cbiAgICByYXdnZXQgPSBleHByLmdldDtcbiAgICBpZighcmF3Z2V0KXtcbiAgICAgIHJhd2dldCA9IGV4cHIuZ2V0ID0gbmV3IEZ1bmN0aW9uKF8uY3R4TmFtZSwgXy5leHROYW1lICwgXy5wcmVmaXgrIFwicmV0dXJuIChcIiArIGV4cHIuYm9keSArIFwiKVwiKTtcbiAgICAgIGV4cHIuYm9keSA9IG51bGw7XG4gICAgfVxuICAgIHRvdWNoZWQuZ2V0ID0gIWV4dD8gcmF3Z2V0OiBmdW5jdGlvbihjb250ZXh0LCBlKXtcbiAgICAgIHJldHVybiByYXdnZXQoIGNvbnRleHQsIGUgfHwgZXh0IClcbiAgICB9XG5cbiAgICBpZihleHByLnNldGJvZHkgJiYgIWV4cHIuc2V0KXtcbiAgICAgIHZhciBzZXRib2R5ID0gZXhwci5zZXRib2R5O1xuICAgICAgdmFyIGZpbHRlcnMgPSBleHByLmZpbHRlcnM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZighZmlsdGVycyB8fCAhXy5zb21lKGZpbHRlcnMsIGZ1bmN0aW9uKGZpbHRlcil7IHJldHVybiAhc2VsZi5fZl8oZmlsdGVyKS5zZXQgfSkgKXtcbiAgICAgICAgZXhwci5zZXQgPSBmdW5jdGlvbihjdHgsIHZhbHVlLCBleHQpe1xuICAgICAgICAgIGV4cHIuc2V0ID0gbmV3IEZ1bmN0aW9uKF8uY3R4TmFtZSwgXy5zZXROYW1lICwgXy5leHROYW1lLCBfLnByZWZpeCArIHNldGJvZHkpOyAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gZXhwci5zZXQoY3R4LCB2YWx1ZSwgZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXhwci5maWx0ZXJzID0gZXhwci5zZXRib2R5ID0gbnVsbDtcbiAgICB9XG4gICAgaWYoZXhwci5zZXQpe1xuICAgICAgdG91Y2hlZC5zZXQgPSAhZXh0PyBleHByLnNldCA6IGZ1bmN0aW9uKGN0eCwgdmFsdWUpe1xuICAgICAgICByZXR1cm4gZXhwci5zZXQoY3R4LCB2YWx1ZSwgZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b3VjaGVkLnR5cGUgPSAnZXhwcmVzc2lvbic7XG4gICAgdG91Y2hlZC50b3VjaGVkID0gdHJ1ZTtcbiAgICB0b3VjaGVkLm9uY2UgPSBleHByLm9uY2UgfHwgZXhwci5jb25zdGFudDtcbiAgICByZXR1cm4gdG91Y2hlZFxuICB9LFxuICAvLyBmaW5kIGZpbHRlclxuICBfZl86IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHZhciBmaWx0ZXIgPSBDb21wb25lbnQuZmlsdGVyKG5hbWUpO1xuICAgIGlmKCFmaWx0ZXIpIHRocm93IEVycm9yKCdmaWx0ZXIgJyArIG5hbWUgKyAnIGlzIHVuZGVmaW5lZCcpO1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH0sXG4gIC8vIHNpbXBsZSBhY2Nlc3NvciBnZXRcbiAgX3NnXzpmdW5jdGlvbihwYXRoLCBkZWZhdWx0cywgZXh0KXtcbiAgICBpZiggcGF0aCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZihleHQgJiYgdHlwZW9mIGV4dCA9PT0gJ29iamVjdCcpe1xuICAgICAgaWYoZXh0W3BhdGhdICE9PSB1bmRlZmluZWQpICByZXR1cm4gZXh0W3BhdGhdO1xuICAgIH1cbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVkLFxuICAgICAgY29tcHV0ZWRQcm9wZXJ0eSA9IGNvbXB1dGVkW3BhdGhdO1xuICAgIGlmKGNvbXB1dGVkUHJvcGVydHkpe1xuICAgICAgaWYoY29tcHV0ZWRQcm9wZXJ0eS50eXBlPT09J2V4cHJlc3Npb24nICYmICFjb21wdXRlZFByb3BlcnR5LmdldCkgdGhpcy5fdG91Y2hFeHByKGNvbXB1dGVkUHJvcGVydHkpO1xuICAgICAgaWYoY29tcHV0ZWRQcm9wZXJ0eS5nZXQpICByZXR1cm4gY29tcHV0ZWRQcm9wZXJ0eS5nZXQodGhpcyk7XG4gICAgICBlbHNlIF8ubG9nKFwidGhlIGNvbXB1dGVkICdcIiArIHBhdGggKyBcIicgZG9uJ3QgZGVmaW5lIHRoZSBnZXQgZnVuY3Rpb24sICBnZXQgZGF0YS5cIitwYXRoICsgXCIgYWx0bmF0ZWx5XCIsIFwid2FyblwiKVxuICAgIH1cblxuICAgIGlmKCBkZWZhdWx0cyA9PT0gdW5kZWZpbmVkICApe1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzW3BhdGhdO1xuXG4gIH0sXG4gIC8vIHNpbXBsZSBhY2Nlc3NvciBzZXRcbiAgX3NzXzpmdW5jdGlvbihwYXRoLCB2YWx1ZSwgZGF0YSAsIG9wLCBjb21wdXRlZCl7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy5jb21wdXRlZCxcbiAgICAgIG9wID0gb3AgfHwgXCI9XCIsIHByZXYsIFxuICAgICAgY29tcHV0ZWRQcm9wZXJ0eSA9IGNvbXB1dGVkPyBjb21wdXRlZFtwYXRoXTpudWxsO1xuXG4gICAgaWYob3AgIT09ICc9Jyl7XG4gICAgICBwcmV2ID0gY29tcHV0ZWRQcm9wZXJ0eT8gY29tcHV0ZWRQcm9wZXJ0eS5nZXQodGhpcyk6IGRhdGFbcGF0aF07XG4gICAgICBzd2l0Y2gob3Ape1xuICAgICAgICBjYXNlIFwiKz1cIjpcbiAgICAgICAgICB2YWx1ZSA9IHByZXYgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIi09XCI6XG4gICAgICAgICAgdmFsdWUgPSBwcmV2IC0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIqPVwiOlxuICAgICAgICAgIHZhbHVlID0gcHJldiAqIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiLz1cIjpcbiAgICAgICAgICB2YWx1ZSA9IHByZXYgLyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIiU9XCI6XG4gICAgICAgICAgdmFsdWUgPSBwcmV2ICUgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGNvbXB1dGVkUHJvcGVydHkpIHtcbiAgICAgIGlmKGNvbXB1dGVkUHJvcGVydHkuc2V0KSByZXR1cm4gY29tcHV0ZWRQcm9wZXJ0eS5zZXQodGhpcywgdmFsdWUpO1xuICAgICAgZWxzZSBfLmxvZyhcInRoZSBjb21wdXRlZCAnXCIgKyBwYXRoICsgXCInIGRvbid0IGRlZmluZSB0aGUgc2V0IGZ1bmN0aW9uLCAgYXNzaWduIGRhdGEuXCIrcGF0aCArIFwiIGFsdG5hdGVseVwiLCBcIndhcm5cIiApXG4gICAgfVxuICAgIGRhdGFbcGF0aF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWd1bGFyLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbigpe1xuICBfLmxvZyhcInVzZSAkaW5qZWN0IGluc3RlYWQgb2YgaW5qZWN0XCIsIFwid2FyblwiKTtcbiAgcmV0dXJuIHRoaXMuJGluamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbi8vIG9ubHkgb25lIGJ1aWx0aW4gZmlsdGVyXG5cblJlZ3VsYXIuZmlsdGVyKGZpbHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVndWxhcjtcblxuXG5cbmZ1bmN0aW9uIHRyeUdldFNlbGVjdG9yKHRwbCl7XG4gIHZhciBub2RlO1xuICBpZiggdHlwZW9mIHRwbCA9PT0gJ3N0cmluZycgJiYgdHBsLmxlbmd0aCA8IDE2ICYmIChub2RlID0gZG9tLmZpbmQoIHRwbCApKSApIHtcbiAgICBfLmxvZyhcInBhc3Mgc2VsZWN0b3IgYXMgdGVtcGxhdGUgaGFzIGJlIGRlcHJlY2F0ZWQsIHBhc3Mgbm9kZSBvciB0ZW1wbGF0ZSBzdHJpbmcgaW5zdGVhZFwiLCAnd2FybicpXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9oZWxwZXIvcGFyc2UnKTtcbnZhciBub2RlID0gcmVxdWlyZSgnLi4vcGFyc2VyL25vZGUnKTtcblxuXG5mdW5jdGlvbiBpbml0RGVmaW5pdGlvbihjb250ZXh0LCBkZWZpbml0aW9uLCBiZWZvcmVDb25maWcpe1xuXG4gIHZhciBldmVudENvbmZpZywgaGFzSW5zdGFuY2VDb21wdXRlZCA9ICEhZGVmaW5pdGlvbi5jb21wdXRlZCwgdGVtcGxhdGU7XG4gIHZhciB1c2VQcm90b3R5ZVN0cmluZyA9IHR5cGVvZiBjb250ZXh0LnRlbXBsYXRlID09PSAnc3RyaW5nJyAmJiAhZGVmaW5pdGlvbi50ZW1wbGF0ZTtcblxuIC8vIHRlbXBsYXRlIGlzIGEgc3RyaW5nIChsZW4gPCAxNikuIHdlIHdpbGwgZmluZCBpdCBjb250YWluZXIgZmlyc3RcblxuICBkZWZpbml0aW9uLmRhdGEgPSBkZWZpbml0aW9uLmRhdGEgfHwge307XG4gIGRlZmluaXRpb24uY29tcHV0ZWQgPSBkZWZpbml0aW9uLmNvbXB1dGVkIHx8IHt9O1xuICBpZiggY29udGV4dC5kYXRhICkgXy5leHRlbmQoIGRlZmluaXRpb24uZGF0YSwgY29udGV4dC5kYXRhICk7XG4gIGlmKCBjb250ZXh0LmNvbXB1dGVkICkgXy5leHRlbmQoIGRlZmluaXRpb24uY29tcHV0ZWQsIGNvbnRleHQuY29tcHV0ZWQgKTtcblxuICB2YXIgbGlzdGVuZXJzID0gY29udGV4dC5fZXZlbnRMaXN0ZW5lcnMgfHwgW107XG4gIHZhciBub3JtTGlzdGVuZXI7XG4gIC8vIGhhbmxlIGluaXRpYWxpemVkIGV2ZW50IGJpbmRpbmdcbiAgaWYoIGRlZmluaXRpb24uZXZlbnRzKXtcbiAgICBub3JtTGlzdGVuZXIgPSBfLm5vcm1MaXN0ZW5lcihkZWZpbml0aW9uLmV2ZW50cyk7XG4gICAgaWYobm9ybUxpc3RlbmVyLmxlbmd0aCl7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KG5vcm1MaXN0ZW5lcilcbiAgICB9XG4gICAgZGVsZXRlIGRlZmluaXRpb24uZXZlbnRzO1xuICB9XG5cblxuICBkZWZpbml0aW9uLmRhdGEgPSBkZWZpbml0aW9uLmRhdGEgfHwge307XG4gIGRlZmluaXRpb24uY29tcHV0ZWQgPSBkZWZpbml0aW9uLmNvbXB1dGVkIHx8IHt9O1xuICBpZihjb250ZXh0LmRhdGEpIF8uZXh0ZW5kKGRlZmluaXRpb24uZGF0YSwgY29udGV4dC5kYXRhKTtcbiAgaWYoY29udGV4dC5jb21wdXRlZCkgXy5leHRlbmQoZGVmaW5pdGlvbi5jb21wdXRlZCwgY29udGV4dC5jb21wdXRlZCk7XG5cbiAgdmFyIHVzZVByb3RvdHllU3RyaW5nID0gdHlwZW9mIGNvbnRleHQudGVtcGxhdGUgPT09ICdzdHJpbmcnICYmICFkZWZpbml0aW9uLnRlbXBsYXRlO1xuXG4gIF8uZXh0ZW5kKGNvbnRleHQsIGRlZmluaXRpb24sIHRydWUpO1xuXG5cblxuICBpZihsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCl7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oIGl0ZW0gKXtcbiAgICAgIGNvbnRleHQuJG9uKGl0ZW0udHlwZSwgaXRlbS5saXN0ZW5lcilcbiAgICB9KVxuICB9XG5cblxuICAvLyB3ZSBuZWVkIGFkZCBzb21lIGxvZ2ljIGF0IGNsaWVudC5cbiAgYmVmb3JlQ29uZmlnICYmIGJlZm9yZUNvbmZpZygpO1xuXG4gIC8vIG9ubHkgaGF2ZSBpbnN0YW5jZSBjb21wdXRlZCwgd2UgbmVlZCBwcmVwYXJlIHRoZSBwcm9wZXJ0eVxuICBpZiggaGFzSW5zdGFuY2VDb21wdXRlZCApIGNvbnRleHQuY29tcHV0ZWQgPSBoYW5kbGVDb21wdXRlZChjb250ZXh0LmNvbXB1dGVkKTtcblxuICBjb250ZXh0LiRlbWl0KCBcIiRjb25maWdcIiwgY29udGV4dC5kYXRhICk7XG4gIGNvbnRleHQuY29uZmlnICYmIGNvbnRleHQuY29uZmlnKCBjb250ZXh0LmRhdGEgKTtcbiAgY29udGV4dC4kZW1pdCggXCIkYWZ0ZXJDb25maWdcIiwgY29udGV4dC5kYXRhICk7XG5cbiAgdGVtcGxhdGUgPSBjb250ZXh0LnRlbXBsYXRlO1xuXG4gXG4gIGlmKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0ZW1wbGF0ZSA9IHBhcnNlLnBhcnNlKHRlbXBsYXRlKTtcbiAgICBpZih1c2VQcm90b3R5ZVN0cmluZykge1xuICAgIC8vIGF2b2lkIG11bHRpcGx5IGNvbXBpbGVcbiAgICAgIGNvbnRleHQuY29uc3RydWN0b3IucHJvdG90eXBlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfWVsc2V7XG4gICAgICBkZWxldGUgY29udGV4dC50ZW1wbGF0ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG52YXIgaGFuZGxlQ29tcHV0ZWQgPSAoZnVuY3Rpb24oKXtcbiAgLy8gd3JhcCB0aGUgY29tcHV0ZWQgZ2V0dGVyO1xuICBmdW5jdGlvbiB3cmFwR2V0KGdldCl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgICAgcmV0dXJuIGdldC5jYWxsKGNvbnRleHQsIGNvbnRleHQuZGF0YSApO1xuICAgIH1cbiAgfVxuICAvLyB3cmFwIHRoZSBjb21wdXRlZCBzZXR0ZXI7XG4gIGZ1bmN0aW9uIHdyYXBTZXQoc2V0KXtcbiAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dCwgdmFsdWUpe1xuICAgICAgc2V0LmNhbGwoIGNvbnRleHQsIHZhbHVlLCBjb250ZXh0LmRhdGEgKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oIGNvbXB1dGVkICl7XG4gICAgaWYoIWNvbXB1dGVkKSByZXR1cm47XG4gICAgdmFyIHBhcnNlZENvbXB1dGVkID0ge30sIGhhbmRsZSwgcGFpciwgdHlwZTtcbiAgICBmb3IodmFyIGkgaW4gY29tcHV0ZWQpe1xuICAgICAgaGFuZGxlID0gY29tcHV0ZWRbaV1cbiAgICAgIHR5cGUgPSB0eXBlb2YgaGFuZGxlO1xuXG4gICAgICBpZihoYW5kbGUudHlwZSA9PT0gJ2V4cHJlc3Npb24nKXtcbiAgICAgICAgcGFyc2VkQ29tcHV0ZWRbaV0gPSBoYW5kbGU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoIHR5cGUgPT09IFwic3RyaW5nXCIgKXtcbiAgICAgICAgcGFyc2VkQ29tcHV0ZWRbaV0gPSBwYXJzZS5leHByZXNzaW9uKGhhbmRsZSlcbiAgICAgIH1lbHNle1xuICAgICAgICBwYWlyID0gcGFyc2VkQ29tcHV0ZWRbaV0gPSB7dHlwZTogJ2V4cHJlc3Npb24nfTtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJmdW5jdGlvblwiICl7XG4gICAgICAgICAgcGFpci5nZXQgPSB3cmFwR2V0KGhhbmRsZSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGlmKGhhbmRsZS5nZXQpIHBhaXIuZ2V0ID0gd3JhcEdldChoYW5kbGUuZ2V0KTtcbiAgICAgICAgICBpZihoYW5kbGUuc2V0KSBwYWlyLnNldCA9IHdyYXBTZXQoaGFuZGxlLnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRDb21wdXRlZDtcbiAgfVxufSkoKTtcblxuXG5mdW5jdGlvbiBwcmVwYXJlQXR0ciAoIGFzdCAsZGlyZWN0aXZlICl7XG4gIGlmKGFzdC5wYXJzZWQgKSByZXR1cm4gYXN0O1xuICB2YXIgdmFsdWUgPSBhc3QudmFsdWU7XG4gIHZhciBuYW1lPSAgYXN0Lm5hbWUsIGJvZHksIGNvbnN0YW50O1xuICBpZih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIH52YWx1ZS5pbmRleE9mKGNvbmZpZy5CRUdJTikgJiYgfnZhbHVlLmluZGV4T2YoY29uZmlnLkVORCkgKXtcbiAgICBpZiggIWRpcmVjdGl2ZSB8fCAhZGlyZWN0aXZlLm5wcyApIHtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZS5wYXJzZSh2YWx1ZSwgeyBtb2RlOiAyIH0pO1xuICAgICAgaWYocGFyc2VkLmxlbmd0aCA9PT0gMSAmJiBwYXJzZWRbMF0udHlwZSA9PT0gJ2V4cHJlc3Npb24nKXsgXG4gICAgICAgIGJvZHkgPSBwYXJzZWRbMF07XG4gICAgICB9IGVsc2V7XG4gICAgICAgIGNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgYm9keSA9IFtdO1xuICAgICAgICBwYXJzZWQuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICBpZighaXRlbS5jb25zdGFudCkgY29uc3RhbnQ9ZmFsc2U7XG4gICAgICAgICAgLy8gc2lsZW50IHRoZSBtdXRpcGxlIGludGVwbGF0aW9uXG4gICAgICAgICAgICBib2R5LnB1c2goaXRlbS5ib2R5IHx8IFwiJ1wiICsgaXRlbS50ZXh0LnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKSArIFwiJ1wiKTsgICAgICAgIFxuICAgICAgICB9KTtcbiAgICAgICAgYm9keSA9IG5vZGUuZXhwcmVzc2lvbihcIltcIiArIGJvZHkuam9pbihcIixcIikgKyBcIl0uam9pbignJylcIiwgbnVsbCwgY29uc3RhbnQpO1xuICAgICAgfVxuICAgICAgYXN0LnZhbHVlID0gYm9keTtcbiAgICB9XG4gIH1cbiAgYXN0LnBhcnNlZCA9IHRydWU7XG4gIHJldHVybiBhc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBzaGFyZSBsb2dpYyBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50XG4gIGluaXREZWZpbml0aW9uOiBpbml0RGVmaW5pdGlvbixcbiAgaGFuZGxlQ29tcHV0ZWQ6IGhhbmRsZUNvbXB1dGVkLFxuICBwcmVwYXJlQXR0cjogcHJlcGFyZUF0dHJcbn0iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5yZXF1aXJlKCcuL2hlbHBlci9zaGltJykoKTtcblxuXG5cbnZhciBfICA9IG1vZHVsZS5leHBvcnRzO1xudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnLi9oZWxwZXIvZW50aXRpZXMnKTtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIG8yc3RyID0gKHt9KS50b1N0cmluZztcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSd1bmRlZmluZWQnPyB3aW5kb3c6IGdsb2JhbDtcbnZhciBNQVhfUFJJT1JJVFkgPSA5OTk5O1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cblxuXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXy51aWQgPSAoZnVuY3Rpb24oKXtcbiAgdmFyIF91aWQ9MDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIF91aWQrKztcbiAgfVxufSkoKTtcblxuXy5leHRlbmQgPSBmdW5jdGlvbiggbzEsIG8yLCBvdmVycmlkZSApe1xuICBmb3IodmFyIGkgaW4gbzIpIGlmIChvMi5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgaWYoIG8xW2ldID09PSB1bmRlZmluZWQgfHwgb3ZlcnJpZGUgPT09IHRydWUgKXtcbiAgICAgIG8xW2ldID0gbzJbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG8xO1xufVxuXG5fLmtleXMgPSBPYmplY3Qua2V5cz8gT2JqZWN0LmtleXM6IGZ1bmN0aW9uKG9iail7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yKHZhciBpIGluIG9iaikgaWYob2JqLmhhc093blByb3BlcnR5KGkpKXtcbiAgICByZXMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5fLnNvbWUgPSBmdW5jdGlvbihsaXN0LCBmbil7XG4gIGZvcih2YXIgaSA9MCxsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICBpZihmbihsaXN0W2ldKSkgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5fLnZhck5hbWUgPSAnZCc7XG5fLnNldE5hbWUgPSAncF8nO1xuXy5jdHhOYW1lID0gJ2MnO1xuXy5leHROYW1lID0gJ2UnO1xuXG5fLnJXb3JkID0gL15bXFwkXFx3XSskLztcbl8uclNpbXBsZUFjY2Vzc29yID0gL15bXFwkXFx3XSsoXFwuW1xcJFxcd10rKSokLztcblxuXy5uZXh0VGljayA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbic/IFxuICBzZXRJbW1lZGlhdGUuYmluZCh3aW4pIDogXG4gIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCkgXG4gIH1cblxuXG5cbl8ucHJlZml4ID0gXCIndXNlIHN0cmljdCc7dmFyIFwiICsgXy52YXJOYW1lICsgXCI9XCIgKyBfLmN0eE5hbWUgKyBcIi5kYXRhO1wiICsgIF8uZXh0TmFtZSAgKyBcIj1cIiArIF8uZXh0TmFtZSArIFwifHwnJztcIjtcblxuXG5fLnNsaWNlID0gZnVuY3Rpb24ob2JqLCBzdGFydCwgZW5kKXtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IodmFyIGkgPSBzdGFydCB8fCAwLCBsZW4gPSBlbmQgfHwgb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICByZXMucHVzaChvYmpbaV0pXG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gYmVhY3VzZSBzbGljZSBhbmQgdG9Mb3dlckNhc2UgaXMgZXhwZW5zaXZlLiB3ZSBoYW5kbGUgdW5kZWZpbmVkIGFuZCBudWxsIGluIGFub3RoZXIgd2F5XG5fLnR5cGVPZiA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBvID09IG51bGwgPyBTdHJpbmcobykgOm8yc3RyLmNhbGwobykuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG59XG5cblxuXG5cbl8ubWFrZVByZWRpY2F0ZSA9IGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUod29yZHMsIHByZWZpeCkge1xuICAgIGlmICh0eXBlb2Ygd29yZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgd29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG4gICAgfVxuICAgIHZhciBmID0gXCJcIixcbiAgICBjYXRzID0gW107XG4gICAgb3V0OiBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2F0cy5sZW5ndGg7ICsrail7XG4gICAgICAgICAgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09PSB3b3Jkc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHJldHVybiBmICs9IFwicmV0dXJuIHN0ciA9PT0gJ1wiICsgYXJyWzBdICsgXCInO1wiO1xuICAgICAgICBmICs9IFwic3dpdGNoKHN0cil7XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgZiArPSBcImNhc2UgJ1wiICsgYXJyW2ldICsgXCInOlwiO1xuICAgICAgICB9XG4gICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIHRocmVlIGxlbmd0aCBjYXRlZ29yaWVzLCBhbiBvdXRlclxuICAgIC8vIHN3aXRjaCBmaXJzdCBkaXNwYXRjaGVzIG9uIHRoZSBsZW5ndGhzLCB0byBzYXZlIG9uIGNvbXBhcmlzb25zLlxuICAgIGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgY2F0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgZiArPSBcInN3aXRjaChzdHIubGVuZ3RoKXtcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2F0ID0gY2F0c1tpXTtcbiAgICAgICAgICAgIGYgKz0gXCJjYXNlIFwiICsgY2F0WzBdLmxlbmd0aCArIFwiOlwiO1xuICAgICAgICAgICAgY29tcGFyZVRvKGNhdCk7XG4gICAgICAgIH1cbiAgICAgICAgZiArPSBcIn1cIjtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIHNpbXBseSBnZW5lcmF0ZSBhIGZsYXQgYHN3aXRjaGAgc3RhdGVtZW50LlxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBhcmVUbyh3b3Jkcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIiwgZik7XG59XG5cblxuXy50cmFja0Vycm9yUG9zID0gKGZ1bmN0aW9uICgpe1xuICAvLyBsaW5lYnJlYWtcbiAgdmFyIGxiID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG4gIHZhciBtaW5SYW5nZSA9IDIwLCBtYXhSYW5nZSA9IDIwO1xuICBmdW5jdGlvbiBmaW5kTGluZShsaW5lcywgcG9zKXtcbiAgICB2YXIgdG1wTGVuID0gMDtcbiAgICBmb3IodmFyIGkgPSAwLGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgIHZhciBsaW5lTGVuID0gKGxpbmVzW2ldIHx8IFwiXCIpLmxlbmd0aDtcblxuICAgICAgaWYodG1wTGVuICsgbGluZUxlbiA+IHBvcykge1xuICAgICAgICByZXR1cm4ge251bTogaSwgbGluZTogbGluZXNbaV0sIHN0YXJ0OiBwb3MgLSBpIC0gdG1wTGVuICwgcHJldjpsaW5lc1tpLTFdLCBuZXh0OiBsaW5lc1tpKzFdIH07XG4gICAgICB9XG4gICAgICAvLyAxIGlzIGZvciB0aGUgbGluZWJyZWFrXG4gICAgICB0bXBMZW4gPSB0bXBMZW4gKyBsaW5lTGVuIDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0TGluZShzdHIsICBzdGFydCwgbnVtLCB0YXJnZXQpe1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBtaW4gPSBzdGFydCAtIG1pblJhbmdlO1xuICAgIGlmKG1pbiA8IDApIG1pbiA9IDA7XG4gICAgdmFyIG1heCA9IHN0YXJ0ICsgbWF4UmFuZ2U7XG4gICAgaWYobWF4ID4gbGVuKSBtYXggPSBsZW47XG5cbiAgICB2YXIgcmVtYWluID0gc3RyLnNsaWNlKG1pbiwgbWF4KTtcbiAgICB2YXIgcHJlZml4ID0gXCJbXCIgKyhudW0rMSkgKyBcIl0gXCIgKyAobWluID4gMD8gXCIuLlwiIDogXCJcIilcbiAgICB2YXIgcG9zdGZpeCA9IG1heCA8IGxlbiA/IFwiLi5cIjogXCJcIjtcbiAgICB2YXIgcmVzID0gcHJlZml4ICsgcmVtYWluICsgcG9zdGZpeDtcbiAgICBpZih0YXJnZXQpIHJlcyArPSBcIlxcblwiICsgbmV3IEFycmF5KHN0YXJ0LW1pbiArIHByZWZpeC5sZW5ndGggKyAxKS5qb2luKFwiIFwiKSArIFwiXl5eXCI7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIHBvcyl7XG4gICAgaWYocG9zID4gaW5wdXQubGVuZ3RoLTEpIHBvcyA9IGlucHV0Lmxlbmd0aC0xO1xuICAgIGxiLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQobGIpO1xuICAgIHZhciBsaW5lID0gZmluZExpbmUobGluZXMscG9zKTtcbiAgICB2YXIgc3RhcnQgPSBsaW5lLnN0YXJ0LCBudW0gPSBsaW5lLm51bTtcblxuICAgIHJldHVybiAobGluZS5wcmV2PyBmb3JtYXRMaW5lKGxpbmUucHJldiwgc3RhcnQsIG51bS0xICkgKyAnXFxuJzogJycgKSArIFxuICAgICAgZm9ybWF0TGluZShsaW5lLmxpbmUsIHN0YXJ0LCBudW0sIHRydWUpICsgJ1xcbicgKyBcbiAgICAgIChsaW5lLm5leHQ/IGZvcm1hdExpbmUobGluZS5uZXh0LCBzdGFydCwgbnVtKzEgKSArICdcXG4nOiAnJyApO1xuXG4gIH1cbn0pKCk7XG5cblxudmFyIGlnbm9yZWRSZWYgPSAvXFwoKFxcP1xcIXxcXD9cXDp8XFw/XFw9KS9nO1xuXy5maW5kU3ViQ2FwdHVyZSA9IGZ1bmN0aW9uIChyZWdTdHIpIHtcbiAgdmFyIGxlZnQgPSAwLFxuICAgIHJpZ2h0ID0gMCxcbiAgICBsZW4gPSByZWdTdHIubGVuZ3RoLFxuICAgIGlnbm9yZWQgPSByZWdTdHIubWF0Y2goaWdub3JlZFJlZik7IC8vIGlnbm9yZWQgdW5jYXB0dXJlXG4gIGlmKGlnbm9yZWQpIGlnbm9yZWQgPSBpZ25vcmVkLmxlbmd0aFxuICBlbHNlIGlnbm9yZWQgPSAwO1xuICBmb3IgKDsgbGVuLS07KSB7XG4gICAgdmFyIGxldHRlciA9IHJlZ1N0ci5jaGFyQXQobGVuKTtcbiAgICBpZiAobGVuID09PSAwIHx8IHJlZ1N0ci5jaGFyQXQobGVuIC0gMSkgIT09IFwiXFxcXFwiICkgeyBcbiAgICAgIGlmIChsZXR0ZXIgPT09IFwiKFwiKSBsZWZ0Kys7XG4gICAgICBpZiAobGV0dGVyID09PSBcIilcIikgcmlnaHQrKztcbiAgICB9XG4gIH1cbiAgaWYgKGxlZnQgIT09IHJpZ2h0KSB0aHJvdyBcIlJlZ0V4cDogXCIrIHJlZ1N0ciArIFwiJ3MgYnJhY2tldCBpcyBub3QgbWFyY2hlZFwiO1xuICBlbHNlIHJldHVybiBsZWZ0IC0gaWdub3JlZDtcbn07XG5cblxuXy5lc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiggc3RyKXsvLyBDcmVkaXQ6IFhSZWdFeHAgMC42LjEgKGMpIDIwMDctMjAwOCBTdGV2ZW4gTGV2aXRoYW4gPGh0dHA6Ly9zdGV2ZW5sZXZpdGhhbi5jb20vcmVnZXgveHJlZ2V4cC8+IE1JVCBMaWNlbnNlXG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxde30oKSorPy5cXFxcXiR8LCNcXHNdL2csIGZ1bmN0aW9uKG1hdGNoKXtcbiAgICByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7XG4gIH0pO1xufTtcblxuXG52YXIgckVudGl0eSA9IG5ldyBSZWdFeHAoXCImKD86KCN4WzAtOWEtZkEtRl0rKXwoI1swLTldKyl8KFwiICsgXy5rZXlzKGVudGl0aWVzKS5qb2luKCd8JykgKyAnKSk7JywgJ2dpJyk7XG5cbl8uY29udmVydEVudGl0eSA9IGZ1bmN0aW9uKGNocil7XG5cbiAgcmV0dXJuIChcIlwiICsgY2hyKS5yZXBsYWNlKHJFbnRpdHksIGZ1bmN0aW9uKGFsbCwgaGV4LCBkZWMsIGNhcHR1cmUpe1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICBpZiggZGVjICkgY2hhckNvZGUgPSBwYXJzZUludCggZGVjLnNsaWNlKDEpLCAxMCApO1xuICAgIGVsc2UgaWYoIGhleCApIGNoYXJDb2RlID0gcGFyc2VJbnQoIGhleC5zbGljZSgyKSwgMTYgKTtcbiAgICBlbHNlIGNoYXJDb2RlID0gZW50aXRpZXNbY2FwdHVyZV1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaGFyQ29kZSApXG4gIH0pO1xuXG59XG5cblxuLy8gc2ltcGxlIGdldCBhY2Nlc3NvclxuXG5fLmNyZWF0ZU9iamVjdCA9IE9iamVjdC5jcmVhdGU/IGZ1bmN0aW9uKG8pe1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShvIHx8IG51bGwpXG59OiAoZnVuY3Rpb24oKXtcbiAgICBmdW5jdGlvbiBUZW1wKCkge31cbiAgICByZXR1cm4gZnVuY3Rpb24obyl7XG4gICAgICBpZighbykgcmV0dXJuIHt9XG4gICAgICBUZW1wLnByb3RvdHlwZSA9IG87XG4gICAgICB2YXIgb2JqID0gbmV3IFRlbXAoKTtcbiAgICAgIFRlbXAucHJvdG90eXBlID0gbnVsbDsgLy8g5LiN6KaB5L+d5oyB5LiA5LiqIE8g55qE5p2C5pWj5byV55So77yIYSBzdHJheSByZWZlcmVuY2XvvIkuLi5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG59KSgpO1xuXG5fLmNyZWF0ZVByb3RvID0gZnVuY3Rpb24oZm4sIG8pe1xuICAgIGZ1bmN0aW9uIEZvbygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGZuO31cbiAgICBGb28ucHJvdG90eXBlID0gbztcbiAgICByZXR1cm4gKGZuLnByb3RvdHlwZSA9IG5ldyBGb28oKSk7XG59XG5cblxuXy5yZW1vdmVPbmUgPSBmdW5jdGlvbihsaXN0ICwgZmlsdGVyKXtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBmb3IoO2xlbi0tOyl7XG4gICAgaWYoZmlsdGVyKGxpc3RbbGVuXSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGxlbiwgMSlcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbmNsb25lXG4qL1xuXy5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iail7XG4gIGlmKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICkpIHJldHVybiBvYmo7XG4gIGlmKEFycmF5LmlzQXJyYXkob2JqKSl7XG4gICAgdmFyIGNsb25lZCA9IFtdO1xuICAgIGZvcih2YXIgaT0wLGxlbiA9IG9iai5sZW5ndGg7IGk8IGxlbjtpKyspe1xuICAgICAgY2xvbmVkW2ldID0gb2JqW2ldXG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1lbHNle1xuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBmb3IodmFyIGkgaW4gb2JqKSBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpe1xuICAgICAgY2xvbmVkW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59XG5cbl8uZXF1YWxzID0gZnVuY3Rpb24obm93LCBvbGQpe1xuICB2YXIgdHlwZSA9IHR5cGVvZiBub3c7XG4gIGlmKHR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvbGQgPT09ICdudW1iZXInJiYgaXNOYU4obm93KSAmJiBpc05hTihvbGQpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gbm93ID09PSBvbGQ7XG59XG5cbnZhciBkYXNoID0gLy0oW2Etel0pL2c7XG5fLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZShkYXNoLCBmdW5jdGlvbihhbGwsIGNhcHR1cmUpe1xuICAgIHJldHVybiBjYXB0dXJlLnRvVXBwZXJDYXNlKCk7XG4gIH0pXG59XG5cblxuXG5fLnRocm90dGxlID0gZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCl7XG4gIHZhciB3YWl0ID0gd2FpdCB8fCAxMDA7XG4gIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcHJldmlvdXMgPSArbmV3IERhdGU7XG4gICAgdGltZW91dCA9IG51bGw7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm93ID0gKyBuZXcgRGF0ZTtcbiAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG4vLyBob2dhbiBlc2NhcGVcbi8vID09PT09PT09PT09PT09XG5fLmVzY2FwZSA9IChmdW5jdGlvbigpe1xuICB2YXIgckFtcCA9IC8mL2csXG4gICAgICByTHQgPSAvPC9nLFxuICAgICAgckd0ID0gLz4vZyxcbiAgICAgIHJBcG9zID0gL1xcJy9nLFxuICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgaENoYXJzID0gL1smPD5cXFwiXFwnXS87XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBoQ2hhcnMudGVzdChzdHIpID9cbiAgICAgIHN0clxuICAgICAgICAucmVwbGFjZShyQW1wLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZShyTHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2Uockd0LCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKHJBcG9zLCAnJiMzOTsnKVxuICAgICAgICAucmVwbGFjZShyUXVvdCwgJyZxdW90OycpIDpcbiAgICAgIHN0cjtcbiAgfVxufSkoKTtcblxuXy5jYWNoZSA9IGZ1bmN0aW9uKG1heCl7XG4gIG1heCA9IG1heCB8fCAxMDAwO1xuICB2YXIga2V5cyA9IFtdLFxuICAgICAgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIGNhY2hlW2tleXMuc2hpZnQoKV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAvLyBcbiAgICAgIGlmKGNhY2hlW2tleV0gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgY2FjaGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNhY2hlO1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgfSxcbiAgICBtYXg6IG1heCxcbiAgICBsZW46ZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICB9XG4gIH07XG59XG5cbi8vIC8vIHNldHVwIHRoZSByYXcgRXhwcmVzc2lvblxuXG5cbi8vIGhhbmRsZSB0aGUgc2FtZSBsb2dpYyBvbiBjb21wb25lbnQncyBgb24tKmAgYW5kIGVsZW1lbnQncyBgb24tKmBcbi8vIHJldHVybiB0aGUgZmlyZSBvYmplY3Rcbl8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSApe1xuICB2YXIgc2VsZiA9IHRoaXMsIGV2YWx1YXRlO1xuICBpZih2YWx1ZS50eXBlID09PSAnZXhwcmVzc2lvbicpeyAvLyBpZiBpcyBleHByZXNzaW9uLCBnbyBldmFsdWF0ZWQgd2F5XG4gICAgZXZhbHVhdGUgPSB2YWx1ZS5nZXQ7XG4gIH1cbiAgaWYoZXZhbHVhdGUpe1xuICAgIHJldHVybiBmdW5jdGlvbiBmaXJlKG9iail7XG4gICAgICBzZWxmLiR1cGRhdGUoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGRhdGEuJGV2ZW50ID0gb2JqO1xuICAgICAgICB2YXIgcmVzID0gZXZhbHVhdGUoc2VsZik7XG4gICAgICAgIGlmKHJlcyA9PT0gZmFsc2UgJiYgb2JqICYmIG9iai5wcmV2ZW50RGVmYXVsdCkgb2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuJGV2ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSlcblxuICAgIH1cbiAgfWVsc2V7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpcmUoKXtcbiAgICAgIHZhciBhcmdzID0gXy5zbGljZShhcmd1bWVudHMpO1xuICAgICAgYXJncy51bnNoaWZ0KHZhbHVlKTtcbiAgICAgIHNlbGYuJHVwZGF0ZShmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLiRlbWl0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSBjYWxsIG9uY2Vcbl8ub25jZSA9IGZ1bmN0aW9uKGZuKXtcbiAgdmFyIHRpbWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBpZiggdGltZSsrID09PSAwKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbl8uZml4T2JqU3RyID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYoc3RyLnRyaW0oKS5pbmRleE9mKCd7JykgIT09IDApe1xuICAgIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5fLm1hcD0gZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrKXtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXMucHVzaChjYWxsYmFjayhhcnJheVtpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2csIHR5cGUpe1xuICBpZih0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgIGNvbnNvbGVbdHlwZSB8fCBcImxvZ1wiXShtc2cpO1xufVxuXG5fLmxvZyA9IGxvZztcblxuXG5fLm5vcm1MaXN0ZW5lciA9IGZ1bmN0aW9uKCBldmVudHMgICl7XG4gICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdmFyIHBUeXBlID0gXy50eXBlT2YoIGV2ZW50cyApO1xuICAgIGlmKCBwVHlwZSA9PT0gJ2FycmF5JyApe1xuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9ZWxzZSBpZiAoIHBUeXBlID09PSAnb2JqZWN0JyApe1xuICAgICAgZm9yKCB2YXIgaSBpbiBldmVudHMgKSBpZiAoIGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShpKSApe1xuICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpLFxuICAgICAgICAgIGxpc3RlbmVyOiBldmVudHNbaV1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJzO1xufVxuXG5cbi8vaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc2luZ2xlLXBhZ2UuaHRtbCN2b2lkLWVsZW1lbnRzXG5fLmlzVm9pZFRhZyA9IF8ubWFrZVByZWRpY2F0ZShcImFyZWEgYmFzZSBiciBjb2wgZW1iZWQgaHIgaW1nIGlucHV0IGtleWdlbiBsaW5rIG1lbnVpdGVtIG1ldGEgcGFyYW0gc291cmNlIHRyYWNrIHdiciByLWNvbnRlbnRcIik7XG5fLmlzQm9vbGVhbkF0dHIgPSBfLm1ha2VQcmVkaWNhdGUoJ3NlbGVjdGVkIGNoZWNrZWQgZGlzYWJsZWQgcmVhZG9ubHkgcmVxdWlyZWQgb3BlbiBhdXRvZm9jdXMgY29udHJvbHMgYXV0b3BsYXkgY29tcGFjdCBsb29wIGRlZmVyIG11bHRpcGxlJyk7XG5cblxuXy5pc0V4cHIgPSBmdW5jdGlvbihleHByKXtcbiAgcmV0dXJuIGV4cHIgJiYgZXhwci50eXBlID09PSAnZXhwcmVzc2lvbic7XG59XG4vLyBAVE9ETzogbWFrZSBpdCBtb3JlIHN0cmljdFxuXy5pc0dyb3VwID0gZnVuY3Rpb24oZ3JvdXApe1xuICByZXR1cm4gZ3JvdXAuaW5qZWN0IHx8IGdyb3VwLiRpbmplY3Q7XG59XG5cbl8uYmxhbmtSZWcgPSAvXFxzKy87IFxuXG5fLmdldENvbXBpbGVGbiA9IGZ1bmN0aW9uKHNvdXJjZSwgY3R4LCBvcHRpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBwYXNzZWRPcHRpb25zICl7XG4gICAgaWYoIHBhc3NlZE9wdGlvbnMgJiYgb3B0aW9ucyApIF8uZXh0ZW5kKCBwYXNzZWRPcHRpb25zICwgb3B0aW9ucyApO1xuICAgIGVsc2UgcGFzc2VkT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGN0eC4kY29tcGlsZShzb3VyY2UsIHBhc3NlZE9wdGlvbnMgKVxuICB9XG4gIHJldHVybiBjdHguJGNvbXBpbGUuYmluZChjdHgsc291cmNlLCBvcHRpb25zKVxufVxuXG4vLyByZW1vdmUgZGlyZWN0aXZlIHBhcmFtIGZyb20gQVNUXG5fLmZpeFRhZ0FTVCA9IGZ1bmN0aW9uKCB0YWdBU1QsIENvbXBvbmVudCApe1xuXG4gIGlmKCB0YWdBU1QudG91Y2hlZCApIHJldHVybjtcblxuICB2YXIgYXR0cnMgPSB0YWdBU1QuYXR0cnM7XG5cbiAgaWYoICFhdHRycyApIHJldHVybjtcblxuICAvLyBNYXliZSBtdWx0aXBsZSBkaXJlY3RpdmUgbmVlZCBzYW1lIHBhcmFtLCBcbiAgLy8gV2UgcGxhY2UgYWxsIHBhcmFtIGluIHRvdGFsUGFyYW1NYXBcbiAgdmFyIGxlbiA9IGF0dHJzLmxlbmd0aDtcbiAgaWYoIWxlbikgcmV0dXJuO1xuICB2YXIgZGlyZWN0aXZlcz1bXSwgb3RoZXJBdHRyTWFwID0ge307XG4gIGZvcig7bGVuLS07KXtcblxuICAgIHZhciBhdHRyID0gYXR0cnNbIGxlbiBdO1xuXG5cbiAgICAvLyBASUUgZml4IElFOS0gaW5wdXQgdHlwZSBjYW4ndCBhc3NpZ24gYWZ0ZXIgdmFsdWVcbiAgICBpZihhdHRyLm5hbWUgPT09ICd0eXBlJykgYXR0ci5wcmlvcml0eSA9IE1BWF9QUklPUklUWSArIDE7XG5cbiAgICB2YXIgZGlyZWN0aXZlID0gQ29tcG9uZW50LmRpcmVjdGl2ZSggYXR0ci5uYW1lICk7XG4gICAgaWYoIGRpcmVjdGl2ZSApIHtcblxuICAgICAgYXR0ci5wcmlvcml0eSA9IGRpcmVjdGl2ZS5wcmlvcml0eSB8fCAxO1xuICAgICAgYXR0ci5kaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgZGlyZWN0aXZlcy5wdXNoKGF0dHIpO1xuXG4gICAgfWVsc2UgaWYoYXR0ci50eXBlID09PSAnYXR0cmlidXRlJyl7XG4gICAgICBvdGhlckF0dHJNYXBbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGlyZWN0aXZlcy5mb3JFYWNoKCBmdW5jdGlvbiggYXR0ciApe1xuICAgIHZhciBkaXJlY3RpdmUgPSBDb21wb25lbnQuZGlyZWN0aXZlKGF0dHIubmFtZSk7XG4gICAgdmFyIHBhcmFtID0gZGlyZWN0aXZlLnBhcmFtO1xuICAgIGlmKHBhcmFtICYmIHBhcmFtLmxlbmd0aCl7XG4gICAgICBhdHRyLnBhcmFtID0ge307XG4gICAgICBwYXJhbS5mb3JFYWNoKGZ1bmN0aW9uKCBuYW1lICl7XG4gICAgICAgIGlmKCBuYW1lIGluIG90aGVyQXR0ck1hcCApe1xuICAgICAgICAgIGF0dHIucGFyYW1bbmFtZV0gPSBvdGhlckF0dHJNYXBbbmFtZV0gPT09IHVuZGVmaW5lZD8gdHJ1ZTogb3RoZXJBdHRyTWFwW25hbWVdXG4gICAgICAgICAgXy5yZW1vdmVPbmUoYXR0cnMsIGZ1bmN0aW9uKGF0dHIpe1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KTtcblxuICBhdHRycy5zb3J0KGZ1bmN0aW9uKGExLCBhMil7XG4gICAgXG4gICAgdmFyIHAxID0gYTEucHJpb3JpdHk7XG4gICAgdmFyIHAyID0gYTIucHJpb3JpdHk7XG5cbiAgICBpZiggcDEgPT0gbnVsbCApIHAxID0gTUFYX1BSSU9SSVRZO1xuICAgIGlmKCBwMiA9PSBudWxsICkgcDIgPSBNQVhfUFJJT1JJVFk7XG5cbiAgICByZXR1cm4gcDIgLSBwMTtcblxuICB9KVxuXG4gIHRhZ0FTVC50b3VjaGVkID0gdHJ1ZTtcbn1cblxuXy5maW5kSXRlbSA9IGZ1bmN0aW9uKGxpc3QsIGZpbHRlcil7XG4gIGlmKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlKGxlbi0tKXtcbiAgICBpZihmaWx0ZXIobGlzdFtsZW5dKSkgcmV0dXJuIGxpc3RbbGVuXVxuICB9XG59XG5cbl8uZ2V0UGFyYW1PYmogPSBmdW5jdGlvbihjb21wb25lbnQsIHBhcmFtKXtcbiAgdmFyIHBhcmFtT2JqID0ge307XG4gIGlmKHBhcmFtKSB7XG4gICAgZm9yKHZhciBpIGluIHBhcmFtKSBpZihwYXJhbS5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbVtpXTtcbiAgICAgIHBhcmFtT2JqW2ldID0gIHZhbHVlICYmIHZhbHVlLnR5cGU9PT0nZXhwcmVzc2lvbic/IGNvbXBvbmVudC4kZ2V0KHZhbHVlKTogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbU9iajtcbn1cbl8uZXZlbnRSZWcgPSAvXm9uLShcXHdbLVxcd10rKSQvO1xuXG5fLnRvVGV4dCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBvYmogPT0gbnVsbCA/IFwiXCI6IFwiXCIgKyBvYmo7XG59XG5cblxuLy8gaG9nYW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2l0dGVyL2hvZ2FuLmpzXG4vLyBNSVRcbl8uZXNjYXBlID0gKGZ1bmN0aW9uKCl7XG4gIHZhciByQW1wID0gLyYvZyxcbiAgICAgIHJMdCA9IC88L2csXG4gICAgICByR3QgPSAvPi9nLFxuICAgICAgckFwb3MgPSAvXFwnL2csXG4gICAgICByUXVvdCA9IC9cXFwiL2csXG4gICAgICBoQ2hhcnMgPSAvWyY8PlxcXCJcXCddLztcblxuICBmdW5jdGlvbiBpZ25vcmVOdWxsVmFsKHZhbCkge1xuICAgIHJldHVybiBTdHJpbmcoKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PSBudWxsKSA/ICcnIDogdmFsKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgc3RyID0gaWdub3JlTnVsbFZhbChzdHIpO1xuICAgIHJldHVybiBoQ2hhcnMudGVzdChzdHIpID9cbiAgICAgIHN0clxuICAgICAgICAucmVwbGFjZShyQW1wLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZShyTHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2Uockd0LCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKHJBcG9zLCAnJiMzOTsnKVxuICAgICAgICAucmVwbGFjZShyUXVvdCwgJyZxdW90OycpIDpcbiAgICAgIHN0cjtcbiAgfVxuXG59KSgpO1xuXG5cblxuXG5cblxuXG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OXlaV2QxYkdGeWFuTXZiR2xpTDNWMGFXd3Vhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SnlaWEYxYVhKbEtDY3VMMmhsYkhCbGNpOXphR2x0Snlrb0tUdGNibHh1WEc1Y2JuWmhjaUJmSUNBOUlHMXZaSFZzWlM1bGVIQnZjblJ6TzF4dWRtRnlJR1Z1ZEdsMGFXVnpJRDBnY21WeGRXbHlaU2duTGk5b1pXeHdaWEl2Wlc1MGFYUnBaWE1uS1R0Y2JuWmhjaUJ6YkdsalpTQTlJRnRkTG5Oc2FXTmxPMXh1ZG1GeUlHOHljM1J5SUQwZ0tIdDlLUzUwYjFOMGNtbHVaenRjYm5aaGNpQjNhVzRnUFNCMGVYQmxiMllnZDJsdVpHOTNJQ0U5UFNkMWJtUmxabWx1WldRblB5QjNhVzVrYjNjNklHZHNiMkpoYkR0Y2JuWmhjaUJOUVZoZlVGSkpUMUpKVkZrZ1BTQTVPVGs1TzF4dWRtRnlJR052Ym1acFp5QTlJSEpsY1hWcGNtVW9KeTR2WTI5dVptbG5KeWs3WEc1Y2JseHVYeTV1YjI5d0lEMGdablZ1WTNScGIyNG9LWHQ5TzF4dVh5NTFhV1FnUFNBb1puVnVZM1JwYjI0b0tYdGNiaUFnZG1GeUlGOTFhV1E5TUR0Y2JpQWdjbVYwZFhKdUlHWjFibU4wYVc5dUtDbDdYRzRnSUNBZ2NtVjBkWEp1SUY5MWFXUXJLenRjYmlBZ2ZWeHVmU2tvS1R0Y2JseHVYeTVsZUhSbGJtUWdQU0JtZFc1amRHbHZiaWdnYnpFc0lHOHlMQ0J2ZG1WeWNtbGtaU0FwZTF4dUlDQm1iM0lvZG1GeUlHa2dhVzRnYnpJcElHbG1JQ2h2TWk1b1lYTlBkMjVRY205d1pYSjBlU2hwS1NsN1hHNGdJQ0FnYVdZb0lHOHhXMmxkSUQwOVBTQjFibVJsWm1sdVpXUWdmSHdnYjNabGNuSnBaR1VnUFQwOUlIUnlkV1VnS1h0Y2JpQWdJQ0FnSUc4eFcybGRJRDBnYnpKYmFWMWNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUc4eE8xeHVmVnh1WEc1ZkxtdGxlWE1nUFNCUFltcGxZM1F1YTJWNWN6OGdUMkpxWldOMExtdGxlWE02SUdaMWJtTjBhVzl1S0c5aWFpbDdYRzRnSUhaaGNpQnlaWE1nUFNCYlhUdGNiaUFnWm05eUtIWmhjaUJwSUdsdUlHOWlhaWtnYVdZb2IySnFMbWhoYzA5M2JsQnliM0JsY25SNUtHa3BLWHRjYmlBZ0lDQnlaWE11Y0hWemFDaHBLVHRjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdjbVZ6TzF4dWZWeHVYRzVmTG5OdmJXVWdQU0JtZFc1amRHbHZiaWhzYVhOMExDQm1iaWw3WEc0Z0lHWnZjaWgyWVhJZ2FTQTlNQ3hzWlc0Z1BTQnNhWE4wTG14bGJtZDBhRHNnYVNBOElHeGxianNnYVNzcktYdGNiaUFnSUNCcFppaG1iaWhzYVhOMFcybGRLU2tnY21WMGRYSnVJSFJ5ZFdWY2JpQWdmVnh1ZlZ4dVhHNWZMblpoY2s1aGJXVWdQU0FuWkNjN1hHNWZMbk5sZEU1aGJXVWdQU0FuY0Y4bk8xeHVYeTVqZEhoT1lXMWxJRDBnSjJNbk8xeHVYeTVsZUhST1lXMWxJRDBnSjJVbk8xeHVYRzVmTG5KWGIzSmtJRDBnTDE1YlhGd2tYRngzWFNza0x6dGNibDh1Y2xOcGJYQnNaVUZqWTJWemMyOXlJRDBnTDE1YlhGd2tYRngzWFNzb1hGd3VXMXhjSkZ4Y2QxMHJLU29rTHp0Y2JseHVYeTV1WlhoMFZHbGpheUE5SUhSNWNHVnZaaUJ6WlhSSmJXMWxaR2xoZEdVZ1BUMDlJQ2RtZFc1amRHbHZiaWMvSUZ4dUlDQnpaWFJKYlcxbFpHbGhkR1V1WW1sdVpDaDNhVzRwSURvZ1hHNGdJR1oxYm1OMGFXOXVLR05oYkd4aVlXTnJLU0I3WEc0Z0lDQWdjMlYwVkdsdFpXOTFkQ2hqWVd4c1ltRmpheXdnTUNrZ1hHNGdJSDFjYmx4dVhHNWNibDh1Y0hKbFptbDRJRDBnWENJbmRYTmxJSE4wY21samRDYzdkbUZ5SUZ3aUlDc2dYeTUyWVhKT1lXMWxJQ3NnWENJOVhDSWdLeUJmTG1OMGVFNWhiV1VnS3lCY0lpNWtZWFJoTzF3aUlDc2dJRjh1WlhoMFRtRnRaU0FnS3lCY0lqMWNJaUFySUY4dVpYaDBUbUZ0WlNBcklGd2lmSHduSnp0Y0lqdGNibHh1WEc1ZkxuTnNhV05sSUQwZ1puVnVZM1JwYjI0b2IySnFMQ0J6ZEdGeWRDd2daVzVrS1h0Y2JpQWdkbUZ5SUhKbGN5QTlJRnRkTzF4dUlDQm1iM0lvZG1GeUlHa2dQU0J6ZEdGeWRDQjhmQ0F3TENCc1pXNGdQU0JsYm1RZ2ZId2diMkpxTG14bGJtZDBhRHNnYVNBOElHeGxianNnYVNzcktYdGNiaUFnSUNCeVpYTXVjSFZ6YUNodlltcGJhVjBwWEc0Z0lIMWNiaUFnY21WMGRYSnVJSEpsY3p0Y2JuMWNibHh1THk4Z1ltVmhZM1Z6WlNCemJHbGpaU0JoYm1RZ2RHOU1iM2RsY2tOaGMyVWdhWE1nWlhod1pXNXphWFpsTGlCM1pTQm9ZVzVrYkdVZ2RXNWtaV1pwYm1Wa0lHRnVaQ0J1ZFd4c0lHbHVJR0Z1YjNSb1pYSWdkMkY1WEc1ZkxuUjVjR1ZQWmlBOUlHWjFibU4wYVc5dUlDaHZLU0I3WEc0Z0lISmxkSFZ5YmlCdklEMDlJRzUxYkd3Z1B5QlRkSEpwYm1jb2J5a2dPbTh5YzNSeUxtTmhiR3dvYnlrdWMyeHBZMlVvT0N3Z0xURXBMblJ2VEc5M1pYSkRZWE5sS0NrN1hHNTlYRzVjYmx4dVhHNWNibDh1YldGclpWQnlaV1JwWTJGMFpTQTlJR1oxYm1OMGFXOXVJRzFoYTJWUWNtVmthV05oZEdVb2QyOXlaSE1zSUhCeVpXWnBlQ2tnZTF4dUlDQWdJR2xtSUNoMGVYQmxiMllnZDI5eVpITWdQVDA5SUZ3aWMzUnlhVzVuWENJcElIdGNiaUFnSUNBZ0lDQWdkMjl5WkhNZ1BTQjNiM0prY3k1emNHeHBkQ2hjSWlCY0lpazdYRzRnSUNBZ2ZWeHVJQ0FnSUhaaGNpQm1JRDBnWENKY0lpeGNiaUFnSUNCallYUnpJRDBnVzEwN1hHNGdJQ0FnYjNWME9pQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJSGR2Y21SekxteGxibWQwYURzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdvZ1BTQXdPeUJxSUR3Z1kyRjBjeTVzWlc1bmRHZzdJQ3NyYWlsN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0dOaGRITmJhbDFiTUYwdWJHVnVaM1JvSUQwOVBTQjNiM0prYzF0cFhTNXNaVzVuZEdncElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kyRjBjMXRxWFM1d2RYTm9LSGR2Y21SelcybGRLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVWdiM1YwTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JqWVhSekxuQjFjMmdvVzNkdmNtUnpXMmxkWFNrN1hHNGdJQ0FnZlZ4dUlDQWdJR1oxYm1OMGFXOXVJR052YlhCaGNtVlVieWhoY25JcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0dGeWNpNXNaVzVuZEdnZ1BUMDlJREVwSUhKbGRIVnliaUJtSUNzOUlGd2ljbVYwZFhKdUlITjBjaUE5UFQwZ0oxd2lJQ3NnWVhKeVd6QmRJQ3NnWENJbk8xd2lPMXh1SUNBZ0lDQWdJQ0JtSUNzOUlGd2ljM2RwZEdOb0tITjBjaWw3WENJN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dZWEp5TG14bGJtZDBhRHNnS3l0cEtYdGNiaUFnSUNBZ0lDQWdJQ0FnWmlBclBTQmNJbU5oYzJVZ0oxd2lJQ3NnWVhKeVcybGRJQ3NnWENJbk9sd2lPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUdZZ0t6MGdYQ0p5WlhSMWNtNGdkSEoxWlgxeVpYUjFjbTRnWm1Gc2MyVTdYQ0k3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnVjJobGJpQjBhR1Z5WlNCaGNtVWdiVzl5WlNCMGFHRnVJSFJvY21WbElHeGxibWQwYUNCallYUmxaMjl5YVdWekxDQmhiaUJ2ZFhSbGNseHVJQ0FnSUM4dklITjNhWFJqYUNCbWFYSnpkQ0JrYVhOd1lYUmphR1Z6SUc5dUlIUm9aU0JzWlc1bmRHaHpMQ0IwYnlCellYWmxJRzl1SUdOdmJYQmhjbWx6YjI1ekxseHVJQ0FnSUdsbUlDaGpZWFJ6TG14bGJtZDBhQ0ErSURNcElIdGNiaUFnSUNBZ0lDQWdZMkYwY3k1emIzSjBLR1oxYm1OMGFXOXVLR0VzSUdJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJpTG14bGJtZDBhQ0F0SUdFdWJHVnVaM1JvTzF4dUlDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdaaUFyUFNCY0luTjNhWFJqYUNoemRISXViR1Z1WjNSb0tYdGNJanRjYmlBZ0lDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCallYUnpMbXhsYm1kMGFEc2dLeXRwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IyWVhJZ1kyRjBJRDBnWTJGMGMxdHBYVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHWWdLejBnWENKallYTmxJRndpSUNzZ1kyRjBXekJkTG14bGJtZDBhQ0FySUZ3aU9sd2lPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXRjR0Z5WlZSdktHTmhkQ2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ1ppQXJQU0JjSW4xY0lqdGNibHh1SUNBZ0lDQWdJQ0F2THlCUGRHaGxjbmRwYzJVc0lITnBiWEJzZVNCblpXNWxjbUYwWlNCaElHWnNZWFFnWUhOM2FYUmphR0FnYzNSaGRHVnRaVzUwTGx4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJR052YlhCaGNtVlVieWgzYjNKa2N5azdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1JuVnVZM1JwYjI0b1hDSnpkSEpjSWl3Z1ppazdYRzU5WEc1Y2JseHVYeTUwY21GamEwVnljbTl5VUc5eklEMGdLR1oxYm1OMGFXOXVJQ2dwZTF4dUlDQXZMeUJzYVc1bFluSmxZV3RjYmlBZ2RtRnlJR3hpSUQwZ0wxeGNjbHhjYm54YlhGeHVYRnh5WEZ4MU1qQXlPRnhjZFRJd01qbGRMMmM3WEc0Z0lIWmhjaUJ0YVc1U1lXNW5aU0E5SURJd0xDQnRZWGhTWVc1blpTQTlJREl3TzF4dUlDQm1kVzVqZEdsdmJpQm1hVzVrVEdsdVpTaHNhVzVsY3l3Z2NHOXpLWHRjYmlBZ0lDQjJZWElnZEcxd1RHVnVJRDBnTUR0Y2JpQWdJQ0JtYjNJb2RtRnlJR2tnUFNBd0xHeGxiaUE5SUd4cGJtVnpMbXhsYm1kMGFEc2dhU0E4SUd4bGJqc2dhU3NyS1h0Y2JpQWdJQ0FnSUhaaGNpQnNhVzVsVEdWdUlEMGdLR3hwYm1WelcybGRJSHg4SUZ3aVhDSXBMbXhsYm1kMGFEdGNibHh1SUNBZ0lDQWdhV1lvZEcxd1RHVnVJQ3NnYkdsdVpVeGxiaUErSUhCdmN5a2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdlMjUxYlRvZ2FTd2diR2x1WlRvZ2JHbHVaWE5iYVYwc0lITjBZWEowT2lCd2IzTWdMU0JwSUMwZ2RHMXdUR1Z1SUN3Z2NISmxkanBzYVc1bGMxdHBMVEZkTENCdVpYaDBPaUJzYVc1bGMxdHBLekZkSUgwN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNBdkx5QXhJR2x6SUdadmNpQjBhR1VnYkdsdVpXSnlaV0ZyWEc0Z0lDQWdJQ0IwYlhCTVpXNGdQU0IwYlhCTVpXNGdLeUJzYVc1bFRHVnVJRHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdablZ1WTNScGIyNGdabTl5YldGMFRHbHVaU2h6ZEhJc0lDQnpkR0Z5ZEN3Z2JuVnRMQ0IwWVhKblpYUXBlMXh1SUNBZ0lIWmhjaUJzWlc0Z1BTQnpkSEl1YkdWdVozUm9PMXh1SUNBZ0lIWmhjaUJ0YVc0Z1BTQnpkR0Z5ZENBdElHMXBibEpoYm1kbE8xeHVJQ0FnSUdsbUtHMXBiaUE4SURBcElHMXBiaUE5SURBN1hHNGdJQ0FnZG1GeUlHMWhlQ0E5SUhOMFlYSjBJQ3NnYldGNFVtRnVaMlU3WEc0Z0lDQWdhV1lvYldGNElENGdiR1Z1S1NCdFlYZ2dQU0JzWlc0N1hHNWNiaUFnSUNCMllYSWdjbVZ0WVdsdUlEMGdjM1J5TG5Oc2FXTmxLRzFwYml3Z2JXRjRLVHRjYmlBZ0lDQjJZWElnY0hKbFptbDRJRDBnWENKYlhDSWdLeWh1ZFcwck1Ta2dLeUJjSWwwZ1hDSWdLeUFvYldsdUlENGdNRDhnWENJdUxsd2lJRG9nWENKY0lpbGNiaUFnSUNCMllYSWdjRzl6ZEdacGVDQTlJRzFoZUNBOElHeGxiaUEvSUZ3aUxpNWNJam9nWENKY0lqdGNiaUFnSUNCMllYSWdjbVZ6SUQwZ2NISmxabWw0SUNzZ2NtVnRZV2x1SUNzZ2NHOXpkR1pwZUR0Y2JpQWdJQ0JwWmloMFlYSm5aWFFwSUhKbGN5QXJQU0JjSWx4Y2Jsd2lJQ3NnYm1WM0lFRnljbUY1S0hOMFlYSjBMVzFwYmlBcklIQnlaV1pwZUM1c1pXNW5kR2dnS3lBeEtTNXFiMmx1S0Z3aUlGd2lLU0FySUZ3aVhsNWVYQ0k3WEc0Z0lDQWdjbVYwZFhKdUlISmxjenRjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdablZ1WTNScGIyNG9hVzV3ZFhRc0lIQnZjeWw3WEc0Z0lDQWdhV1lvY0c5eklENGdhVzV3ZFhRdWJHVnVaM1JvTFRFcElIQnZjeUE5SUdsdWNIVjBMbXhsYm1kMGFDMHhPMXh1SUNBZ0lHeGlMbXhoYzNSSmJtUmxlQ0E5SURBN1hHNGdJQ0FnZG1GeUlHeHBibVZ6SUQwZ2FXNXdkWFF1YzNCc2FYUW9iR0lwTzF4dUlDQWdJSFpoY2lCc2FXNWxJRDBnWm1sdVpFeHBibVVvYkdsdVpYTXNjRzl6S1R0Y2JpQWdJQ0IyWVhJZ2MzUmhjblFnUFNCc2FXNWxMbk4wWVhKMExDQnVkVzBnUFNCc2FXNWxMbTUxYlR0Y2JseHVJQ0FnSUhKbGRIVnliaUFvYkdsdVpTNXdjbVYyUHlCbWIzSnRZWFJNYVc1bEtHeHBibVV1Y0hKbGRpd2djM1JoY25Rc0lHNTFiUzB4SUNrZ0t5QW5YRnh1SnpvZ0p5Y2dLU0FySUZ4dUlDQWdJQ0FnWm05eWJXRjBUR2x1WlNoc2FXNWxMbXhwYm1Vc0lITjBZWEowTENCdWRXMHNJSFJ5ZFdVcElDc2dKMXhjYmljZ0t5QmNiaUFnSUNBZ0lDaHNhVzVsTG01bGVIUS9JR1p2Y20xaGRFeHBibVVvYkdsdVpTNXVaWGgwTENCemRHRnlkQ3dnYm5WdEt6RWdLU0FySUNkY1hHNG5PaUFuSnlBcE8xeHVYRzRnSUgxY2JuMHBLQ2s3WEc1Y2JseHVkbUZ5SUdsbmJtOXlaV1JTWldZZ1BTQXZYRndvS0Z4Y1AxeGNJWHhjWEQ5Y1hEcDhYRncvWEZ3OUtTOW5PMXh1WHk1bWFXNWtVM1ZpUTJGd2RIVnlaU0E5SUdaMWJtTjBhVzl1SUNoeVpXZFRkSElwSUh0Y2JpQWdkbUZ5SUd4bFpuUWdQU0F3TEZ4dUlDQWdJSEpwWjJoMElEMGdNQ3hjYmlBZ0lDQnNaVzRnUFNCeVpXZFRkSEl1YkdWdVozUm9MRnh1SUNBZ0lHbG5ibTl5WldRZ1BTQnlaV2RUZEhJdWJXRjBZMmdvYVdkdWIzSmxaRkpsWmlrN0lDOHZJR2xuYm05eVpXUWdkVzVqWVhCMGRYSmxYRzRnSUdsbUtHbG5ibTl5WldRcElHbG5ibTl5WldRZ1BTQnBaMjV2Y21Wa0xteGxibWQwYUZ4dUlDQmxiSE5sSUdsbmJtOXlaV1FnUFNBd08xeHVJQ0JtYjNJZ0tEc2diR1Z1TFMwN0tTQjdYRzRnSUNBZ2RtRnlJR3hsZEhSbGNpQTlJSEpsWjFOMGNpNWphR0Z5UVhRb2JHVnVLVHRjYmlBZ0lDQnBaaUFvYkdWdUlEMDlQU0F3SUh4OElISmxaMU4wY2k1amFHRnlRWFFvYkdWdUlDMGdNU2tnSVQwOUlGd2lYRnhjWEZ3aUlDa2dleUJjYmlBZ0lDQWdJR2xtSUNoc1pYUjBaWElnUFQwOUlGd2lLRndpS1NCc1pXWjBLeXM3WEc0Z0lDQWdJQ0JwWmlBb2JHVjBkR1Z5SUQwOVBTQmNJaWxjSWlrZ2NtbG5hSFFyS3p0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnYVdZZ0tHeGxablFnSVQwOUlISnBaMmgwS1NCMGFISnZkeUJjSWxKbFowVjRjRG9nWENJcklISmxaMU4wY2lBcklGd2lKM01nWW5KaFkydGxkQ0JwY3lCdWIzUWdiV0Z5WTJobFpGd2lPMXh1SUNCbGJITmxJSEpsZEhWeWJpQnNaV1owSUMwZ2FXZHViM0psWkR0Y2JuMDdYRzVjYmx4dVh5NWxjMk5oY0dWU1pXZEZlSEFnUFNCbWRXNWpkR2x2YmlnZ2MzUnlLWHN2THlCRGNtVmthWFE2SUZoU1pXZEZlSEFnTUM0MkxqRWdLR01wSURJd01EY3RNakF3T0NCVGRHVjJaVzRnVEdWMmFYUm9ZVzRnUEdoMGRIQTZMeTl6ZEdWMlpXNXNaWFpwZEdoaGJpNWpiMjB2Y21WblpYZ3ZlSEpsWjJWNGNDOCtJRTFKVkNCTWFXTmxibk5sWEc0Z0lISmxkSFZ5YmlCemRISXVjbVZ3YkdGalpTZ3ZXeTFiWEZ4ZGUzMG9LU29yUHk1Y1hGeGNYaVI4TENOY1hITmRMMmNzSUdaMWJtTjBhVzl1S0cxaGRHTm9LWHRjYmlBZ0lDQnlaWFIxY200Z0oxeGNYRnduSUNzZ2JXRjBZMmc3WEc0Z0lIMHBPMXh1ZlR0Y2JseHVYRzUyWVhJZ2NrVnVkR2wwZVNBOUlHNWxkeUJTWldkRmVIQW9YQ0ltS0Q4NktDTjRXekF0T1dFdFprRXRSbDByS1h3b0kxc3dMVGxkS3lsOEtGd2lJQ3NnWHk1clpYbHpLR1Z1ZEdsMGFXVnpLUzVxYjJsdUtDZDhKeWtnS3lBbktTazdKeXdnSjJkcEp5azdYRzVjYmw4dVkyOXVkbVZ5ZEVWdWRHbDBlU0E5SUdaMWJtTjBhVzl1S0dOb2NpbDdYRzVjYmlBZ2NtVjBkWEp1SUNoY0lsd2lJQ3NnWTJoeUtTNXlaWEJzWVdObEtISkZiblJwZEhrc0lHWjFibU4wYVc5dUtHRnNiQ3dnYUdWNExDQmtaV01zSUdOaGNIUjFjbVVwZTF4dUlDQWdJSFpoY2lCamFHRnlRMjlrWlR0Y2JpQWdJQ0JwWmlnZ1pHVmpJQ2tnWTJoaGNrTnZaR1VnUFNCd1lYSnpaVWx1ZENnZ1pHVmpMbk5zYVdObEtERXBMQ0F4TUNBcE8xeHVJQ0FnSUdWc2MyVWdhV1lvSUdobGVDQXBJR05vWVhKRGIyUmxJRDBnY0dGeWMyVkpiblFvSUdobGVDNXpiR2xqWlNneUtTd2dNVFlnS1R0Y2JpQWdJQ0JsYkhObElHTm9ZWEpEYjJSbElEMGdaVzUwYVhScFpYTmJZMkZ3ZEhWeVpWMWNibHh1SUNBZ0lISmxkSFZ5YmlCVGRISnBibWN1Wm5KdmJVTm9ZWEpEYjJSbEtDQmphR0Z5UTI5a1pTQXBYRzRnSUgwcE8xeHVYRzU5WEc1Y2JseHVMeThnYzJsdGNHeGxJR2RsZENCaFkyTmxjM052Y2x4dVhHNWZMbU55WldGMFpVOWlhbVZqZENBOUlFOWlhbVZqZEM1amNtVmhkR1UvSUdaMWJtTjBhVzl1S0c4cGUxeHVJQ0J5WlhSMWNtNGdUMkpxWldOMExtTnlaV0YwWlNodklIeDhJRzUxYkd3cFhHNTlPaUFvWm5WdVkzUnBiMjRvS1h0Y2JpQWdJQ0JtZFc1amRHbHZiaUJVWlcxd0tDa2dlMzFjYmlBZ0lDQnlaWFIxY200Z1puVnVZM1JwYjI0b2J5bDdYRzRnSUNBZ0lDQnBaaWdoYnlrZ2NtVjBkWEp1SUh0OVhHNGdJQ0FnSUNCVVpXMXdMbkJ5YjNSdmRIbHdaU0E5SUc4N1hHNGdJQ0FnSUNCMllYSWdiMkpxSUQwZ2JtVjNJRlJsYlhBb0tUdGNiaUFnSUNBZ0lGUmxiWEF1Y0hKdmRHOTBlWEJsSUQwZ2JuVnNiRHNnTHk4ZzVMaU42S2FCNUwrZDVveUI1TGlBNUxpcUlFOGc1NXFFNXAyQzVwV2o1YnlWNTVTbzc3eUlZU0J6ZEhKaGVTQnlaV1psY21WdVkyWHZ2SWt1TGk1Y2JpQWdJQ0FnSUhKbGRIVnliaUJ2WW1wY2JpQWdJQ0I5WEc1OUtTZ3BPMXh1WEc1ZkxtTnlaV0YwWlZCeWIzUnZJRDBnWm5WdVkzUnBiMjRvWm00c0lHOHBlMXh1SUNBZ0lHWjFibU4wYVc5dUlFWnZieWdwSUhzZ2RHaHBjeTVqYjI1emRISjFZM1J2Y2lBOUlHWnVPMzFjYmlBZ0lDQkdiMjh1Y0hKdmRHOTBlWEJsSUQwZ2J6dGNiaUFnSUNCeVpYUjFjbTRnS0dadUxuQnliM1J2ZEhsd1pTQTlJRzVsZHlCR2IyOG9LU2s3WEc1OVhHNWNibHh1WHk1eVpXMXZkbVZQYm1VZ1BTQm1kVzVqZEdsdmJpaHNhWE4wSUN3Z1ptbHNkR1Z5S1h0Y2JpQWdkbUZ5SUd4bGJpQTlJR3hwYzNRdWJHVnVaM1JvTzF4dUlDQm1iM0lvTzJ4bGJpMHRPeWw3WEc0Z0lDQWdhV1lvWm1sc2RHVnlLR3hwYzNSYmJHVnVYU2twSUh0Y2JpQWdJQ0FnSUd4cGMzUXVjM0JzYVdObEtHeGxiaXdnTVNsY2JpQWdJQ0FnSUhKbGRIVnlianRjYmlBZ0lDQjlYRzRnSUgxY2JuMWNibHh1WEc0dktpcGNibU5zYjI1bFhHNHFMMXh1WHk1amJHOXVaU0E5SUdaMWJtTjBhVzl1SUdOc2IyNWxLRzlpYWlsN1hHNGdJR2xtS0NGdlltb2dmSHdnS0hSNWNHVnZaaUJ2WW1vZ0lUMDlJQ2R2WW1wbFkzUW5JQ2twSUhKbGRIVnliaUJ2WW1vN1hHNGdJR2xtS0VGeWNtRjVMbWx6UVhKeVlYa29iMkpxS1NsN1hHNGdJQ0FnZG1GeUlHTnNiMjVsWkNBOUlGdGRPMXh1SUNBZ0lHWnZjaWgyWVhJZ2FUMHdMR3hsYmlBOUlHOWlhaTVzWlc1bmRHZzdJR2s4SUd4bGJqdHBLeXNwZTF4dUlDQWdJQ0FnWTJ4dmJtVmtXMmxkSUQwZ2IySnFXMmxkWEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCamJHOXVaV1E3WEc0Z0lIMWxiSE5sZTF4dUlDQWdJSFpoY2lCamJHOXVaV1FnUFNCN2ZUdGNiaUFnSUNCbWIzSW9kbUZ5SUdrZ2FXNGdiMkpxS1NCcFppaHZZbW91YUdGelQzZHVVSEp2Y0dWeWRIa29hU2twZTF4dUlDQWdJQ0FnWTJ4dmJtVmtXMmxkSUQwZ2IySnFXMmxkTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z1kyeHZibVZrTzF4dUlDQjlYRzU5WEc1Y2JsOHVaWEYxWVd4eklEMGdablZ1WTNScGIyNG9ibTkzTENCdmJHUXBlMXh1SUNCMllYSWdkSGx3WlNBOUlIUjVjR1Z2WmlCdWIzYzdYRzRnSUdsbUtIUjVjR1VnUFQwOUlDZHVkVzFpWlhJbklDWW1JSFI1Y0dWdlppQnZiR1FnUFQwOUlDZHVkVzFpWlhJbkppWWdhWE5PWVU0b2JtOTNLU0FtSmlCcGMwNWhUaWh2YkdRcEtTQnlaWFIxY200Z2RISjFaVnh1SUNCeVpYUjFjbTRnYm05M0lEMDlQU0J2YkdRN1hHNTlYRzVjYm5aaGNpQmtZWE5vSUQwZ0x5MG9XMkV0ZWwwcEwyYzdYRzVmTG1OaGJXVnNRMkZ6WlNBOUlHWjFibU4wYVc5dUtITjBjaWw3WEc0Z0lISmxkSFZ5YmlCemRISXVjbVZ3YkdGalpTaGtZWE5vTENCbWRXNWpkR2x2YmloaGJHd3NJR05oY0hSMWNtVXBlMXh1SUNBZ0lISmxkSFZ5YmlCallYQjBkWEpsTG5SdlZYQndaWEpEWVhObEtDazdYRzRnSUgwcFhHNTlYRzVjYmx4dVhHNWZMblJvY205MGRHeGxJRDBnWm5WdVkzUnBiMjRnZEdoeWIzUjBiR1VvWm5WdVl5d2dkMkZwZENsN1hHNGdJSFpoY2lCM1lXbDBJRDBnZDJGcGRDQjhmQ0F4TURBN1hHNGdJSFpoY2lCamIyNTBaWGgwTENCaGNtZHpMQ0J5WlhOMWJIUTdYRzRnSUhaaGNpQjBhVzFsYjNWMElEMGdiblZzYkR0Y2JpQWdkbUZ5SUhCeVpYWnBiM1Z6SUQwZ01EdGNiaUFnZG1GeUlHeGhkR1Z5SUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ2NISmxkbWx2ZFhNZ1BTQXJibVYzSUVSaGRHVTdYRzRnSUNBZ2RHbHRaVzkxZENBOUlHNTFiR3c3WEc0Z0lDQWdjbVZ6ZFd4MElEMGdablZ1WXk1aGNIQnNlU2hqYjI1MFpYaDBMQ0JoY21kektUdGNiaUFnSUNCamIyNTBaWGgwSUQwZ1lYSm5jeUE5SUc1MWJHdzdYRzRnSUgwN1hHNGdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQjJZWElnYm05M0lEMGdLeUJ1WlhjZ1JHRjBaVHRjYmlBZ0lDQjJZWElnY21WdFlXbHVhVzVuSUQwZ2QyRnBkQ0F0SUNodWIzY2dMU0J3Y21WMmFXOTFjeWs3WEc0Z0lDQWdZMjl1ZEdWNGRDQTlJSFJvYVhNN1hHNGdJQ0FnWVhKbmN5QTlJR0Z5WjNWdFpXNTBjenRjYmlBZ0lDQnBaaUFvY21WdFlXbHVhVzVuSUR3OUlEQWdmSHdnY21WdFlXbHVhVzVuSUQ0Z2QyRnBkQ2tnZTF4dUlDQWdJQ0FnWTJ4bFlYSlVhVzFsYjNWMEtIUnBiV1Z2ZFhRcE8xeHVJQ0FnSUNBZ2RHbHRaVzkxZENBOUlHNTFiR3c3WEc0Z0lDQWdJQ0J3Y21WMmFXOTFjeUE5SUc1dmR6dGNiaUFnSUNBZ0lISmxjM1ZzZENBOUlHWjFibU11WVhCd2JIa29ZMjl1ZEdWNGRDd2dZWEpuY3lrN1hHNGdJQ0FnSUNCamIyNTBaWGgwSUQwZ1lYSm5jeUE5SUc1MWJHdzdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDZ2hkR2x0Wlc5MWRDa2dlMXh1SUNBZ0lDQWdkR2x0Wlc5MWRDQTlJSE5sZEZScGJXVnZkWFFvYkdGMFpYSXNJSEpsYldGcGJtbHVaeWs3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCeVpYTjFiSFE3WEc0Z0lIMDdYRzU5TzF4dVhHNHZMeUJvYjJkaGJpQmxjMk5oY0dWY2JpOHZJRDA5UFQwOVBUMDlQVDA5UFQwOVhHNWZMbVZ6WTJGd1pTQTlJQ2htZFc1amRHbHZiaWdwZTF4dUlDQjJZWElnY2tGdGNDQTlJQzhtTDJjc1hHNGdJQ0FnSUNCeVRIUWdQU0F2UEM5bkxGeHVJQ0FnSUNBZ2NrZDBJRDBnTHo0dlp5eGNiaUFnSUNBZ0lISkJjRzl6SUQwZ0wxeGNKeTluTEZ4dUlDQWdJQ0FnY2xGMWIzUWdQU0F2WEZ4Y0lpOW5MRnh1SUNBZ0lDQWdhRU5vWVhKeklEMGdMMXNtUEQ1Y1hGd2lYRnduWFM4N1hHNWNiaUFnY21WMGRYSnVJR1oxYm1OMGFXOXVLSE4wY2lrZ2UxeHVJQ0FnSUhKbGRIVnliaUJvUTJoaGNuTXVkR1Z6ZENoemRISXBJRDljYmlBZ0lDQWdJSE4wY2x4dUlDQWdJQ0FnSUNBdWNtVndiR0ZqWlNoeVFXMXdMQ0FuSm1GdGNEc25LVnh1SUNBZ0lDQWdJQ0F1Y21Wd2JHRmpaU2h5VEhRc0lDY21iSFE3SnlsY2JpQWdJQ0FnSUNBZ0xuSmxjR3hoWTJVb2NrZDBMQ0FuSm1kME95Y3BYRzRnSUNBZ0lDQWdJQzV5WlhCc1lXTmxLSEpCY0c5ekxDQW5KaU16T1RzbktWeHVJQ0FnSUNBZ0lDQXVjbVZ3YkdGalpTaHlVWFZ2ZEN3Z0p5WnhkVzkwT3ljcElEcGNiaUFnSUNBZ0lITjBjanRjYmlBZ2ZWeHVmU2tvS1R0Y2JseHVYeTVqWVdOb1pTQTlJR1oxYm1OMGFXOXVLRzFoZUNsN1hHNGdJRzFoZUNBOUlHMWhlQ0I4ZkNBeE1EQXdPMXh1SUNCMllYSWdhMlY1Y3lBOUlGdGRMRnh1SUNBZ0lDQWdZMkZqYUdVZ1BTQjdmVHRjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0J6WlhRNklHWjFibU4wYVc5dUtHdGxlU3dnZG1Gc2RXVXBJSHRjYmlBZ0lDQWdJR2xtSUNoclpYbHpMbXhsYm1kMGFDQStJSFJvYVhNdWJXRjRLU0I3WEc0Z0lDQWdJQ0FnSUdOaFkyaGxXMnRsZVhNdWMyaHBablFvS1YwZ1BTQjFibVJsWm1sdVpXUTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQXZMeUJjYmlBZ0lDQWdJR2xtS0dOaFkyaGxXMnRsZVYwZ1BUMDlJSFZ1WkdWbWFXNWxaQ2w3WEc0Z0lDQWdJQ0FnSUd0bGVYTXVjSFZ6YUNoclpYa3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdZMkZqYUdWYmEyVjVYU0E5SUhaaGJIVmxPMXh1SUNBZ0lDQWdjbVYwZFhKdUlIWmhiSFZsTzF4dUlDQWdJSDBzWEc0Z0lDQWdaMlYwT2lCbWRXNWpkR2x2YmloclpYa3BJSHRjYmlBZ0lDQWdJR2xtSUNoclpYa2dQVDA5SUhWdVpHVm1hVzVsWkNrZ2NtVjBkWEp1SUdOaFkyaGxPMXh1SUNBZ0lDQWdjbVYwZFhKdUlHTmhZMmhsVzJ0bGVWMDdYRzRnSUNBZ2ZTeGNiaUFnSUNCdFlYZzZJRzFoZUN4Y2JpQWdJQ0JzWlc0NlpuVnVZM1JwYjI0b0tYdGNiaUFnSUNBZ0lISmxkSFZ5YmlCclpYbHpMbXhsYm1kMGFEdGNiaUFnSUNCOVhHNGdJSDA3WEc1OVhHNWNiaTh2SUM4dklITmxkSFZ3SUhSb1pTQnlZWGNnUlhod2NtVnpjMmx2Ymx4dVhHNWNiaTh2SUdoaGJtUnNaU0IwYUdVZ2MyRnRaU0JzYjJkcFl5QnZiaUJqYjIxd2IyNWxiblFuY3lCZ2IyNHRLbUFnWVc1a0lHVnNaVzFsYm5RbmN5QmdiMjR0S21CY2JpOHZJSEpsZEhWeWJpQjBhR1VnWm1seVpTQnZZbXBsWTNSY2JsOHVhR0Z1Wkd4bFJYWmxiblFnUFNCbWRXNWpkR2x2YmloMllXeDFaU3dnZEhsd1pTQXBlMXh1SUNCMllYSWdjMlZzWmlBOUlIUm9hWE1zSUdWMllXeDFZWFJsTzF4dUlDQnBaaWgyWVd4MVpTNTBlWEJsSUQwOVBTQW5aWGh3Y21WemMybHZiaWNwZXlBdkx5QnBaaUJwY3lCbGVIQnlaWE56YVc5dUxDQm5ieUJsZG1Gc2RXRjBaV1FnZDJGNVhHNGdJQ0FnWlhaaGJIVmhkR1VnUFNCMllXeDFaUzVuWlhRN1hHNGdJSDFjYmlBZ2FXWW9aWFpoYkhWaGRHVXBlMXh1SUNBZ0lISmxkSFZ5YmlCbWRXNWpkR2x2YmlCbWFYSmxLRzlpYWlsN1hHNGdJQ0FnSUNCelpXeG1MaVIxY0dSaGRHVW9ablZ1WTNScGIyNG9LWHRjYmlBZ0lDQWdJQ0FnZG1GeUlHUmhkR0VnUFNCMGFHbHpMbVJoZEdFN1hHNGdJQ0FnSUNBZ0lHUmhkR0V1SkdWMlpXNTBJRDBnYjJKcU8xeHVJQ0FnSUNBZ0lDQjJZWElnY21WeklEMGdaWFpoYkhWaGRHVW9jMlZzWmlrN1hHNGdJQ0FnSUNBZ0lHbG1LSEpsY3lBOVBUMGdabUZzYzJVZ0ppWWdiMkpxSUNZbUlHOWlhaTV3Y21WMlpXNTBSR1ZtWVhWc2RDa2diMkpxTG5CeVpYWmxiblJFWldaaGRXeDBLQ2s3WEc0Z0lDQWdJQ0FnSUdSaGRHRXVKR1YyWlc1MElEMGdkVzVrWldacGJtVmtPMXh1SUNBZ0lDQWdmU2xjYmx4dUlDQWdJSDFjYmlBZ2ZXVnNjMlY3WEc0Z0lDQWdjbVYwZFhKdUlHWjFibU4wYVc5dUlHWnBjbVVvS1h0Y2JpQWdJQ0FnSUhaaGNpQmhjbWR6SUQwZ1h5NXpiR2xqWlNoaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUNBZ1lYSm5jeTUxYm5Ob2FXWjBLSFpoYkhWbEtUdGNiaUFnSUNBZ0lITmxiR1l1SkhWd1pHRjBaU2htZFc1amRHbHZiaWdwZTF4dUlDQWdJQ0FnSUNCelpXeG1MaVJsYldsMExtRndjR3g1S0hObGJHWXNJR0Z5WjNNcE8xeHVJQ0FnSUNBZ2ZTbGNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVMeThnYjI1c2VTQmpZV3hzSUc5dVkyVmNibDh1YjI1alpTQTlJR1oxYm1OMGFXOXVLR1p1S1h0Y2JpQWdkbUZ5SUhScGJXVWdQU0F3TzF4dUlDQnlaWFIxY200Z1puVnVZM1JwYjI0b0tYdGNiaUFnSUNCcFppZ2dkR2x0WlNzcklEMDlQU0F3S1NCbWJpNWhjSEJzZVNoMGFHbHpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQjlYRzU5WEc1Y2JsOHVabWw0VDJKcVUzUnlJRDBnWm5WdVkzUnBiMjRvYzNSeUtYdGNiaUFnYVdZb2MzUnlMblJ5YVcwb0tTNXBibVJsZUU5bUtDZDdKeWtnSVQwOUlEQXBlMXh1SUNBZ0lISmxkSFZ5YmlBbmV5Y2dLeUJ6ZEhJZ0t5QW5mU2M3WEc0Z0lIMWNiaUFnY21WMGRYSnVJSE4wY2p0Y2JuMWNibHh1WEc1ZkxtMWhjRDBnWm5WdVkzUnBiMjRvWVhKeVlYa3NJR05oYkd4aVlXTnJLWHRjYmlBZ2RtRnlJSEpsY3lBOUlGdGRPMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkdWdUlEMGdZWEp5WVhrdWJHVnVaM1JvT3lCcElEd2diR1Z1T3lCcEt5c3BJSHRjYmlBZ0lDQnlaWE11Y0hWemFDaGpZV3hzWW1GamF5aGhjbkpoZVZ0cFhTd2dhU2twTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhNN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUd4dlp5aHRjMmNzSUhSNWNHVXBlMXh1SUNCcFppaDBlWEJsYjJZZ1kyOXVjMjlzWlNBaFBUMGdYQ0oxYm1SbFptbHVaV1JjSWlrZ0lHTnZibk52YkdWYmRIbHdaU0I4ZkNCY0lteHZaMXdpWFNodGMyY3BPMXh1ZlZ4dVhHNWZMbXh2WnlBOUlHeHZaenRjYmx4dVhHNWZMbTV2Y20xTWFYTjBaVzVsY2lBOUlHWjFibU4wYVc5dUtDQmxkbVZ1ZEhNZ0lDbDdYRzRnSUNBZ2RtRnlJR1YyWlc1MFRHbHpkR1Z1WlhKeklEMGdXMTA3WEc0Z0lDQWdkbUZ5SUhCVWVYQmxJRDBnWHk1MGVYQmxUMllvSUdWMlpXNTBjeUFwTzF4dUlDQWdJR2xtS0NCd1ZIbHdaU0E5UFQwZ0oyRnljbUY1SnlBcGUxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdWMlpXNTBjenRjYmlBZ0lDQjlaV3h6WlNCcFppQW9JSEJVZVhCbElEMDlQU0FuYjJKcVpXTjBKeUFwZTF4dUlDQWdJQ0FnWm05eUtDQjJZWElnYVNCcGJpQmxkbVZ1ZEhNZ0tTQnBaaUFvSUdWMlpXNTBjeTVvWVhOUGQyNVFjbTl3WlhKMGVTaHBLU0FwZTF4dUlDQWdJQ0FnSUNCbGRtVnVkRXhwYzNSbGJtVnljeTV3ZFhOb0tIdGNiaUFnSUNBZ0lDQWdJQ0IwZVhCbE9pQnBMRnh1SUNBZ0lDQWdJQ0FnSUd4cGMzUmxibVZ5T2lCbGRtVnVkSE5iYVYxY2JpQWdJQ0FnSUNBZ2ZTbGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJR1YyWlc1MFRHbHpkR1Z1WlhKek8xeHVmVnh1WEc1Y2JpOHZhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZhSFJ0YkM5M1p5OWtjbUZtZEhNdmFIUnRiQzl0WVhOMFpYSXZjMmx1WjJ4bExYQmhaMlV1YUhSdGJDTjJiMmxrTFdWc1pXMWxiblJ6WEc1ZkxtbHpWbTlwWkZSaFp5QTlJRjh1YldGclpWQnlaV1JwWTJGMFpTaGNJbUZ5WldFZ1ltRnpaU0JpY2lCamIyd2daVzFpWldRZ2FISWdhVzFuSUdsdWNIVjBJR3RsZVdkbGJpQnNhVzVySUcxbGJuVnBkR1Z0SUcxbGRHRWdjR0Z5WVcwZ2MyOTFjbU5sSUhSeVlXTnJJSGRpY2lCeUxXTnZiblJsYm5SY0lpazdYRzVmTG1selFtOXZiR1ZoYmtGMGRISWdQU0JmTG0xaGEyVlFjbVZrYVdOaGRHVW9KM05sYkdWamRHVmtJR05vWldOclpXUWdaR2x6WVdKc1pXUWdjbVZoWkc5dWJIa2djbVZ4ZFdseVpXUWdiM0JsYmlCaGRYUnZabTlqZFhNZ1kyOXVkSEp2YkhNZ1lYVjBiM0JzWVhrZ1kyOXRjR0ZqZENCc2IyOXdJR1JsWm1WeUlHMTFiSFJwY0d4bEp5azdYRzVjYmx4dVh5NXBjMFY0Y0hJZ1BTQm1kVzVqZEdsdmJpaGxlSEJ5S1h0Y2JpQWdjbVYwZFhKdUlHVjRjSElnSmlZZ1pYaHdjaTUwZVhCbElEMDlQU0FuWlhod2NtVnpjMmx2YmljN1hHNTlYRzR2THlCQVZFOUVUem9nYldGclpTQnBkQ0J0YjNKbElITjBjbWxqZEZ4dVh5NXBjMGR5YjNWd0lEMGdablZ1WTNScGIyNG9aM0p2ZFhBcGUxeHVJQ0J5WlhSMWNtNGdaM0p2ZFhBdWFXNXFaV04wSUh4OElHZHliM1Z3TGlScGJtcGxZM1E3WEc1OVhHNWNibDh1WW14aGJtdFNaV2NnUFNBdlhGeHpLeTg3SUZ4dVhHNWZMbWRsZEVOdmJYQnBiR1ZHYmlBOUlHWjFibU4wYVc5dUtITnZkWEpqWlN3Z1kzUjRMQ0J2Y0hScGIyNXpLWHRjYmlBZ2NtVjBkWEp1SUdaMWJtTjBhVzl1S0NCd1lYTnpaV1JQY0hScGIyNXpJQ2w3WEc0Z0lDQWdhV1lvSUhCaGMzTmxaRTl3ZEdsdmJuTWdKaVlnYjNCMGFXOXVjeUFwSUY4dVpYaDBaVzVrS0NCd1lYTnpaV1JQY0hScGIyNXpJQ3dnYjNCMGFXOXVjeUFwTzF4dUlDQWdJR1ZzYzJVZ2NHRnpjMlZrVDNCMGFXOXVjeUE5SUc5d2RHbHZibk03WEc0Z0lDQWdjbVYwZFhKdUlHTjBlQzRrWTI5dGNHbHNaU2h6YjNWeVkyVXNJSEJoYzNObFpFOXdkR2x2Ym5NZ0tWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCamRIZ3VKR052YlhCcGJHVXVZbWx1WkNoamRIZ3NjMjkxY21ObExDQnZjSFJwYjI1ektWeHVmVnh1WEc0dkx5QnlaVzF2ZG1VZ1pHbHlaV04wYVhabElIQmhjbUZ0SUdaeWIyMGdRVk5VWEc1ZkxtWnBlRlJoWjBGVFZDQTlJR1oxYm1OMGFXOXVLQ0IwWVdkQlUxUXNJRU52YlhCdmJtVnVkQ0FwZTF4dVhHNGdJR2xtS0NCMFlXZEJVMVF1ZEc5MVkyaGxaQ0FwSUhKbGRIVnlianRjYmx4dUlDQjJZWElnWVhSMGNuTWdQU0IwWVdkQlUxUXVZWFIwY25NN1hHNWNiaUFnYVdZb0lDRmhkSFJ5Y3lBcElISmxkSFZ5Ymp0Y2JseHVJQ0F2THlCTllYbGlaU0J0ZFd4MGFYQnNaU0JrYVhKbFkzUnBkbVVnYm1WbFpDQnpZVzFsSUhCaGNtRnRMQ0JjYmlBZ0x5OGdWMlVnY0d4aFkyVWdZV3hzSUhCaGNtRnRJR2x1SUhSdmRHRnNVR0Z5WVcxTllYQmNiaUFnZG1GeUlHeGxiaUE5SUdGMGRISnpMbXhsYm1kMGFEdGNiaUFnYVdZb0lXeGxiaWtnY21WMGRYSnVPMXh1SUNCMllYSWdaR2x5WldOMGFYWmxjejFiWFN3Z2IzUm9aWEpCZEhSeVRXRndJRDBnZTMwN1hHNGdJR1p2Y2lnN2JHVnVMUzA3S1h0Y2JseHVJQ0FnSUhaaGNpQmhkSFJ5SUQwZ1lYUjBjbk5iSUd4bGJpQmRPMXh1WEc1Y2JpQWdJQ0F2THlCQVNVVWdabWw0SUVsRk9TMGdhVzV3ZFhRZ2RIbHdaU0JqWVc0bmRDQmhjM05wWjI0Z1lXWjBaWElnZG1Gc2RXVmNiaUFnSUNCcFppaGhkSFJ5TG01aGJXVWdQVDA5SUNkMGVYQmxKeWtnWVhSMGNpNXdjbWx2Y21sMGVTQTlJRTFCV0Y5UVVrbFBVa2xVV1NBcklERTdYRzVjYmlBZ0lDQjJZWElnWkdseVpXTjBhWFpsSUQwZ1EyOXRjRzl1Wlc1MExtUnBjbVZqZEdsMlpTZ2dZWFIwY2k1dVlXMWxJQ2s3WEc0Z0lDQWdhV1lvSUdScGNtVmpkR2wyWlNBcElIdGNibHh1SUNBZ0lDQWdZWFIwY2k1d2NtbHZjbWwwZVNBOUlHUnBjbVZqZEdsMlpTNXdjbWx2Y21sMGVTQjhmQ0F4TzF4dUlDQWdJQ0FnWVhSMGNpNWthWEpsWTNScGRtVWdQU0IwY25WbE8xeHVJQ0FnSUNBZ1pHbHlaV04wYVhabGN5NXdkWE5vS0dGMGRISXBPMXh1WEc0Z0lDQWdmV1ZzYzJVZ2FXWW9ZWFIwY2k1MGVYQmxJRDA5UFNBbllYUjBjbWxpZFhSbEp5bDdYRzRnSUNBZ0lDQnZkR2hsY2tGMGRISk5ZWEJiWVhSMGNpNXVZVzFsWFNBOUlHRjBkSEl1ZG1Gc2RXVTdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdaR2x5WldOMGFYWmxjeTVtYjNKRllXTm9LQ0JtZFc1amRHbHZiaWdnWVhSMGNpQXBlMXh1SUNBZ0lIWmhjaUJrYVhKbFkzUnBkbVVnUFNCRGIyMXdiMjVsYm5RdVpHbHlaV04wYVhabEtHRjBkSEl1Ym1GdFpTazdYRzRnSUNBZ2RtRnlJSEJoY21GdElEMGdaR2x5WldOMGFYWmxMbkJoY21GdE8xeHVJQ0FnSUdsbUtIQmhjbUZ0SUNZbUlIQmhjbUZ0TG14bGJtZDBhQ2w3WEc0Z0lDQWdJQ0JoZEhSeUxuQmhjbUZ0SUQwZ2UzMDdYRzRnSUNBZ0lDQndZWEpoYlM1bWIzSkZZV05vS0daMWJtTjBhVzl1S0NCdVlXMWxJQ2w3WEc0Z0lDQWdJQ0FnSUdsbUtDQnVZVzFsSUdsdUlHOTBhR1Z5UVhSMGNrMWhjQ0FwZTF4dUlDQWdJQ0FnSUNBZ0lHRjBkSEl1Y0dGeVlXMWJibUZ0WlYwZ1BTQnZkR2hsY2tGMGRISk5ZWEJiYm1GdFpWMGdQVDA5SUhWdVpHVm1hVzVsWkQ4Z2RISjFaVG9nYjNSb1pYSkJkSFJ5VFdGd1cyNWhiV1ZkWEc0Z0lDQWdJQ0FnSUNBZ1h5NXlaVzF2ZG1WUGJtVW9ZWFIwY25Nc0lHWjFibU4wYVc5dUtHRjBkSElwZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHRjBkSEl1Ym1GdFpTQTlQVDBnYm1GdFpWeHVJQ0FnSUNBZ0lDQWdJSDBwWEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgwcFhHNGdJQ0FnZlZ4dUlDQjlLVHRjYmx4dUlDQmhkSFJ5Y3k1emIzSjBLR1oxYm1OMGFXOXVLR0V4TENCaE1pbDdYRzRnSUNBZ1hHNGdJQ0FnZG1GeUlIQXhJRDBnWVRFdWNISnBiM0pwZEhrN1hHNGdJQ0FnZG1GeUlIQXlJRDBnWVRJdWNISnBiM0pwZEhrN1hHNWNiaUFnSUNCcFppZ2djREVnUFQwZ2JuVnNiQ0FwSUhBeElEMGdUVUZZWDFCU1NVOVNTVlJaTzF4dUlDQWdJR2xtS0NCd01pQTlQU0J1ZFd4c0lDa2djRElnUFNCTlFWaGZVRkpKVDFKSlZGazdYRzVjYmlBZ0lDQnlaWFIxY200Z2NESWdMU0J3TVR0Y2JseHVJQ0I5S1Z4dVhHNGdJSFJoWjBGVFZDNTBiM1ZqYUdWa0lEMGdkSEoxWlR0Y2JuMWNibHh1WHk1bWFXNWtTWFJsYlNBOUlHWjFibU4wYVc5dUtHeHBjM1FzSUdacGJIUmxjaWw3WEc0Z0lHbG1LQ0ZzYVhOMElIeDhJQ0ZzYVhOMExteGxibWQwYUNrZ2NtVjBkWEp1TzF4dUlDQjJZWElnYkdWdUlEMGdiR2x6ZEM1c1pXNW5kR2c3WEc0Z0lIZG9hV3hsS0d4bGJpMHRLWHRjYmlBZ0lDQnBaaWhtYVd4MFpYSW9iR2x6ZEZ0c1pXNWRLU2tnY21WMGRYSnVJR3hwYzNSYmJHVnVYVnh1SUNCOVhHNTlYRzVjYmw4dVoyVjBVR0Z5WVcxUFltb2dQU0JtZFc1amRHbHZiaWhqYjIxd2IyNWxiblFzSUhCaGNtRnRLWHRjYmlBZ2RtRnlJSEJoY21GdFQySnFJRDBnZTMwN1hHNGdJR2xtS0hCaGNtRnRLU0I3WEc0Z0lDQWdabTl5S0haaGNpQnBJR2x1SUhCaGNtRnRLU0JwWmlod1lYSmhiUzVvWVhOUGQyNVFjbTl3WlhKMGVTaHBLU2w3WEc0Z0lDQWdJQ0IyWVhJZ2RtRnNkV1VnUFNCd1lYSmhiVnRwWFR0Y2JpQWdJQ0FnSUhCaGNtRnRUMkpxVzJsZElEMGdJSFpoYkhWbElDWW1JSFpoYkhWbExuUjVjR1U5UFQwblpYaHdjbVZ6YzJsdmJpYy9JR052YlhCdmJtVnVkQzRrWjJWMEtIWmhiSFZsS1RvZ2RtRnNkV1U3WEc0Z0lDQWdmVnh1SUNCOVhHNGdJSEpsZEhWeWJpQndZWEpoYlU5aWFqdGNibjFjYmw4dVpYWmxiblJTWldjZ1BTQXZYbTl1TFNoY1hIZGJMVnhjZDEwcktTUXZPMXh1WEc1ZkxuUnZWR1Y0ZENBOUlHWjFibU4wYVc5dUtHOWlhaWw3WEc0Z0lISmxkSFZ5YmlCdlltb2dQVDBnYm5Wc2JDQS9JRndpWENJNklGd2lYQ0lnS3lCdlltbzdYRzU5WEc1Y2JseHVMeThnYUc5bllXNWNiaTh2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5MGQybDBkR1Z5TDJodloyRnVMbXB6WEc0dkx5Qk5TVlJjYmw4dVpYTmpZWEJsSUQwZ0tHWjFibU4wYVc5dUtDbDdYRzRnSUhaaGNpQnlRVzF3SUQwZ0x5WXZaeXhjYmlBZ0lDQWdJSEpNZENBOUlDODhMMmNzWEc0Z0lDQWdJQ0J5UjNRZ1BTQXZQaTluTEZ4dUlDQWdJQ0FnY2tGd2IzTWdQU0F2WEZ3bkwyY3NYRzRnSUNBZ0lDQnlVWFZ2ZENBOUlDOWNYRndpTDJjc1hHNGdJQ0FnSUNCb1EyaGhjbk1nUFNBdld5WThQbHhjWENKY1hDZGRMenRjYmx4dUlDQm1kVzVqZEdsdmJpQnBaMjV2Y21WT2RXeHNWbUZzS0haaGJDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCVGRISnBibWNvS0haaGJDQTlQVDBnZFc1a1pXWnBibVZrSUh4OElIWmhiQ0E5UFNCdWRXeHNLU0EvSUNjbklEb2dkbUZzS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCbWRXNWpkR2x2YmlBb2MzUnlLU0I3WEc0Z0lDQWdjM1J5SUQwZ2FXZHViM0psVG5Wc2JGWmhiQ2h6ZEhJcE8xeHVJQ0FnSUhKbGRIVnliaUJvUTJoaGNuTXVkR1Z6ZENoemRISXBJRDljYmlBZ0lDQWdJSE4wY2x4dUlDQWdJQ0FnSUNBdWNtVndiR0ZqWlNoeVFXMXdMQ0FuSm1GdGNEc25LVnh1SUNBZ0lDQWdJQ0F1Y21Wd2JHRmpaU2h5VEhRc0lDY21iSFE3SnlsY2JpQWdJQ0FnSUNBZ0xuSmxjR3hoWTJVb2NrZDBMQ0FuSm1kME95Y3BYRzRnSUNBZ0lDQWdJQzV5WlhCc1lXTmxLSEpCY0c5ekxDQW5KaU16T1RzbktWeHVJQ0FnSUNBZ0lDQXVjbVZ3YkdGalpTaHlVWFZ2ZEN3Z0p5WnhkVzkwT3ljcElEcGNiaUFnSUNBZ0lITjBjanRjYmlBZ2ZWeHVYRzU5S1NncE8xeHVYRzVjYmx4dVhHNWNibHh1WEc0aVhYMD0iLCJ2YXIgZGlmZkFycmF5ID0gcmVxdWlyZSgnLi9oZWxwZXIvZGlmZicpLmRpZmZBcnJheTtcbnZhciBjb21iaW5lID0gcmVxdWlyZSgnLi9oZWxwZXIvY29tYmluZScpO1xudmFyIGFuaW1hdGUgPSByZXF1aXJlKFwiLi9oZWxwZXIvYW5pbWF0ZVwiKTtcbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlci9QYXJzZXInKTtcbnZhciBub2RlID0gcmVxdWlyZShcIi4vcGFyc2VyL25vZGVcIik7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL2dyb3VwJyk7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vZG9tXCIpO1xudmFyIF8gPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG52YXIgT1BUSU9OUyA9IGNvbnN0cy5PUFRJT05TO1xudmFyIEVSUk9SID0gY29uc3RzLkVSUk9SO1xudmFyIE1TRyA9IGNvbnN0cy5NU0c7XG52YXIgbm9kZUN1cnNvciA9IHJlcXVpcmUoJy4vaGVscGVyL2N1cnNvcicpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL3JlbmRlci9zaGFyZWQnKTtcblxuXG5cbnZhciB3YWxrZXJzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG5cbi8vIHVzZWQgaW4gd2Fsa2Vycy5saXN0XG4vLyByZW1vdmUgYmxvY2sgaW4gZ3JvdXBcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGluZGV4LCBybGVuLCBjaGlsZHJlbil7XG4gIGZvcih2YXIgaiA9IDE7IGogPD0gcmxlbjsgaisrKXsgLy9yZW1vdmVkXG4gICAgdmFyIHJlbW92ZWQgPSBjaGlsZHJlblsgaW5kZXggKyBqIF07XG4gICAgaWYocmVtb3ZlZCkgcmVtb3ZlZC5kZXN0cm95KHRydWUpO1xuICB9XG4gIGNoaWxkcmVuLnNwbGljZShpbmRleCsxLCBybGVuKTtcbn1cblxuXG53YWxrZXJzLmxpc3QgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpe1xuXG4gIHZhciBSZWd1bGFyID0gd2Fsa2Vycy5SZWd1bGFyOyAgXG4gIHZhciBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJSZWd1bGFyIGxpc3RcIiksXG4gICAgbmFtZXNwYWNlID0gb3B0aW9ucy5uYW1lc3BhY2UsXG4gICAgZXh0cmEgPSBvcHRpb25zLmV4dHJhO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGdyb3VwID0gbmV3IEdyb3VwKFtwbGFjZWhvbGRlcl0pO1xuICB2YXIgY2hpbGRyZW4gPSBncm91cC5jaGlsZHJlbjtcblxuICB2YXIgaW5kZXhOYW1lID0gYXN0LnZhcmlhYmxlICsgJ19pbmRleCc7XG4gIHZhciBrZXlOYW1lID0gYXN0LnZhcmlhYmxlICsgJ19rZXknO1xuICB2YXIgdmFyaWFibGUgPSBhc3QudmFyaWFibGU7XG4gIHZhciBhbHRlcm5hdGUgPSBhc3QuYWx0ZXJuYXRlO1xuICB2YXIgdHJhY2sgPSBhc3QudHJhY2ssIGtleU9mLCBleHRyYU9iajtcbiAgdmFyIGN1cnNvciA9IG9wdGlvbnMuY3Vyc29yO1xuXG4gIGlmKCB0cmFjayAmJiB0cmFjayAhPT0gdHJ1ZSApe1xuICAgIFxuICAgIHRyYWNrID0gdGhpcy5fdG91Y2hFeHByKHRyYWNrKTtcbiAgICBleHRyYU9iaiA9IF8uY3JlYXRlT2JqZWN0KGV4dHJhKTtcbiAgICBrZXlPZiA9IGZ1bmN0aW9uKCBpdGVtLCBpbmRleCApe1xuICAgICAgZXh0cmFPYmpbIHZhcmlhYmxlIF0gPSBpdGVtO1xuICAgICAgZXh0cmFPYmpbIGluZGV4TmFtZSBdID0gaW5kZXg7XG4gICAgICAvLyBARklYIGtleU5hbWVcbiAgICAgIHJldHVybiB0cmFjay5nZXQoIHNlbGYsIGV4dHJhT2JqICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmFuZ2UoaW5kZXgsIGVuZCwgbmV3TGlzdCwgcmF3TmV3VmFsdWUpe1xuICAgIGZvcih2YXIgbyA9IGluZGV4OyBvIDwgZW5kOyBvKyspeyAvL2FkZFxuICAgICAgLy8gcHJvdG90eXBlIGluaGVyaXRcbiAgICAgIHZhciBpdGVtID0gbmV3TGlzdFtvXTtcbiAgICAgIHZhciBkYXRhID0gXy5jcmVhdGVPYmplY3QoZXh0cmEpO1xuICAgICAgdXBkYXRlVGFyZ2V0KGRhdGEsIG8sIGl0ZW0sIHJhd05ld1ZhbHVlKTtcblxuICAgICAgdmFyIHNlY3Rpb24gPSBzZWxmLiRjb21waWxlKGFzdC5ib2R5LCB7XG4gICAgICAgIGV4dHJhOiBkYXRhLFxuICAgICAgICBuYW1lc3BhY2U6bmFtZXNwYWNlLFxuICAgICAgICByZWNvcmQ6IHRydWUsXG4gICAgICAgIG91dGVyOiBvcHRpb25zLm91dGVyLFxuICAgICAgICBjdXJzb3I6IGN1cnNvclxuICAgICAgfSlcbiAgICAgIHNlY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgICAvLyBhdXRvbGlua1xuICAgICAgdmFyIGluc2VydCA9ICBjb21iaW5lLmxhc3QoZ3JvdXAuZ2V0KG8pKTtcbiAgICAgIGlmKGluc2VydC5wYXJlbnROb2RlICYmICEoY3Vyc29yICYmIGN1cnNvci5ub2RlKSApe1xuICAgICAgICBhbmltYXRlLmluamVjdChjb21iaW5lLm5vZGUoc2VjdGlvbiksaW5zZXJ0LCAnYWZ0ZXInKTtcbiAgICAgIH1cbiAgICAgIC8vIGluc2VydC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb21iaW5lLm5vZGUoc2VjdGlvbiksIGluc2VydC5uZXh0U2libGluZyk7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoIG8gKyAxICwgMCwgc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFyZ2V0KHRhcmdldCwgaW5kZXgsIGl0ZW0sIHJhd05ld1ZhbHVlKXtcbiAgICAgIHRhcmdldFsgaW5kZXhOYW1lIF0gPSBpbmRleDtcbiAgICAgIGlmKCByYXdOZXdWYWx1ZSApe1xuICAgICAgICB0YXJnZXRbIGtleU5hbWUgXSA9IGl0ZW07XG4gICAgICAgIHRhcmdldFsgdmFyaWFibGUgXSA9IHJhd05ld1ZhbHVlWyBpdGVtIF07XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGFyZ2V0WyB2YXJpYWJsZSBdID0gaXRlbTtcbiAgICAgICAgdGFyZ2V0W2tleU5hbWVdID0gbnVsbFxuICAgICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiB1cGRhdGVSYW5nZShzdGFydCwgZW5kLCBuZXdMaXN0LCByYXdOZXdWYWx1ZSl7XG4gICAgZm9yKHZhciBrID0gc3RhcnQ7IGsgPCBlbmQ7IGsrKyl7IC8vIG5vIGNoYW5nZVxuICAgICAgdmFyIHNlY3QgPSBncm91cC5nZXQoIGsgKyAxICksIGl0ZW0gPSBuZXdMaXN0WyBrIF07XG4gICAgICB1cGRhdGVUYXJnZXQoc2VjdC5kYXRhLCBrLCBpdGVtLCByYXdOZXdWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTEQobmV3TGlzdCwgb2xkTGlzdCwgc3BsaWNlcyAsIHJhd05ld1ZhbHVlICl7XG5cbiAgICB2YXIgY3VyID0gcGxhY2Vob2xkZXI7XG4gICAgdmFyIG0gPSAwLCBsZW4gPSBuZXdMaXN0Lmxlbmd0aDtcblxuICAgIGlmKCFzcGxpY2VzICYmIChsZW4gIT09MCB8fCBvbGRMaXN0Lmxlbmd0aCAhPT0wKSAgKXtcbiAgICAgIHNwbGljZXMgPSBkaWZmQXJyYXkobmV3TGlzdCwgb2xkTGlzdCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYoIXNwbGljZXMgfHwgIXNwbGljZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICBcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3BsaWNlcy5sZW5ndGg7IGkrKyl7IC8vaW5pdFxuICAgICAgdmFyIHNwbGljZSA9IHNwbGljZXNbaV07XG4gICAgICB2YXIgaW5kZXggPSBzcGxpY2UuaW5kZXg7IC8vIGJlYWN1c2Ugd2UgdXNlIGEgY29tbWVudCBmb3IgcGxhY2Vob2xkZXJcbiAgICAgIHZhciByZW1vdmVkID0gc3BsaWNlLnJlbW92ZWQ7XG4gICAgICB2YXIgYWRkID0gc3BsaWNlLmFkZDtcbiAgICAgIHZhciBybGVuID0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgICAvLyBmb3IgdHJhY2tcbiAgICAgIGlmKCB0cmFjayAmJiBybGVuICYmIGFkZCApe1xuICAgICAgICB2YXIgbWluYXIgPSBNYXRoLm1pbihybGVuLCBhZGQpO1xuICAgICAgICB2YXIgdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUodEluZGV4IDwgbWluYXIpe1xuICAgICAgICAgIGlmKCBrZXlPZihuZXdMaXN0W2luZGV4XSwgaW5kZXgpICE9PSBrZXlPZiggcmVtb3ZlZFswXSwgaW5kZXggKSApe1xuICAgICAgICAgICAgcmVtb3ZlUmFuZ2UoaW5kZXgsIDEsIGNoaWxkcmVuKVxuICAgICAgICAgICAgYWRkUmFuZ2UoaW5kZXgsIGluZGV4KzEsIG5ld0xpc3QsIHJhd05ld1ZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZW1vdmVkLnNoaWZ0KCk7XG4gICAgICAgICAgYWRkLS07XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICB0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBybGVuID0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHVwZGF0ZVJhbmdlKG0sIGluZGV4LCBuZXdMaXN0LCByYXdOZXdWYWx1ZSk7XG5cbiAgICAgIHJlbW92ZVJhbmdlKCBpbmRleCAscmxlbiwgY2hpbGRyZW4pXG5cbiAgICAgIGFkZFJhbmdlKGluZGV4LCBpbmRleCthZGQsIG5ld0xpc3QsIHJhd05ld1ZhbHVlKVxuXG4gICAgICBtID0gaW5kZXggKyBhZGQgLSBybGVuO1xuICAgICAgbSAgPSBtIDwgMD8gMCA6IG07XG5cbiAgICB9XG4gICAgaWYobSA8IGxlbil7XG4gICAgICBmb3IodmFyIGkgPSBtOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICB2YXIgcGFpciA9IGdyb3VwLmdldChpICsgMSk7XG4gICAgICAgIHBhaXIuZGF0YVtpbmRleE5hbWVdID0gaTtcbiAgICAgICAgLy8gQFRPRE8gZml4IGtleXNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgdHJhY2sgaXMgY29uc3RhbnQgdGVzdC5cbiAgZnVuY3Rpb24gdXBkYXRlU2ltcGxlKG5ld0xpc3QsIG9sZExpc3QsIHJhd05ld1ZhbHVlICl7XG5cbiAgICB2YXIgbmxlbiA9IG5ld0xpc3QubGVuZ3RoO1xuICAgIHZhciBvbGVuID0gb2xkTGlzdC5sZW5ndGg7XG4gICAgdmFyIG1sZW4gPSBNYXRoLm1pbihubGVuLCBvbGVuKTtcblxuICAgIHVwZGF0ZVJhbmdlKDAsIG1sZW4sIG5ld0xpc3QsIHJhd05ld1ZhbHVlKVxuICAgIGlmKG5sZW4gPCBvbGVuKXsgLy9uZWVkIGFkZFxuICAgICAgcmVtb3ZlUmFuZ2Uobmxlbiwgb2xlbi1ubGVuLCBjaGlsZHJlbik7XG4gICAgfWVsc2UgaWYobmxlbiA+IG9sZW4pe1xuICAgICAgYWRkUmFuZ2Uob2xlbiwgbmxlbiwgbmV3TGlzdCwgcmF3TmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShuZXdWYWx1ZSwgb2xkVmFsdWUsIHNwbGljZXMpe1xuXG4gICAgdmFyIG5UeXBlID0gXy50eXBlT2YoIG5ld1ZhbHVlICk7XG4gICAgdmFyIG9UeXBlID0gXy50eXBlT2YoIG9sZFZhbHVlICk7XG5cbiAgICB2YXIgbmV3TGlzdCA9IGdldExpc3RGcm9tVmFsdWUoIG5ld1ZhbHVlLCBuVHlwZSApO1xuICAgIHZhciBvbGRMaXN0ID0gZ2V0TGlzdEZyb21WYWx1ZSggb2xkVmFsdWUsIG9UeXBlICk7XG5cbiAgICB2YXIgcmF3TmV3VmFsdWU7XG5cblxuICAgIHZhciBubGVuID0gbmV3TGlzdCAmJiBuZXdMaXN0Lmxlbmd0aDtcbiAgICB2YXIgb2xlbiA9IG9sZExpc3QgJiYgb2xkTGlzdC5sZW5ndGg7XG5cbiAgICAvLyBpZiBwcmV2aW91cyBsaXN0IGhhcyAsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBhbHRuYXRlZCBzZWN0aW9uLlxuICAgIGlmKCAhb2xlbiAmJiBubGVuICYmIGdyb3VwLmdldCgxKSApe1xuICAgICAgdmFyIGFsdEdyb3VwID0gY2hpbGRyZW4ucG9wKCk7XG4gICAgICBpZihhbHRHcm91cC5kZXN0cm95KSAgYWx0R3JvdXAuZGVzdHJveSh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiggblR5cGUgPT09ICdvYmplY3QnICkgcmF3TmV3VmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgIGlmKHRyYWNrID09PSB0cnVlKXtcbiAgICAgIHVwZGF0ZVNpbXBsZSggbmV3TGlzdCwgb2xkTGlzdCwgIHJhd05ld1ZhbHVlICk7XG4gICAgfWVsc2V7XG4gICAgICB1cGRhdGVMRCggbmV3TGlzdCwgb2xkTGlzdCwgc3BsaWNlcywgcmF3TmV3VmFsdWUgKTtcbiAgICB9XG5cbiAgICAvLyBAIHsjbGlzdH0geyNlbHNlfVxuICAgIGlmKCAhbmxlbiAmJiBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlLmxlbmd0aCl7XG4gICAgICB2YXIgc2VjdGlvbiA9IHNlbGYuJGNvbXBpbGUoYWx0ZXJuYXRlLCB7XG4gICAgICAgIGV4dHJhOiBleHRyYSxcbiAgICAgICAgcmVjb3JkOiB0cnVlLFxuICAgICAgICBvdXRlcjogb3B0aW9ucy5vdXRlcixcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgIH0pXG4gICAgICBjaGlsZHJlbi5wdXNoKHNlY3Rpb24pO1xuICAgICAgaWYocGxhY2Vob2xkZXIucGFyZW50Tm9kZSl7XG4gICAgICAgIGFuaW1hdGUuaW5qZWN0KGNvbWJpbmUubm9kZShzZWN0aW9uKSwgcGxhY2Vob2xkZXIsICdhZnRlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuJHdhdGNoKGFzdC5zZXF1ZW5jZSwgdXBkYXRlLCB7IFxuICAgIGluaXQ6IHRydWUsIFxuICAgIGRpZmY6IHRyYWNrICE9PSB0cnVlICxcbiAgICBkZWVwOiB0cnVlXG4gIH0pO1xuICAvL0BGSVhJVCwgYmVhY3VzZSBpdCBpcyBzeW5jIHByb2Nlc3MsIHdlIGNhbiBcbiAgY3Vyc29yID0gbnVsbDtcbiAgcmV0dXJuIGdyb3VwO1xufVxuXG5cblxuLy8geyNpbmNsdWRlIH0gb3IgeyNpbmMgdGVtcGxhdGV9XG53YWxrZXJzLnRlbXBsYXRlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKXtcbiAgdmFyIGNvbnRlbnQgPSBhc3QuY29udGVudCwgY29tcGlsZWQ7XG4gIHZhciBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ2lubGN1ZGUnKTtcbiAgdmFyIGNvbXBpbGVkLCBuYW1lc3BhY2UgPSBvcHRpb25zLm5hbWVzcGFjZSwgZXh0cmEgPSBvcHRpb25zLmV4dHJhO1xuICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoW3BsYWNlaG9sZGVyXSk7XG4gIHZhciBjdXJzb3IgPSBvcHRpb25zLmN1cnNvcjtcblxuICBpZihjb250ZW50KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kd2F0Y2goY29udGVudCwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgdmFyIHJlbW92ZWQgPSBncm91cC5nZXQoMSksIHR5cGU9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmKCByZW1vdmVkKXtcbiAgICAgICAgcmVtb3ZlZC5kZXN0cm95KHRydWUpOyBcbiAgICAgICAgZ3JvdXAuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICBpZighdmFsdWUpIHJldHVybjtcblxuICAgICAgZ3JvdXAucHVzaCggY29tcGlsZWQgPSB0eXBlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoY3Vyc29yPyB7Y3Vyc29yOiBjdXJzb3J9OiBudWxsKTogc2VsZi4kY29tcGlsZSggdHlwZSAhPT0gJ29iamVjdCc/IFN0cmluZyh2YWx1ZSk6IHZhbHVlLCB7XG4gICAgICAgIHJlY29yZDogdHJ1ZSxcbiAgICAgICAgb3V0ZXI6IG9wdGlvbnMub3V0ZXIsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICBjdXJzb3I6IGN1cnNvcixcbiAgICAgICAgZXh0cmE6IGV4dHJhfSkgKTsgXG4gICAgICBpZihwbGFjZWhvbGRlci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbXBpbGVkLiRpbmplY3QocGxhY2Vob2xkZXIsICdiZWZvcmUnKVxuICAgICAgfVxuICAgIH0sIE9QVElPTlMuSU5JVCk7XG4gIH1cbiAgcmV0dXJuIGdyb3VwO1xufTtcblxuZnVuY3Rpb24gZ2V0TGlzdEZyb21WYWx1ZSh2YWx1ZSwgdHlwZSl7XG4gIHJldHVybiB0eXBlID09PSAnYXJyYXknPyB2YWx1ZTogKHR5cGUgPT09ICdvYmplY3QnPyBfLmtleXModmFsdWUpIDogIFtdKTtcbn1cblxuXG4vLyBob3cgdG8gcmVzb2x2ZSB0aGlzIHByb2JsZW1cbnZhciBpaSA9IDA7XG53YWxrZXJzWydpZiddID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKXtcbiAgdmFyIHNlbGYgPSB0aGlzLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIGV4dHJhID0gb3B0aW9ucy5leHRyYTtcbiAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmVsZW1lbnQpeyAvLyBhdHRyaWJ1dGUgaW50ZXBsYXRpb25cbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24obnZhbHVlKXtcbiAgICAgIGlmKCEhbnZhbHVlKXtcbiAgICAgICAgaWYoYWx0ZXJuYXRlKSBjb21iaW5lLmRlc3Ryb3koYWx0ZXJuYXRlKVxuICAgICAgICBpZihhc3QuY29uc2VxdWVudCkgY29uc2VxdWVudCA9IHNlbGYuJGNvbXBpbGUoYXN0LmNvbnNlcXVlbnQsIHtcbiAgICAgICAgICByZWNvcmQ6IHRydWUsIFxuICAgICAgICAgIGVsZW1lbnQ6IG9wdGlvbnMuZWxlbWVudCAsIFxuICAgICAgICAgIGV4dHJhOmV4dHJhXG4gICAgICAgIH0pO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKCBjb25zZXF1ZW50ICkgY29tYmluZS5kZXN0cm95KGNvbnNlcXVlbnQpXG4gICAgICAgIGlmKCBhc3QuYWx0ZXJuYXRlICkgYWx0ZXJuYXRlID0gc2VsZi4kY29tcGlsZShhc3QuYWx0ZXJuYXRlLCB7cmVjb3JkOiB0cnVlLCBlbGVtZW50OiBvcHRpb25zLmVsZW1lbnQsIGV4dHJhOiBleHRyYX0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiR3YXRjaChhc3QudGVzdCwgdXBkYXRlLCBPUFRJT05TLkZPUkNFKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoY29uc2VxdWVudCkgY29tYmluZS5kZXN0cm95KGNvbnNlcXVlbnQpO1xuICAgICAgICBlbHNlIGlmKGFsdGVybmF0ZSkgY29tYmluZS5kZXN0cm95KGFsdGVybmF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHRlc3QsIG5vZGU7XG4gIHZhciBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJSZWd1bGFyIGlmXCIgKyBpaSsrKTtcbiAgdmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gIGdyb3VwLnB1c2gocGxhY2Vob2xkZXIpO1xuICB2YXIgcHJlVmFsdWUgPSBudWxsLCBuYW1lc3BhY2U9IG9wdGlvbnMubmFtZXNwYWNlO1xuICB2YXIgY3Vyc29yID0gb3B0aW9ucy5jdXJzb3I7XG4gIGlmKGN1cnNvciAmJiBjdXJzb3Iubm9kZSl7XG4gICAgZG9tLmluamVjdCggcGxhY2Vob2xkZXIgLCBjdXJzb3Iubm9kZSwnYmVmb3JlJylcbiAgfVxuXG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChudmFsdWUsIG9sZCl7XG4gICAgdmFyIHZhbHVlID0gISFudmFsdWUsIGNvbXBpbGVkU2VjdGlvbjtcbiAgICBpZih2YWx1ZSA9PT0gcHJlVmFsdWUpIHJldHVybjtcbiAgICBwcmVWYWx1ZSA9IHZhbHVlO1xuICAgIGlmKGdyb3VwLmNoaWxkcmVuWzFdKXtcbiAgICAgIGdyb3VwLmNoaWxkcmVuWzFdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICBncm91cC5jaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gICAgdmFyIGN1ck9wdGlvbnMgPSB7XG4gICAgICByZWNvcmQ6IHRydWUsIFxuICAgICAgb3V0ZXI6IG9wdGlvbnMub3V0ZXIsXG4gICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgXG4gICAgICBleHRyYTogZXh0cmEsXG4gICAgICBjdXJzb3I6IGN1cnNvclxuICAgIH1cbiAgICBpZih2YWx1ZSl7IC8vdHJ1ZVxuXG4gICAgICBpZihhc3QuY29uc2VxdWVudCAmJiBhc3QuY29uc2VxdWVudC5sZW5ndGgpeyBcbiAgICAgICAgY29tcGlsZWRTZWN0aW9uID0gc2VsZi4kY29tcGlsZSggYXN0LmNvbnNlcXVlbnQgLCBjdXJPcHRpb25zICk7XG4gICAgICB9XG4gICAgfWVsc2V7IC8vZmFsc2VcbiAgICAgIGlmKGFzdC5hbHRlcm5hdGUgJiYgYXN0LmFsdGVybmF0ZS5sZW5ndGgpe1xuICAgICAgICBjb21waWxlZFNlY3Rpb24gPSBzZWxmLiRjb21waWxlKGFzdC5hbHRlcm5hdGUsIGN1ck9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwbGFjZWhvbGRlci5wYXJlbnROb2RlICYmIHBsYWNlaG9sZGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBub2RlLCBwbGFjZWhvbGRlciApO1xuICAgIGlmKGNvbXBpbGVkU2VjdGlvbil7XG4gICAgICBncm91cC5wdXNoKGNvbXBpbGVkU2VjdGlvbik7XG4gICAgICBpZihwbGFjZWhvbGRlci5wYXJlbnROb2RlKXtcbiAgICAgICAgYW5pbWF0ZS5pbmplY3QoY29tYmluZS5ub2RlKGNvbXBpbGVkU2VjdGlvbiksIHBsYWNlaG9sZGVyLCAnYmVmb3JlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGN1cnNvciA9IG51bGw7XG4gICAgLy8gYWZ0ZXIgZmlyc3QgbW91bnQgLCB3ZSBuZWVkIGNsZWFyIHRoaXMgZmxhdDtcbiAgfVxuICB0aGlzLiR3YXRjaChhc3QudGVzdCwgdXBkYXRlLCBPUFRJT05TLkZPUkNFX0lOSVQpO1xuXG4gIHJldHVybiBncm91cDtcbn1cblxuXG53YWxrZXJzLl9oYW5kbGVNb3VudFRleHQgPSBmdW5jdGlvbihjdXJzb3IsIGFzdFRleHQpe1xuICAgIHZhciBub2RlLCBtb3VudE5vZGUgPSBjdXJzb3Iubm9kZTtcbiAgICAvLyBmaXggdW51c2VkIGJsYWNrIGluIGFzdFRleHQ7XG4gICAgdmFyIG5vZGVUZXh0ID0gZG9tLnRleHQobW91bnROb2RlKTtcblxuICAgIGlmKCBub2RlVGV4dCA9PT0gYXN0VGV4dCApe1xuICAgICAgbm9kZSA9IG1vdW50Tm9kZTtcbiAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgfWVsc2V7XG4gICAgICAvLyBtYXliZSBoYXZlIHNvbWUgcmVkdW5kYW5jeSAgYmxhbmtcbiAgICAgIHZhciBpbmRleCA9IG5vZGVUZXh0LmluZGV4T2YoYXN0VGV4dCk7XG4gICAgICBpZih+aW5kZXgpe1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXN0VGV4dCk7XG4gICAgICAgIGRvbS50ZXh0KCBtb3VudE5vZGUsIG5vZGVUZXh0LnNsaWNlKGluZGV4ICsgYXN0VGV4dC5sZW5ndGgpICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiggXy5ibGFua1JlZy50ZXN0KCBhc3RUZXh0ICkgKXsgfVxuICAgICAgICB0aHJvdyBFcnJvciggTVNHW0VSUk9SLlVOTUFUQ0hFRF9BU1RdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuXG53YWxrZXJzLmV4cHJlc3Npb24gPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpe1xuXG4gIHZhciBjdXJzb3IgPSBvcHRpb25zLmN1cnNvciwgbm9kZSxcbiAgICBtb3VudE5vZGUgPSBjdXJzb3IgJiYgY3Vyc29yLm5vZGU7XG5cbiAgaWYobW91bnROb2RlKXtcbiAgICAvL0BCVUc6IGlmIHNlcnZlciByZW5kZXIgJmd0OyBpbiBFeHByZXNzaW9uIHdpbGwgY2F1c2UgZXJyb3JcbiAgICB2YXIgYXN0VGV4dCA9IF8udG9UZXh0KCB0aGlzLiRnZXQoYXN0KSApO1xuXG4gICAgbm9kZSA9IHdhbGtlcnMuX2hhbmRsZU1vdW50VGV4dChjdXJzb3IsIGFzdFRleHQpO1xuXG4gIH1lbHNle1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgfVxuXG4gIHRoaXMuJHdhdGNoKGFzdCwgZnVuY3Rpb24obmV3dmFsKXtcbiAgICBkb20udGV4dChub2RlLCBfLnRvVGV4dChuZXd2YWwpKTtcbiAgfSwgT1BUSU9OUy5TVEFCTEVfSU5JVCApXG4gIHJldHVybiBub2RlO1xuXG59XG5cblxud2Fsa2Vycy50ZXh0ID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKXtcbiAgdmFyIGN1cnNvciA9IG9wdGlvbnMuY3Vyc29yICwgbm9kZTtcbiAgdmFyIHRleHQgPSBhc3QudGV4dDtcbiAgdmFyIGFzdFRleHQgPSB0ZXh0LmluZGV4T2YoJyYnKSAhPT0gLTE/IF8uY29udmVydEVudGl0eSh0ZXh0KTogdGV4dDtcblxuICBpZihjdXJzb3IgJiYgY3Vyc29yLm5vZGUpIHsgXG4gICAgdmFyIG1vdW50Tm9kZSA9IGN1cnNvci5ub2RlO1xuICAgIC8vIG1heWJlIHJlZ3VsYXJqcyBwYXJzZXIgaGF2ZSBzb21lIGRpZmZlcmVuY2Ugd2l0aCBodG1sIGJ1aWx0aW4gcGFyc2VyIHdoZW4gcHJvY2VzcyAgZW1wdHkgdGV4dFxuICAgIC8vIEB0b2RvIGVycm9yIHJlcG9ydFxuICAgIGlmKG1vdW50Tm9kZS5ub2RlVHlwZSAhPT0gMyApe1xuXG4gICAgICBpZiggXy5ibGFua1JlZy50ZXN0KGFzdFRleHQpICkgcmV0dXJuIHtcbiAgICAgICAgY29kZTogIEVSUk9SLlVOTUFUQ0hFRF9BU1RcbiAgICAgIH1cblxuICAgIH1lbHNle1xuICAgICAgbm9kZSA9IHdhbGtlcnMuX2hhbmRsZU1vdW50VGV4dCggY3Vyc29yLCBhc3RUZXh0IClcbiAgICB9IFxuICB9XG4gICAgICBcblxuICByZXR1cm4gbm9kZSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggYXN0VGV4dCApO1xufVxuXG5cblxuXG4vKipcbiAqIHdhbGtlcnMgZWxlbWVudCAoY29udGFpbnMgY29tcG9uZW50KVxuICovXG53YWxrZXJzLmVsZW1lbnQgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpe1xuXG4gIHZhciBhdHRycyA9IGFzdC5hdHRycywgc2VsZiA9IHRoaXMsXG4gICAgQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgIGNoaWxkcmVuID0gYXN0LmNoaWxkcmVuLFxuICAgIG5hbWVzcGFjZSA9IG9wdGlvbnMubmFtZXNwYWNlLCBcbiAgICBleHRyYSA9IG9wdGlvbnMuZXh0cmEsXG4gICAgY3Vyc29yID0gb3B0aW9ucy5jdXJzb3IsXG4gICAgdGFnID0gYXN0LnRhZyxcbiAgICBDb21wb25lbnQgPSBDb25zdHJ1Y3Rvci5jb21wb25lbnQodGFnKSxcbiAgICByZWYsIGdyb3VwLCBlbGVtZW50LCBtb3VudE5vZGU7XG5cbiAgLy8gaWYgaW5pdGl0YWxpemVkIHdpdGggbW91bnQgbW9kZSwgc29tZXRpbWUsIFxuICAvLyBicm93c2VyIHdpbGwgaWdub3JlIHRoZSB3aGl0ZXNwYWNlIGJldHdlZW4gbm9kZSwgYW5kIHNvbWV0aW1lcyBpdCB3b24ndFxuICBpZihjdXJzb3Ipe1xuICAgIC8vIHRleHRDT250ZW50IHdpdGggRW1wdHkgdGV4dFxuICAgIGlmKGN1cnNvci5ub2RlICYmIGN1cnNvci5ub2RlLm5vZGVUeXBlID09PSAzKXtcbiAgICAgIGlmKF8uYmxhbmtSZWcudGVzdChkb20udGV4dChjdXJzb3Iubm9kZSkgKSApIGN1cnNvci5uZXh0KCk7XG4gICAgICBlbHNlIHRocm93IEVycm9yKE1TR1tFUlJPUi5VTk1BVENIRURfQVNUXSk7XG4gICAgfVxuICB9XG5cbiAgaWYoY3Vyc29yKSBtb3VudE5vZGUgPSBjdXJzb3Iubm9kZTtcblxuICBpZiggdGFnID09PSAnci1jb250ZW50JyApe1xuICAgIF8ubG9nKCdyLWNvbnRlbnQgaXMgZGVwcmVjYXRlZCwgdXNlIHsjaW5jIHRoaXMuJGJvZHl9IGluc3RlYWQgKGB7I2luY2x1ZGV9YCBhcyBzYW1lKScsICd3YXJuJyk7XG4gICAgcmV0dXJuIHRoaXMuJGJvZHkgJiYgdGhpcy4kYm9keShjdXJzb3I/IHtjdXJzb3I6IGN1cnNvcn06IG51bGwpO1xuICB9IFxuXG4gIGlmKENvbXBvbmVudCB8fCB0YWcgPT09ICdyLWNvbXBvbmVudCcpe1xuICAgIG9wdGlvbnMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIHJldHVybiB3YWxrZXJzLmNvbXBvbmVudC5jYWxsKHRoaXMsIGFzdCwgb3B0aW9ucylcbiAgfVxuXG4gIGlmKHRhZyA9PT0gJ3N2ZycpIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gIC8vIEBEZXByZWNhdGVkOiBtYXkgYmUgcmVtb3ZlZCBpbiBuZXh0IHZlcnNpb24sIHVzZSB7I2luYyB9IGluc3RlYWRcbiAgXG4gIGlmKCBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggKXtcblxuICAgIHZhciBzdWJNb3VudE5vZGUgPSBtb3VudE5vZGU/IG1vdW50Tm9kZS5maXJzdENoaWxkOiBudWxsO1xuICAgIGdyb3VwID0gdGhpcy4kY29tcGlsZShjaGlsZHJlbiwge1xuICAgICAgZXh0cmE6IGV4dHJhICxcbiAgICAgIG91dGVyOiBvcHRpb25zLm91dGVyLFxuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIFxuICAgICAgY3Vyc29yOiAgc3ViTW91bnROb2RlPyBub2RlQ3Vyc29yKHN1Yk1vdW50Tm9kZSk6IG51bGxcbiAgICB9KTtcbiAgfVxuXG5cbiAgaWYobW91bnROb2RlKXtcbiAgICBlbGVtZW50ID0gbW91bnROb2RlXG4gICAgY3Vyc29yLm5leHQoKTtcbiAgfWVsc2V7XG4gICAgZWxlbWVudCA9IGRvbS5jcmVhdGUoIHRhZywgbmFtZXNwYWNlLCBhdHRycyk7XG4gIH1cbiAgXG5cbiAgaWYoZ3JvdXAgJiYgIV8uaXNWb2lkVGFnKHRhZykgKXsgLy8gaWYgbm90IGluaXQgd2l0aCBtb3VudCBtb2RlXG4gICAgYW5pbWF0ZS5pbmplY3QoIGNvbWJpbmUubm9kZShncm91cCkgLCBlbGVtZW50KVxuICB9XG5cbiAgLy8gZml4IHRhZyBhc3QsIHNvbWUgaW5mb21hdGlvbiBvbmx5IGF2YWxpYWJsZSBhdCBydW50aW1lIChkaXJlY3RpdmUgZXRjLi4pXG4gIF8uZml4VGFnQVNUKGFzdCwgQ29uc3RydWN0b3IpXG5cbiAgdmFyIGRlc3Ryb2llcyA9IHdhbGtBdHRyaWJ1dGVzLmNhbGwodGhpcywgYXR0cnMsIGVsZW1lbnQsIGV4dHJhKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIGdyb3VwOiBncm91cCxcbiAgICBub2RlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbihmaXJzdCl7XG4gICAgICBpZiggZmlyc3QgKXtcbiAgICAgICAgYW5pbWF0ZS5yZW1vdmUoIGVsZW1lbnQsIGdyb3VwPyBncm91cC5kZXN0cm95LmJpbmQoIGdyb3VwICk6IF8ubm9vcCApO1xuICAgICAgfWVsc2UgaWYoZ3JvdXApIHtcbiAgICAgICAgZ3JvdXAuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgLy8gZGVzdHJveSByZWZcbiAgICAgIGlmKCBkZXN0cm9pZXMubGVuZ3RoICkge1xuICAgICAgICBkZXN0cm9pZXMuZm9yRWFjaChmdW5jdGlvbiggZGVzdHJveSApe1xuICAgICAgICAgIGlmKCBkZXN0cm95ICl7XG4gICAgICAgICAgICBpZiggdHlwZW9mIGRlc3Ryb3kuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJyApe1xuICAgICAgICAgICAgICBkZXN0cm95LmRlc3Ryb3koKVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbndhbGtlcnMuY29tcG9uZW50ID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKXtcbiAgdmFyIGF0dHJzID0gYXN0LmF0dHJzLCBcbiAgICBDb21wb25lbnQgPSBvcHRpb25zLkNvbXBvbmVudCxcbiAgICBjdXJzb3IgPSBvcHRpb25zLmN1cnNvcixcbiAgICBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3IsXG4gICAgaXNvbGF0ZSwgXG4gICAgZXh0cmEgPSBvcHRpb25zLmV4dHJhLFxuICAgIG5hbWVzcGFjZSA9IG9wdGlvbnMubmFtZXNwYWNlLFxuICAgIHJlZkRpcmVjdGl2ZSA9IHdhbGtlcnMuUmVndWxhci5kaXJlY3RpdmUoJ3JlZicpLFxuICAgIHJlZiwgc2VsZiA9IHRoaXMsIGlzO1xuXG4gIHZhciBkYXRhID0ge30sIGV2ZW50cztcblxuICBmb3IodmFyIGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAvLyBjb25zaWRlciBkaXNhYmxlZCAgIGVxdWxhc3RvICBkaXNhYmxlZD17dHJ1ZX1cblxuICAgIHNoYXJlZC5wcmVwYXJlQXR0ciggYXR0ciwgYXR0ci5uYW1lID09PSAncmVmJyAmJiByZWZEaXJlY3RpdmUgKTtcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuX3RvdWNoRXhwcihhdHRyLnZhbHVlID09PSB1bmRlZmluZWQ/IHRydWU6IGF0dHIudmFsdWUpO1xuICAgIGlmKHZhbHVlLmNvbnN0YW50KSB2YWx1ZSA9IGF0dHIudmFsdWUgPSB2YWx1ZS5nZXQodGhpcyk7XG4gICAgaWYoYXR0ci52YWx1ZSAmJiBhdHRyLnZhbHVlLmNvbnN0YW50ID09PSB0cnVlKXtcbiAgICAgIHZhbHVlID0gdmFsdWUuZ2V0KHRoaXMpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGF0dHIubmFtZTtcbiAgICBpZighYXR0ci5ldmVudCl7XG4gICAgICB2YXIgZXRlc3QgPSBuYW1lLm1hdGNoKF8uZXZlbnRSZWcpO1xuICAgICAgLy8gZXZlbnQ6ICduYXYnXG4gICAgICBpZihldGVzdCkgYXR0ci5ldmVudCA9IGV0ZXN0WzFdO1xuICAgIH1cblxuICAgIC8vIEBjb21waWxlIG1vZGlmaWVyXG4gICAgaWYoYXR0ci5tZGYgPT09ICdjbXBsJyl7XG4gICAgICB2YWx1ZSA9IF8uZ2V0Q29tcGlsZUZuKHZhbHVlLCB0aGlzLCB7XG4gICAgICAgIHJlY29yZDogdHJ1ZSwgXG4gICAgICAgIG5hbWVzcGFjZTpuYW1lc3BhY2UsIFxuICAgICAgICBleHRyYTogZXh0cmEsIFxuICAgICAgICBvdXRlcjogb3B0aW9ucy5vdXRlclxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gQGlmIGlzIHItY29tcG9uZW50IC4gd2UgbmVlZCB0byBmaW5kIHRoZSB0YXJnZXQgQ29tcG9uZW50XG4gICAgaWYobmFtZSA9PT0gJ2lzJyAmJiAhQ29tcG9uZW50KXtcbiAgICAgIGlzID0gdmFsdWU7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuJGdldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICBDb21wb25lbnQgPSBDb25zdHJ1Y3Rvci5jb21wb25lbnQoY29tcG9uZW50TmFtZSlcbiAgICAgIGlmKHR5cGVvZiBDb21wb25lbnQgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImNvbXBvbmVudCBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiBoYXMgbm90IHJlZ2lzdGVkIVwiKTtcbiAgICB9XG4gICAgLy8gYmluZCBldmVudCBwcm94eVxuICAgIHZhciBldmVudE5hbWU7XG4gICAgaWYoZXZlbnROYW1lID0gYXR0ci5ldmVudCl7XG4gICAgICBldmVudHMgPSBldmVudHMgfHwge307XG4gICAgICBldmVudHNbZXZlbnROYW1lXSA9IF8uaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCB2YWx1ZSwgZXZlbnROYW1lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1lbHNlIHtcbiAgICAgIG5hbWUgPSBhdHRyLm5hbWUgPSBfLmNhbWVsQ2FzZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZighdmFsdWUgfHwgdmFsdWUudHlwZSAhPT0gJ2V4cHJlc3Npb24nKXtcbiAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZTtcbiAgICB9ZWxzZXtcbiAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZS5nZXQoc2VsZik7IFxuICAgIH1cbiAgICBpZiggbmFtZSA9PT0gJ3JlZicgICYmIHZhbHVlICE9IG51bGwpe1xuICAgICAgcmVmID0gdmFsdWVcbiAgICB9XG4gICAgaWYoIG5hbWUgPT09ICdpc29sYXRlJyl7XG4gICAgICAvLyAxOiBzdG9wOiBjb21wb3NpdGUgLT4gcGFyZW50XG4gICAgICAvLyAyLiBzdG9wOiBjb21wb3NpdGUgPC0gcGFyZW50XG4gICAgICAvLyAzLiBzdG9wIDEgYW5kIDI6IGNvbXBvc2l0ZSA8LT4gcGFyZW50XG4gICAgICAvLyAwLiBzdG9wIG5vdGhpbmcgKGRlZnVhbHQpXG4gICAgICBpc29sYXRlID0gdmFsdWUudHlwZSA9PT0gJ2V4cHJlc3Npb24nPyB2YWx1ZS5nZXQoc2VsZik6IHBhcnNlSW50KHZhbHVlID09PSB0cnVlPyAzOiB2YWx1ZSwgMTApO1xuICAgICAgZGF0YS5pc29sYXRlID0gaXNvbGF0ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmaW5pdGlvbiA9IHsgXG4gICAgZGF0YTogZGF0YSwgXG4gICAgZXZlbnRzOiBldmVudHMsIFxuICAgICRwYXJlbnQ6IChpc29sYXRlICYgMik/IG51bGw6IHRoaXMsXG4gICAgJHJvb3Q6IHRoaXMuJHJvb3QsXG4gICAgJG91dGVyOiBvcHRpb25zLm91dGVyLFxuICAgIF9ib2R5OiB7XG4gICAgICBjdHg6IHRoaXMsXG4gICAgICBhc3Q6IGFzdC5jaGlsZHJlblxuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgXG4gICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgZXh0cmE6IG9wdGlvbnMuZXh0cmFcbiAgfVxuXG5cbiAgdmFyIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoZGVmaW5pdGlvbiwgb3B0aW9ucyksIHJlZmxpbms7XG5cblxuICBpZihyZWYgJiYgdGhpcy4kcmVmcyl7XG4gICAgcmVmbGluayA9IHJlZkRpcmVjdGl2ZS5saW5rO1xuICAgIHZhciByZWZEZXN0cm95ID0gcmVmbGluay5jYWxsKHRoaXMsIGNvbXBvbmVudCwgcmVmKTtcbiAgICBjb21wb25lbnQuJG9uKCckZGVzdHJveScsIHJlZkRlc3Ryb3kpO1xuICB9XG4gIGZvcih2YXIgaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWV8fHRydWU7XG4gICAgdmFyIG5hbWUgPSBhdHRyLm5hbWU7XG4gICAgLy8gbmVlZCBjb21waWxlZFxuICAgIGlmKHZhbHVlLnR5cGUgPT09ICdleHByZXNzaW9uJyAmJiAhYXR0ci5ldmVudCl7XG4gICAgICB2YWx1ZSA9IHNlbGYuX3RvdWNoRXhwcih2YWx1ZSk7XG4gICAgICAvLyB1c2UgYml0IG9wZXJhdGUgdG8gY29udHJvbCBzY29wZVxuICAgICAgaWYoICEoaXNvbGF0ZSAmIDIpICkgXG4gICAgICAgIHRoaXMuJHdhdGNoKHZhbHVlLCAoZnVuY3Rpb24obmFtZSwgdmFsKXtcbiAgICAgICAgICB0aGlzLmRhdGFbbmFtZV0gPSB2YWw7XG4gICAgICAgIH0pLmJpbmQoY29tcG9uZW50LCBuYW1lKSwgT1BUSU9OUy5TWU5DKVxuICAgICAgaWYoIHZhbHVlLnNldCAmJiAhKGlzb2xhdGUgJiAxICkgKSBcbiAgICAgICAgLy8gc3luYyB0aGUgZGF0YS4gaXQgZm9yY2UgdGhlIGNvbXBvbmVudCBkb24ndCB0cmlnZ2VyIGF0dHIubmFtZSdzIGZpcnN0IGRpcnR5IGVjaGVja1xuICAgICAgICBjb21wb25lbnQuJHdhdGNoKG5hbWUsIHNlbGYuJHVwZGF0ZS5iaW5kKHNlbGYsIHZhbHVlKSwgT1BUSU9OUy5JTklUKTtcbiAgICB9XG4gIH1cbiAgaWYoaXMgJiYgaXMudHlwZSA9PT0gJ2V4cHJlc3Npb24nICApe1xuICAgIHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgIGdyb3VwLnB1c2goY29tcG9uZW50KTtcbiAgICB0aGlzLiR3YXRjaChpcywgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgLy8gZm91bmQgdGhlIG5ldyBjb21wb25lbnRcbiAgICAgIHZhciBDb21wb25lbnQgPSBDb25zdHJ1Y3Rvci5jb21wb25lbnQodmFsdWUpO1xuICAgICAgaWYoIUNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKFwiY29tcG9uZW50IFwiICsgdmFsdWUgKyBcIiBoYXMgbm90IHJlZ2lzdGVkIVwiKTtcbiAgICAgIHZhciBuY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChkZWZpbml0aW9uKTtcbiAgICAgIHZhciBjb21wb25lbnQgPSBncm91cC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIGdyb3VwLnB1c2gobmNvbXBvbmVudCk7XG4gICAgICBuY29tcG9uZW50LiRpbmplY3QoY29tYmluZS5sYXN0KGNvbXBvbmVudCksICdhZnRlcicpXG4gICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgLy8gQFRPRE8gIGlmIGNvbXBvbmVudCBjaGFuZ2VkICwgd2UgbmVlZCB1cGRhdGUgcmVmXG4gICAgICBpZihyZWYpe1xuICAgICAgICBzZWxmLiRyZWZzW3JlZl0gPSBuY29tcG9uZW50O1xuICAgICAgfVxuICAgIH0sIE9QVElPTlMuU1lOQylcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gd2Fsa0F0dHJpYnV0ZXMoYXR0cnMsIGVsZW1lbnQsIGV4dHJhKXtcbiAgdmFyIGJpbmRpbmdzID0gW11cbiAgZm9yKHZhciBpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgIHZhciBiaW5kaW5nID0gdGhpcy5fd2FsayhhdHRyc1tpXSwge2VsZW1lbnQ6IGVsZW1lbnQsIGZyb21FbGVtZW50OiB0cnVlLCBhdHRyczogYXR0cnMsIGV4dHJhOiBleHRyYX0pXG4gICAgaWYoYmluZGluZykgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgfVxuICByZXR1cm4gYmluZGluZ3M7XG59XG5cblxud2Fsa2Vycy5hdHRyaWJ1dGUgPSBmdW5jdGlvbihhc3QgLG9wdGlvbnMpe1xuXG4gIHZhciBhdHRyID0gYXN0O1xuICB2YXIgQ29tcG9uZW50ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgdmFyIG5hbWUgPSBhdHRyLm5hbWU7XG4gIHZhciBkaXJlY3RpdmUgPSBDb21wb25lbnQuZGlyZWN0aXZlKG5hbWUpO1xuXG4gIHNoYXJlZC5wcmVwYXJlQXR0cihhc3QsIGRpcmVjdGl2ZSk7XG5cbiAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZSB8fCBcIlwiO1xuICB2YXIgY29uc3RhbnQgPSB2YWx1ZS5jb25zdGFudDtcbiAgdmFyIGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gIHZhciBzZWxmID0gdGhpcztcblxuXG5cbiAgdmFsdWUgPSB0aGlzLl90b3VjaEV4cHIodmFsdWUpO1xuXG4gIGlmKGNvbnN0YW50KSB2YWx1ZSA9IHZhbHVlLmdldCh0aGlzKTtcblxuICBpZihkaXJlY3RpdmUgJiYgZGlyZWN0aXZlLmxpbmspe1xuICAgIHZhciBleHRyYSA9IHtcbiAgICAgIGF0dHJzOiBvcHRpb25zLmF0dHJzLFxuICAgICAgcGFyYW06IF8uZ2V0UGFyYW1PYmoodGhpcywgYXR0ci5wYXJhbSkgXG4gICAgfVxuICAgIHZhciBiaW5kaW5nID0gZGlyZWN0aXZlLmxpbmsuY2FsbChzZWxmLCBlbGVtZW50LCB2YWx1ZSwgbmFtZSwgZXh0cmEpO1xuICAgIC8vIGlmIHVwZGF0ZSBoYXMgYmVlbiBwYXNzZWQgaW4gLCB3ZSB3aWxsICBhdXRvbWF0ZWx5IHdhdGNoIHZhbHVlIGZvciB1c2VyXG4gICAgaWYoIHR5cGVvZiBkaXJlY3RpdmUudXBkYXRlID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGlmKF8uaXNFeHByKHZhbHVlKSl7XG4gICAgICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbih2YWwsIG9sZCl7XG4gICAgICAgICAgZGlyZWN0aXZlLnVwZGF0ZS5jYWxsKHNlbGYsIGVsZW1lbnQsIHZhbCwgb2xkLCBleHRyYSk7IFxuICAgICAgICB9KVxuICAgICAgfWVsc2V7XG4gICAgICAgIGRpcmVjdGl2ZS51cGRhdGUuY2FsbChzZWxmLCBlbGVtZW50LCB2YWx1ZSwgdW5kZWZpbmVkLCBleHRyYSApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZih0eXBlb2YgYmluZGluZyA9PT0gJ2Z1bmN0aW9uJykgYmluZGluZyA9IHtkZXN0cm95OiBiaW5kaW5nfTsgXG4gICAgcmV0dXJuIGJpbmRpbmc7XG4gIH0gZWxzZXtcbiAgICBpZih2YWx1ZS50eXBlID09PSAnZXhwcmVzc2lvbicgKXtcbiAgICAgIHRoaXMuJHdhdGNoKHZhbHVlLCBmdW5jdGlvbihudmFsdWUsIG9sZCl7XG4gICAgICAgIGRvbS5hdHRyKGVsZW1lbnQsIG5hbWUsIG52YWx1ZSk7XG4gICAgICB9LCBPUFRJT05TLlNUQUJMRV9JTklUKTtcbiAgICB9ZWxzZXtcbiAgICAgIGlmKF8uaXNCb29sZWFuQXR0cihuYW1lKSl7XG4gICAgICAgIGRvbS5hdHRyKGVsZW1lbnQsIG5hbWUsIHRydWUpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGRvbS5hdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoIW9wdGlvbnMuZnJvbUVsZW1lbnQpe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgICBkb20uYXR0cihlbGVtZW50LCBuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cblxuIiwiLyohXG4gICogUmVxd2VzdCEgQSBnZW5lcmFsIHB1cnBvc2UgWEhSIGNvbm5lY3Rpb24gbWFuYWdlclxuICAqIGxpY2Vuc2UgTUlUIChjKSBEdXN0aW4gRGlheiAyMDE1XG4gICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9yZXF3ZXN0XG4gICovXG5cbiFmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0oJ3JlcXdlc3QnLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGNvbnRleHQgPSB0aGlzXG5cbiAgaWYgKCd3aW5kb3cnIGluIGNvbnRleHQpIHtcbiAgICB2YXIgZG9jID0gZG9jdW1lbnRcbiAgICAgICwgYnlUYWcgPSAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnXG4gICAgICAsIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF1cbiAgfSBlbHNlIHtcbiAgICB2YXIgWEhSMlxuICAgIHRyeSB7XG4gICAgICBYSFIyID0gcmVxdWlyZSgneGhyMicpXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGVlciBkZXBlbmRlbmN5IGB4aHIyYCByZXF1aXJlZCEgUGxlYXNlIG5wbSBpbnN0YWxsIHhocjInKVxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIGh0dHBzUmUgPSAvXmh0dHAvXG4gICAgLCBwcm90b2NvbFJlID0gLyheXFx3Kyk6XFwvXFwvL1xuICAgICwgdHdvSHVuZG8gPSAvXigyMFxcZHwxMjIzKSQvIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gICAgLCByZWFkeVN0YXRlID0gJ3JlYWR5U3RhdGUnXG4gICAgLCBjb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnXG4gICAgLCByZXF1ZXN0ZWRXaXRoID0gJ1gtUmVxdWVzdGVkLVdpdGgnXG4gICAgLCB1bmlxaWQgPSAwXG4gICAgLCBjYWxsYmFja1ByZWZpeCA9ICdyZXF3ZXN0XycgKyAoK25ldyBEYXRlKCkpXG4gICAgLCBsYXN0VmFsdWUgLy8gZGF0YSBzdG9yZWQgYnkgdGhlIG1vc3QgcmVjZW50IEpTT05QIGNhbGxiYWNrXG4gICAgLCB4bWxIdHRwUmVxdWVzdCA9ICdYTUxIdHRwUmVxdWVzdCdcbiAgICAsIHhEb21haW5SZXF1ZXN0ID0gJ1hEb21haW5SZXF1ZXN0J1xuICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgICAsIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gQXJyYXkuaXNBcnJheVxuICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgfVxuXG4gICAgLCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICAgICAnY29udGVudFR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAsICdyZXF1ZXN0ZWRXaXRoJzogeG1sSHR0cFJlcXVlc3RcbiAgICAgICAgLCAnYWNjZXB0Jzoge1xuICAgICAgICAgICAgICAnKic6ICAndGV4dC9qYXZhc2NyaXB0LCB0ZXh0L2h0bWwsIGFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwsICovKidcbiAgICAgICAgICAgICwgJ3htbCc6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCdcbiAgICAgICAgICAgICwgJ2h0bWwnOiAndGV4dC9odG1sJ1xuICAgICAgICAgICAgLCAndGV4dCc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgLCAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICAsICdqcyc6ICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQsIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsIHhociA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgLy8gaXMgaXQgeC1kb21haW5cbiAgICAgICAgaWYgKG9bJ2Nyb3NzT3JpZ2luJ10gPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgeGhyID0gY29udGV4dFt4bWxIdHRwUmVxdWVzdF0gPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG51bGxcbiAgICAgICAgICBpZiAoeGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgcmV0dXJuIHhoclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFt4RG9tYWluUmVxdWVzdF0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0W3htbEh0dHBSZXF1ZXN0XSkge1xuICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9IGVsc2UgaWYgKFhIUjIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFhIUjIoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCBnbG9iYWxTZXR1cE9wdGlvbnMgPSB7XG4gICAgICAgIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIGZ1bmN0aW9uIHN1Y2NlZWQocikge1xuICAgIHZhciBwcm90b2NvbCA9IHByb3RvY29sUmUuZXhlYyhyLnVybClcbiAgICBwcm90b2NvbCA9IChwcm90b2NvbCAmJiBwcm90b2NvbFsxXSkgfHwgY29udGV4dC5sb2NhdGlvbi5wcm90b2NvbFxuICAgIHJldHVybiBodHRwc1JlLnRlc3QocHJvdG9jb2wpID8gdHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSA6ICEhci5yZXF1ZXN0LnJlc3BvbnNlXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZWFkeVN0YXRlKHIsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHVzZSBfYWJvcnRlZCB0byBtaXRpZ2F0ZSBhZ2FpbnN0IElFIGVyciBjMDBjMDIzZlxuICAgICAgLy8gKGNhbid0IHJlYWQgcHJvcHMgb24gYWJvcnRlZCByZXF1ZXN0IG9iamVjdHMpXG4gICAgICBpZiAoci5fYWJvcnRlZCkgcmV0dXJuIGVycm9yKHIucmVxdWVzdClcbiAgICAgIGlmIChyLl90aW1lZE91dCkgcmV0dXJuIGVycm9yKHIucmVxdWVzdCwgJ1JlcXVlc3QgaXMgYWJvcnRlZDogdGltZW91dCcpXG4gICAgICBpZiAoci5yZXF1ZXN0ICYmIHIucmVxdWVzdFtyZWFkeVN0YXRlXSA9PSA0KSB7XG4gICAgICAgIHIucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBub29wXG4gICAgICAgIGlmIChzdWNjZWVkKHIpKSBzdWNjZXNzKHIucmVxdWVzdClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVycm9yKHIucmVxdWVzdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRIZWFkZXJzKGh0dHAsIG8pIHtcbiAgICB2YXIgaGVhZGVycyA9IG9bJ2hlYWRlcnMnXSB8fCB7fVxuICAgICAgLCBoXG5cbiAgICBoZWFkZXJzWydBY2NlcHQnXSA9IGhlYWRlcnNbJ0FjY2VwdCddXG4gICAgICB8fCBkZWZhdWx0SGVhZGVyc1snYWNjZXB0J11bb1sndHlwZSddXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddWycqJ11cblxuICAgIHZhciBpc0FGb3JtRGF0YSA9IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgKG9bJ2RhdGEnXSBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbiAgICAvLyBicmVha3MgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIHdpdGggbGVnYWN5IGJyb3dzZXJzXG4gICAgaWYgKCFvWydjcm9zc09yaWdpbiddICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnNbJ3JlcXVlc3RlZFdpdGgnXVxuICAgIGlmICghaGVhZGVyc1tjb250ZW50VHlwZV0gJiYgIWlzQUZvcm1EYXRhKSBoZWFkZXJzW2NvbnRlbnRUeXBlXSA9IG9bJ2NvbnRlbnRUeXBlJ10gfHwgZGVmYXVsdEhlYWRlcnNbJ2NvbnRlbnRUeXBlJ11cbiAgICBmb3IgKGggaW4gaGVhZGVycylcbiAgICAgIGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaCkgJiYgJ3NldFJlcXVlc3RIZWFkZXInIGluIGh0dHAgJiYgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDcmVkZW50aWFscyhodHRwLCBvKSB7XG4gICAgaWYgKHR5cGVvZiBvWyd3aXRoQ3JlZGVudGlhbHMnXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGh0dHAud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaHR0cC53aXRoQ3JlZGVudGlhbHMgPSAhIW9bJ3dpdGhDcmVkZW50aWFscyddXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhbENhbGxiYWNrKGRhdGEpIHtcbiAgICBsYXN0VmFsdWUgPSBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiB1cmxhcHBlbmQgKHVybCwgcykge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybCkge1xuICAgIHZhciByZXFJZCA9IHVuaXFpZCsrXG4gICAgICAsIGNia2V5ID0gb1snanNvbnBDYWxsYmFjayddIHx8ICdjYWxsYmFjaycgLy8gdGhlICdjYWxsYmFjaycga2V5XG4gICAgICAsIGNidmFsID0gb1snanNvbnBDYWxsYmFja05hbWUnXSB8fCByZXF3ZXN0LmdldGNhbGxiYWNrUHJlZml4KHJlcUlkKVxuICAgICAgLCBjYnJlZyA9IG5ldyBSZWdFeHAoJygoXnxcXFxcP3wmKScgKyBjYmtleSArICcpPShbXiZdKyknKVxuICAgICAgLCBtYXRjaCA9IHVybC5tYXRjaChjYnJlZylcbiAgICAgICwgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAsIGxvYWRlZCA9IDBcbiAgICAgICwgaXNJRTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFIDEwLjAnKSAhPT0gLTFcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgaWYgKG1hdGNoWzNdID09PSAnPycpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoY2JyZWcsICckMT0nICsgY2J2YWwpIC8vIHdpbGRjYXJkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2J2YWwgPSBtYXRjaFszXSAvLyBwcm92aWRlZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgY2JrZXkgKyAnPScgKyBjYnZhbCkgLy8gbm8gY2FsbGJhY2sgZGV0YWlscywgYWRkICdlbVxuICAgIH1cblxuICAgIGNvbnRleHRbY2J2YWxdID0gZ2VuZXJhbENhbGxiYWNrXG5cbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgc2NyaXB0LnNyYyA9IHVybFxuICAgIHNjcmlwdC5hc3luYyA9IHRydWVcbiAgICBpZiAodHlwZW9mIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgIT09ICd1bmRlZmluZWQnICYmICFpc0lFMTApIHtcbiAgICAgIC8vIG5lZWQgdGhpcyBmb3IgSUUgZHVlIHRvIG91dC1vZi1vcmRlciBvbnJlYWR5c3RhdGVjaGFuZ2UoKSwgYmluZGluZyBzY3JpcHRcbiAgICAgIC8vIGV4ZWN1dGlvbiB0byBhbiBldmVudCBsaXN0ZW5lciBnaXZlcyB1cyBjb250cm9sIG92ZXIgd2hlbiB0aGUgc2NyaXB0XG4gICAgICAvLyBpcyBleGVjdXRlZC4gU2VlIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQgPSAnX3JlcXdlc3RfJyArIHJlcUlkXG4gICAgfVxuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKHNjcmlwdFtyZWFkeVN0YXRlXSAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdjb21wbGV0ZScgJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnbG9hZGVkJykgfHwgbG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICBzY3JpcHQub25jbGljayAmJiBzY3JpcHQub25jbGljaygpXG4gICAgICAvLyBDYWxsIHRoZSB1c2VyIGNhbGxiYWNrIHdpdGggdGhlIGxhc3QgdmFsdWUgc3RvcmVkIGFuZCBjbGVhbiB1cCB2YWx1ZXMgYW5kIHNjcmlwdHMuXG4gICAgICBmbihsYXN0VmFsdWUpXG4gICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgbG9hZGVkID0gMVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgc2NyaXB0IHRvIHRoZSBET00gaGVhZFxuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXG4gICAgLy8gRW5hYmxlIEpTT05QIHRpbWVvdXRcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIGVycih7fSwgJ1JlcXVlc3QgaXMgYWJvcnRlZDogdGltZW91dCcsIHt9KVxuICAgICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgICAgIGxvYWRlZCA9IDFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXF1ZXN0KGZuLCBlcnIpIHtcbiAgICB2YXIgbyA9IHRoaXMub1xuICAgICAgLCBtZXRob2QgPSAob1snbWV0aG9kJ10gfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKClcbiAgICAgICwgdXJsID0gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG9bJ3VybCddXG4gICAgICAvLyBjb252ZXJ0IG5vbi1zdHJpbmcgb2JqZWN0cyB0byBxdWVyeS1zdHJpbmcgZm9ybSB1bmxlc3Mgb1sncHJvY2Vzc0RhdGEnXSBpcyBmYWxzZVxuICAgICAgLCBkYXRhID0gKG9bJ3Byb2Nlc3NEYXRhJ10gIT09IGZhbHNlICYmIG9bJ2RhdGEnXSAmJiB0eXBlb2Ygb1snZGF0YSddICE9PSAnc3RyaW5nJylcbiAgICAgICAgPyByZXF3ZXN0LnRvUXVlcnlTdHJpbmcob1snZGF0YSddKVxuICAgICAgICA6IChvWydkYXRhJ10gfHwgbnVsbClcbiAgICAgICwgaHR0cFxuICAgICAgLCBzZW5kV2FpdCA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSdyZSB3b3JraW5nIG9uIGEgR0VUIHJlcXVlc3QgYW5kIHdlIGhhdmUgZGF0YSB0aGVuIHdlIHNob3VsZCBhcHBlbmRcbiAgICAvLyBxdWVyeSBzdHJpbmcgdG8gZW5kIG9mIFVSTCBhbmQgbm90IHBvc3QgZGF0YVxuICAgIGlmICgob1sndHlwZSddID09ICdqc29ucCcgfHwgbWV0aG9kID09ICdHRVQnKSAmJiBkYXRhKSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBkYXRhKVxuICAgICAgZGF0YSA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAob1sndHlwZSddID09ICdqc29ucCcpIHJldHVybiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpXG5cbiAgICAvLyBnZXQgdGhlIHhociBmcm9tIHRoZSBmYWN0b3J5IGlmIHBhc3NlZFxuICAgIC8vIGlmIHRoZSBmYWN0b3J5IHJldHVybnMgbnVsbCwgZmFsbC1iYWNrIHRvIG91cnNcbiAgICBodHRwID0gKG8ueGhyICYmIG8ueGhyKG8pKSB8fCB4aHIobylcblxuICAgIGh0dHAub3BlbihtZXRob2QsIHVybCwgb1snYXN5bmMnXSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpXG4gICAgc2V0SGVhZGVycyhodHRwLCBvKVxuICAgIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pXG4gICAgaWYgKGNvbnRleHRbeERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiBjb250ZXh0W3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICBodHRwLm9ubG9hZCA9IGZuXG4gICAgICAgIGh0dHAub25lcnJvciA9IGVyclxuICAgICAgICAvLyBOT1RFOiBzZWVcbiAgICAgICAgLy8gaHR0cDovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL2lld2ViZGV2ZWxvcG1lbnQvdGhyZWFkLzMwZWYzYWRkLTc2N2MtNDQzNi1iOGE5LWYxY2ExOWI0ODEyZVxuICAgICAgICBodHRwLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9XG4gICAgICAgIHNlbmRXYWl0ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZVJlYWR5U3RhdGUodGhpcywgZm4sIGVycilcbiAgICB9XG4gICAgb1snYmVmb3JlJ10gJiYgb1snYmVmb3JlJ10oaHR0cClcbiAgICBpZiAoc2VuZFdhaXQpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICAgIH0sIDIwMClcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cC5zZW5kKGRhdGEpXG4gICAgfVxuICAgIHJldHVybiBodHRwXG4gIH1cblxuICBmdW5jdGlvbiBSZXF3ZXN0KG8sIGZuKSB7XG4gICAgdGhpcy5vID0gb1xuICAgIHRoaXMuZm4gPSBmblxuXG4gICAgaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUeXBlKGhlYWRlcikge1xuICAgIC8vIGpzb24sIGphdmFzY3JpcHQsIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgeG1sXG4gICAgaWYgKGhlYWRlciA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDsgLy9JbiBjYXNlIG9mIG5vIGNvbnRlbnQtdHlwZS5cbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqc29uJykpIHJldHVybiAnanNvbidcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqYXZhc2NyaXB0JykpIHJldHVybiAnanMnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgndGV4dCcpKSByZXR1cm4gJ2h0bWwnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgneG1sJykpIHJldHVybiAneG1sJ1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdChvLCBmbikge1xuXG4gICAgdGhpcy51cmwgPSB0eXBlb2YgbyA9PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcblxuICAgIC8vIHdoZXRoZXIgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQgZm9yIHB1cnBvc2VcbiAgICAvLyBvZiB0cmFja2luZyB0aGUgUHJvbWlzZXNcbiAgICB0aGlzLl9mdWxmaWxsZWQgPSBmYWxzZVxuICAgIC8vIHN1Y2Nlc3MgaGFuZGxlcnNcbiAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uKCl7fVxuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMgPSBbXVxuICAgIC8vIGVycm9yIGhhbmRsZXJzXG4gICAgdGhpcy5fZXJyb3JIYW5kbGVycyA9IFtdXG4gICAgLy8gY29tcGxldGUgKGJvdGggc3VjY2VzcyBhbmQgZmFpbCkgaGFuZGxlcnNcbiAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzID0gW11cbiAgICB0aGlzLl9lcnJlZCA9IGZhbHNlXG4gICAgdGhpcy5fcmVzcG9uc2VBcmdzID0ge31cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgaWYgKG9bJ3RpbWVvdXQnXSkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpbWVkT3V0KClcbiAgICAgIH0sIG9bJ3RpbWVvdXQnXSlcbiAgICB9XG5cbiAgICBpZiAob1snc3VjY2VzcyddKSB7XG4gICAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snc3VjY2VzcyddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob1snZXJyb3InXSkge1xuICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snZXJyb3InXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvWydjb21wbGV0ZSddKSB7XG4gICAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydjb21wbGV0ZSddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUgKHJlc3ApIHtcbiAgICAgIG9bJ3RpbWVvdXQnXSAmJiBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuICAgICAgc2VsZi50aW1lb3V0ID0gbnVsbFxuICAgICAgd2hpbGUgKHNlbGYuX2NvbXBsZXRlSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9jb21wbGV0ZUhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWNjZXNzIChyZXNwKSB7XG4gICAgICB2YXIgdHlwZSA9IG9bJ3R5cGUnXSB8fCByZXNwICYmIHNldFR5cGUocmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykpIC8vIHJlc3AgY2FuIGJlIHVuZGVmaW5lZCBpbiBJRVxuICAgICAgcmVzcCA9ICh0eXBlICE9PSAnanNvbnAnKSA/IHNlbGYucmVxdWVzdCA6IHJlc3BcbiAgICAgIC8vIHVzZSBnbG9iYWwgZGF0YSBmaWx0ZXIgb24gcmVzcG9uc2UgdGV4dFxuICAgICAgdmFyIGZpbHRlcmVkUmVzcG9uc2UgPSBnbG9iYWxTZXR1cE9wdGlvbnMuZGF0YUZpbHRlcihyZXNwLnJlc3BvbnNlVGV4dCwgdHlwZSlcbiAgICAgICAgLCByID0gZmlsdGVyZWRSZXNwb25zZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcC5yZXNwb25zZVRleHQgPSByXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGNhbid0IGFzc2lnbiB0aGlzIGluIElFPD04LCBqdXN0IGlnbm9yZVxuICAgICAgfVxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwID0gY29udGV4dC5KU09OID8gY29udGV4dC5KU09OLnBhcnNlKHIpIDogZXZhbCgnKCcgKyByICsgJyknKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKHJlc3AsICdDb3VsZCBub3QgcGFyc2UgSlNPTiBpbiByZXNwb25zZScsIGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnanMnOlxuICAgICAgICAgIHJlc3AgPSBldmFsKHIpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgcmVzcCA9IHJcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgIHJlc3AgPSByZXNwLnJlc3BvbnNlWE1MXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvciAvLyBJRSB0cm9sb2xvXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5lcnJvckNvZGVcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLnJlYXNvblxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fZnVsZmlsbGVkID0gdHJ1ZVxuICAgICAgZm4ocmVzcClcbiAgICAgIHNlbGYuX3N1Y2Nlc3NIYW5kbGVyKHJlc3ApXG4gICAgICB3aGlsZSAoc2VsZi5fZnVsZmlsbG1lbnRIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3AgPSBzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cblxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lZE91dCgpIHtcbiAgICAgIHNlbGYuX3RpbWVkT3V0ID0gdHJ1ZVxuICAgICAgc2VsZi5yZXF1ZXN0LmFib3J0KClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihyZXNwLCBtc2csIHQpIHtcbiAgICAgIHJlc3AgPSBzZWxmLnJlcXVlc3RcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLm1zZyA9IG1zZ1xuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnQgPSB0XG4gICAgICBzZWxmLl9lcnJlZCA9IHRydWVcbiAgICAgIHdoaWxlIChzZWxmLl9lcnJvckhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fZXJyb3JIYW5kbGVycy5zaGlmdCgpKHJlc3AsIG1zZywgdClcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlKHJlc3ApXG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0ID0gZ2V0UmVxdWVzdC5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9yKVxuICB9XG5cbiAgUmVxd2VzdC5wcm90b3R5cGUgPSB7XG4gICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlXG4gICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKVxuICAgIH1cblxuICAsIHJldHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbml0LmNhbGwodGhpcywgdGhpcy5vLCB0aGlzLmZuKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNtYWxsIGRldmlhdGlvbiBmcm9tIHRoZSBQcm9taXNlcyBBIENvbW1vbkpzIHNwZWNpZmljYXRpb25cbiAgICAgKiBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Qcm9taXNlcy9BXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBgdGhlbmAgd2lsbCBleGVjdXRlIHVwb24gc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICAgICAqL1xuICAsIHRoZW46IGZ1bmN0aW9uIChzdWNjZXNzLCBmYWlsKSB7XG4gICAgICBzdWNjZXNzID0gc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgZmFpbCA9IGZhaWwgfHwgZnVuY3Rpb24gKCkge31cbiAgICAgIGlmICh0aGlzLl9mdWxmaWxsZWQpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AgPSBzdWNjZXNzKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmYWlsKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwLCB0aGlzLl9yZXNwb25zZUFyZ3MubXNnLCB0aGlzLl9yZXNwb25zZUFyZ3MudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMucHVzaChzdWNjZXNzKVxuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZmFpbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGFsd2F5c2Agd2lsbCBleGVjdXRlIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZHMgb3IgZmFpbHNcbiAgICAgKi9cbiAgLCBhbHdheXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCB8fCB0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGZhaWxgIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZSByZXF1ZXN0IGZhaWxzXG4gICAgICovXG4gICwgZmFpbDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZm4odGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICwgJ2NhdGNoJzogZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWlsKGZuKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXdlc3QobywgZm4pIHtcbiAgICByZXR1cm4gbmV3IFJlcXdlc3QobywgZm4pXG4gIH1cblxuICAvLyBub3JtYWxpemUgbmV3bGluZSB2YXJpYW50cyBhY2NvcmRpbmcgdG8gc3BlYyAtPiBDUkxGXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShzKSB7XG4gICAgcmV0dXJuIHMgPyBzLnJlcGxhY2UoL1xccj9cXG4vZywgJ1xcclxcbicpIDogJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcmlhbChlbCwgY2IpIHtcbiAgICB2YXIgbiA9IGVsLm5hbWVcbiAgICAgICwgdCA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgLCBvcHRDYiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgLy8gSUUgZ2l2ZXMgdmFsdWU9XCJcIiBldmVuIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlIGF0dHJpYnV0ZVxuICAgICAgICAgIC8vICdzcGVjaWZpZWQnIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9jb3JlLmh0bWwjSUQtODYyNTI5MjczXG4gICAgICAgICAgaWYgKG8gJiYgIW9bJ2Rpc2FibGVkJ10pXG4gICAgICAgICAgICBjYihuLCBub3JtYWxpemUob1snYXR0cmlidXRlcyddWyd2YWx1ZSddICYmIG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXVsnc3BlY2lmaWVkJ10gPyBvWyd2YWx1ZSddIDogb1sndGV4dCddKSlcbiAgICAgICAgfVxuICAgICAgLCBjaCwgcmEsIHZhbCwgaVxuXG4gICAgLy8gZG9uJ3Qgc2VyaWFsaXplIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FibGVkIG9yIHdpdGhvdXQgYSBuYW1lXG4gICAgaWYgKGVsLmRpc2FibGVkIHx8ICFuKSByZXR1cm5cblxuICAgIHN3aXRjaCAodCkge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGlmICghL3Jlc2V0fGJ1dHRvbnxpbWFnZXxmaWxlL2kudGVzdChlbC50eXBlKSkge1xuICAgICAgICBjaCA9IC9jaGVja2JveC9pLnRlc3QoZWwudHlwZSlcbiAgICAgICAgcmEgPSAvcmFkaW8vaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHZhbCA9IGVsLnZhbHVlXG4gICAgICAgIC8vIFdlYktpdCBnaXZlcyB1cyBcIlwiIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgY2hlY2tib3ggaGFzIG5vIHZhbHVlLCBzbyBjb3JyZWN0IGl0IGhlcmVcbiAgICAgICAgOyghKGNoIHx8IHJhKSB8fCBlbC5jaGVja2VkKSAmJiBjYihuLCBub3JtYWxpemUoY2ggJiYgdmFsID09PSAnJyA/ICdvbicgOiB2YWwpKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBjYihuLCBub3JtYWxpemUoZWwudmFsdWUpKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaWYgKGVsLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdC1vbmUnKSB7XG4gICAgICAgIG9wdENiKGVsLnNlbGVjdGVkSW5kZXggPj0gMCA/IGVsLm9wdGlvbnNbZWwuc2VsZWN0ZWRJbmRleF0gOiBudWxsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgZWwubGVuZ3RoICYmIGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLm9wdGlvbnNbaV0uc2VsZWN0ZWQgJiYgb3B0Q2IoZWwub3B0aW9uc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBjb2xsZWN0IHVwIGFsbCBmb3JtIGVsZW1lbnRzIGZvdW5kIGZyb20gdGhlIHBhc3NlZCBhcmd1bWVudCBlbGVtZW50cyBhbGxcbiAgLy8gdGhlIHdheSBkb3duIHRvIGNoaWxkIGVsZW1lbnRzOyBwYXNzIGEgJzxmb3JtPicgb3IgZm9ybSBmaWVsZHMuXG4gIC8vIGNhbGxlZCB3aXRoICd0aGlzJz1jYWxsYmFjayB0byB1c2UgZm9yIHNlcmlhbCgpIG9uIGVhY2ggZWxlbWVudFxuICBmdW5jdGlvbiBlYWNoRm9ybUVsZW1lbnQoKSB7XG4gICAgdmFyIGNiID0gdGhpc1xuICAgICAgLCBlLCBpXG4gICAgICAsIHNlcmlhbGl6ZVN1YnRhZ3MgPSBmdW5jdGlvbiAoZSwgdGFncykge1xuICAgICAgICAgIHZhciBpLCBqLCBmYVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmYSA9IGVbYnlUYWddKHRhZ3NbaV0pXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZmEubGVuZ3RoOyBqKyspIHNlcmlhbChmYVtqXSwgY2IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlID0gYXJndW1lbnRzW2ldXG4gICAgICBpZiAoL2lucHV0fHNlbGVjdHx0ZXh0YXJlYS9pLnRlc3QoZS50YWdOYW1lKSkgc2VyaWFsKGUsIGNiKVxuICAgICAgc2VyaWFsaXplU3VidGFncyhlLCBbICdpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnIF0pXG4gICAgfVxuICB9XG5cbiAgLy8gc3RhbmRhcmQgcXVlcnkgc3RyaW5nIHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplUXVlcnlTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHJlcXdlc3QudG9RdWVyeVN0cmluZyhyZXF3ZXN0LnNlcmlhbGl6ZUFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpXG4gIH1cblxuICAvLyB7ICduYW1lJzogJ3ZhbHVlJywgLi4uIH0gc3R5bGUgc2VyaWFsaXphdGlvblxuICBmdW5jdGlvbiBzZXJpYWxpemVIYXNoKCkge1xuICAgIHZhciBoYXNoID0ge31cbiAgICBlYWNoRm9ybUVsZW1lbnQuYXBwbHkoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSBpbiBoYXNoKSB7XG4gICAgICAgIGhhc2hbbmFtZV0gJiYgIWlzQXJyYXkoaGFzaFtuYW1lXSkgJiYgKGhhc2hbbmFtZV0gPSBbaGFzaFtuYW1lXV0pXG4gICAgICAgIGhhc2hbbmFtZV0ucHVzaCh2YWx1ZSlcbiAgICAgIH0gZWxzZSBoYXNoW25hbWVdID0gdmFsdWVcbiAgICB9LCBhcmd1bWVudHMpXG4gICAgcmV0dXJuIGhhc2hcbiAgfVxuXG4gIC8vIFsgeyBuYW1lOiAnbmFtZScsIHZhbHVlOiAndmFsdWUnIH0sIC4uLiBdIHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgcmVxd2VzdC5zZXJpYWxpemVBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gW11cbiAgICBlYWNoRm9ybUVsZW1lbnQuYXBwbHkoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBhcnIucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSlcbiAgICB9LCBhcmd1bWVudHMpXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgcmVxd2VzdC5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuICAgIHZhciBvcHQsIGZuXG4gICAgICAsIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cbiAgICBvcHQgPSBhcmdzLnBvcCgpXG4gICAgb3B0ICYmIG9wdC5ub2RlVHlwZSAmJiBhcmdzLnB1c2gob3B0KSAmJiAob3B0ID0gbnVsbClcbiAgICBvcHQgJiYgKG9wdCA9IG9wdC50eXBlKVxuXG4gICAgaWYgKG9wdCA9PSAnbWFwJykgZm4gPSBzZXJpYWxpemVIYXNoXG4gICAgZWxzZSBpZiAob3B0ID09ICdhcnJheScpIGZuID0gcmVxd2VzdC5zZXJpYWxpemVBcnJheVxuICAgIGVsc2UgZm4gPSBzZXJpYWxpemVRdWVyeVN0cmluZ1xuXG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH1cblxuICByZXF3ZXN0LnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAobywgdHJhZCkge1xuICAgIHZhciBwcmVmaXgsIGlcbiAgICAgICwgdHJhZGl0aW9uYWwgPSB0cmFkIHx8IGZhbHNlXG4gICAgICAsIHMgPSBbXVxuICAgICAgLCBlbmMgPSBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgICwgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICB2YWx1ZSA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUpID8gdmFsdWUoKSA6ICh2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSlcbiAgICAgICAgICBzW3MubGVuZ3RoXSA9IGVuYyhrZXkpICsgJz0nICsgZW5jKHZhbHVlKVxuICAgICAgICB9XG4gICAgLy8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cbiAgICBpZiAoaXNBcnJheShvKSkge1xuICAgICAgZm9yIChpID0gMDsgbyAmJiBpIDwgby5sZW5ndGg7IGkrKykgYWRkKG9baV1bJ25hbWUnXSwgb1tpXVsndmFsdWUnXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgZm9yIChwcmVmaXggaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpKSBidWlsZFBhcmFtcyhwcmVmaXgsIG9bcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzcGFjZXMgc2hvdWxkIGJlICsgYWNjb3JkaW5nIHRvIHNwZWNcbiAgICByZXR1cm4gcy5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XG4gICAgdmFyIG5hbWUsIGksIHZcbiAgICAgICwgcmJyYWNrZXQgPSAvXFxbXFxdJC9cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgZm9yIChpID0gMDsgb2JqICYmIGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdiA9IG9ialtpXVxuICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgIGFkZChwcmVmaXgsIHYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyA/IGkgOiAnJykgKyAnXScsIHYsIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiBvYmoudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgbmFtZSArICddJywgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgIGFkZChwcmVmaXgsIG9iailcbiAgICB9XG4gIH1cblxuICByZXF3ZXN0LmdldGNhbGxiYWNrUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFja1ByZWZpeFxuICB9XG5cbiAgLy8galF1ZXJ5IGFuZCBaZXB0byBjb21wYXRpYmlsaXR5LCBkaWZmZXJlbmNlcyBjYW4gYmUgcmVtYXBwZWQgaGVyZSBzbyB5b3UgY2FuIGNhbGxcbiAgLy8gLmFqYXguY29tcGF0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICByZXF3ZXN0LmNvbXBhdCA9IGZ1bmN0aW9uIChvLCBmbikge1xuICAgIGlmIChvKSB7XG4gICAgICBvWyd0eXBlJ10gJiYgKG9bJ21ldGhvZCddID0gb1sndHlwZSddKSAmJiBkZWxldGUgb1sndHlwZSddXG4gICAgICBvWydkYXRhVHlwZSddICYmIChvWyd0eXBlJ10gPSBvWydkYXRhVHlwZSddKVxuICAgICAgb1snanNvbnBDYWxsYmFjayddICYmIChvWydqc29ucENhbGxiYWNrTmFtZSddID0gb1snanNvbnBDYWxsYmFjayddKSAmJiBkZWxldGUgb1snanNvbnBDYWxsYmFjayddXG4gICAgICBvWydqc29ucCddICYmIChvWydqc29ucENhbGxiYWNrJ10gPSBvWydqc29ucCddKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlcXdlc3QobywgZm4pXG4gIH1cblxuICByZXF3ZXN0LmFqYXhTZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgIGdsb2JhbFNldHVwT3B0aW9uc1trXSA9IG9wdGlvbnNba11cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxd2VzdFxufSk7XG4iLCJcbnZhciB3aW4gPSB3aW5kb3csIFxuICBkb2MgPSBkb2N1bWVudDtcblxudmFyIGIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGFzaDogXCJvbmhhc2hjaGFuZ2VcIiBpbiB3aW4gJiYgKCFkb2MuZG9jdW1lbnRNb2RlIHx8IGRvYy5kb2N1bWVudE1vZGUgPiA3KSxcbiAgaGlzdG9yeTogd2luLmhpc3RvcnkgJiYgXCJvbnBvcHN0YXRlXCIgaW4gd2luLFxuICBsb2NhdGlvbjogd2luLmxvY2F0aW9uLFxuICBnZXRIcmVmOiBmdW5jdGlvbihub2RlKXtcbiAgICByZXR1cm4gXCJocmVmXCIgaW4gbm9kZSA/IG5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiLCAyKSA6IG5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgfSxcbiAgb246IFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIHdpbiA/ICAvLyBJRTEwIGF0dGFjaEV2ZW50IGlzIG5vdCB3b3JraW5nIHdoZW4gYmluZGluZyB0aGUgb25wb3BzdGF0ZSwgc28gd2UgbmVlZCBjaGVjayBhZGRFdmVudExpc3RlciBmaXJzdFxuICAgICAgZnVuY3Rpb24obm9kZSx0eXBlLGNiKXtyZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBjYiApfVxuICAgIDogZnVuY3Rpb24obm9kZSx0eXBlLGNiKXtyZXR1cm4gbm9kZS5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgY2IgKX0sXG4gICAgXG4gIG9mZjogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIgaW4gd2luID8gXG4gICAgICBmdW5jdGlvbihub2RlLHR5cGUsY2Ipe3JldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGNiICl9XG4gICAgOiBmdW5jdGlvbihub2RlLHR5cGUsY2Ipe3JldHVybiBub2RlLmRldGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBjYiApfVxufVxuXG4iLCJcbi8vIE1JVFxuLy8gVGh4IEJhY2tib25lLmpzIDEuMS4yICBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktaGFzaGNoYW5nZS9ibG9iL21hc3Rlci9qcXVlcnkuYmEtaGFzaGNoYW5nZS5qc1xuLy8gZm9yIGlmcmFtZSBwYXRjaGVzIGluIG9sZCBpZS5cblxudmFyIGJyb3dzZXIgPSByZXF1aXJlKFwiLi9icm93c2VyLmpzXCIpO1xudmFyIF8gPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xuXG5cbi8vIHRoZSBtb2RlIGNvbnN0XG52YXIgUVVJUksgPSAzLFxuICBIQVNIID0gMSxcbiAgSElTVE9SWSA9IDI7XG5cblxuXG4vLyBleHRyYWN0IEhpc3RvcnkgZm9yIHRlc3Rcbi8vIHJlc29sdmUgdGhlIGNvbmZpY2x0IHdpdGggdGhlIE5hdGl2ZSBIaXN0b3J5XG5mdW5jdGlvbiBIaXN0ZXJ5KG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBUcmljayBmcm9tIGJhY2tib25lLmhpc3RvcnkgZm9yIGFuY2hvci1mYWtlZCB0ZXN0Y2FzZSBcbiAgdGhpcy5sb2NhdGlvbiA9IG9wdGlvbnMubG9jYXRpb24gfHwgYnJvd3Nlci5sb2NhdGlvbjtcblxuICAvLyBtb2RlIGNvbmZpZywgeW91IGNhbiBwYXNzIGFic29sdXRlIG1vZGUgKGp1c3QgZm9yIHRlc3QpO1xuICB0aGlzLmh0bWw1ID0gb3B0aW9ucy5odG1sNTtcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5odG1sNSAmJiBicm93c2VyLmhpc3RvcnkgPyBISVNUT1JZOiBIQVNIOyBcbiAgaWYoICFicm93c2VyLmhhc2ggKSB0aGlzLm1vZGUgPSBRVUlSSztcbiAgaWYob3B0aW9ucy5tb2RlKSB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGU7XG5cbiAgLy8gaGFzaCBwcmVmaXggLCB1c2VkIGZvciBoYXNoIG9yIHF1aXJrIG1vZGVcbiAgdGhpcy5wcmVmaXggPSBcIiNcIiArIChvcHRpb25zLnByZWZpeCB8fCBcIlwiKSA7XG4gIHRoaXMuclByZWZpeCA9IG5ldyBSZWdFeHAodGhpcy5wcmVmaXggKyAnKC4qKSQnKTtcbiAgdGhpcy5pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWwgfHwgNjY7XG5cbiAgLy8gdGhlIHJvb3QgcmVnZXhwIGZvciByZW1vdmUgdGhlIHJvb3QgZm9yIHRoZSBwYXRoLiB1c2VkIGluIEhpc3RvcnkgbW9kZVxuICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgIFwiL1wiIDtcbiAgdGhpcy5yUm9vdCA9IG5ldyBSZWdFeHAoXCJeXCIgKyAgdGhpcy5yb290KTtcblxuICB0aGlzLl9maXhJbml0U3RhdGUoKTtcblxuICB0aGlzLmF1dG9saW5rID0gb3B0aW9ucy5hdXRvbGluayE9PWZhbHNlO1xuXG4gIHRoaXMuY3VyUGF0aCA9IHVuZGVmaW5lZDtcbn1cblxuXy5leHRlbmQoIF8uZW1pdGFibGUoSGlzdGVyeSksIHtcbiAgLy8gY2hlY2sgdGhlIFxuICBzdGFydDogZnVuY3Rpb24oKXtcbiAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpO1xuICAgIHRoaXMuX2NoZWNrUGF0aCA9IF8uYmluZCh0aGlzLmNoZWNrUGF0aCwgdGhpcyk7XG5cbiAgICBpZiggdGhpcy5pc1N0YXJ0ICkgcmV0dXJuO1xuICAgIHRoaXMuaXNTdGFydCA9IHRydWU7XG5cbiAgICBpZih0aGlzLm1vZGUgPT09IFFVSVJLKXtcbiAgICAgIHRoaXMuX2ZpeEhhc2hQcm9iZWxtKHBhdGgpOyBcbiAgICB9XG5cbiAgICBzd2l0Y2ggKCB0aGlzLm1vZGUgKXtcbiAgICAgIGNhc2UgSEFTSDogXG4gICAgICAgIGJyb3dzZXIub24od2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5fY2hlY2tQYXRoKTsgXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBISVNUT1JZOlxuICAgICAgICBicm93c2VyLm9uKHdpbmRvdywgXCJwb3BzdGF0ZVwiLCB0aGlzLl9jaGVja1BhdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUVVJUks6XG4gICAgICAgIHRoaXMuX2NoZWNrTG9vcCgpO1xuICAgIH1cbiAgICAvLyBldmVudCBkZWxlZ2F0ZVxuICAgIHRoaXMuYXV0b2xpbmsgJiYgdGhpcy5fYXV0b2xpbmsoKTtcblxuICAgIHRoaXMuY3VyUGF0aCA9IHBhdGg7XG5cbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgcGF0aCk7XG4gIH0sXG4gIC8vIHRoZSBoaXN0b3J5IHRlYXJkb3duXG4gIHN0b3A6IGZ1bmN0aW9uKCl7XG5cbiAgICBicm93c2VyLm9mZih3aW5kb3csICdoYXNoY2hhbmdlJywgdGhpcy5fY2hlY2tQYXRoKSAgXG4gICAgYnJvd3Nlci5vZmYod2luZG93LCAncG9wc3RhdGUnLCB0aGlzLl9jaGVja1BhdGgpICBcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aWQpO1xuICAgIHRoaXMuaXNTdGFydCA9IGZhbHNlO1xuICAgIHRoaXMuX2NoZWNrUGF0aCA9IG51bGw7XG4gIH0sXG4gIC8vIGdldCB0aGUgcGF0aCBtb2RpZnlcbiAgY2hlY2tQYXRoOiBmdW5jdGlvbihldil7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpLCBjdXJQYXRoID0gdGhpcy5jdXJQYXRoO1xuXG4gICAgLy9mb3Igb2xkSUUgaGFzaCBoaXN0b3J5IGlzc3VlXG4gICAgaWYocGF0aCA9PT0gY3VyUGF0aCAmJiB0aGlzLmlmcmFtZSl7XG4gICAgICBwYXRoID0gdGhpcy5nZXRQYXRoKHRoaXMuaWZyYW1lLmxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICBpZiggcGF0aCAhPT0gY3VyUGF0aCApIHtcbiAgICAgIHRoaXMuaWZyYW1lICYmIHRoaXMubmF2KHBhdGgsIHtzaWxlbnQ6IHRydWV9KTtcbiAgICAgIHRoaXMuY3VyUGF0aCA9IHBhdGg7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHBhdGgpO1xuICAgIH1cbiAgfSxcbiAgLy8gZ2V0IHRoZSBjdXJyZW50IHBhdGhcbiAgZ2V0UGF0aDogZnVuY3Rpb24obG9jYXRpb24pe1xuICAgIHZhciBsb2NhdGlvbiA9IGxvY2F0aW9uIHx8IHRoaXMubG9jYXRpb24sIHRtcDtcbiAgICBpZiggdGhpcy5tb2RlICE9PSBISVNUT1JZICl7XG4gICAgICB0bXAgPSBsb2NhdGlvbi5ocmVmLm1hdGNoKHRoaXMuclByZWZpeCk7XG4gICAgICByZXR1cm4gdG1wICYmIHRtcFsxXT8gdG1wWzFdOiBcIlwiO1xuXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gXy5jbGVhblBhdGgoKCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiICkucmVwbGFjZSggdGhpcy5yUm9vdCwgXCIvXCIgKSlcbiAgICB9XG4gIH0sXG5cbiAgbmF2OiBmdW5jdGlvbih0bywgb3B0aW9ucyApe1xuXG4gICAgdmFyIGlmcmFtZSA9IHRoaXMuaWZyYW1lO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0byA9IF8uY2xlYW5QYXRoKHRvKTtcblxuICAgIGlmKHRoaXMuY3VyUGF0aCA9PSB0bykgcmV0dXJuO1xuXG4gICAgLy8gcHVzaFN0YXRlIHdvbnQgdHJpZ2dlciB0aGUgY2hlY2tQYXRoXG4gICAgLy8gYnV0IGhhc2hjaGFuZ2Ugd2lsbFxuICAgIC8vIHNvIHdlIG5lZWQgc2V0IGN1clBhdGggYmVmb3JlIHRvIGZvcmJpdCB0aGUgQ2hlY2tQYXRoXG4gICAgdGhpcy5jdXJQYXRoID0gdG87XG5cbiAgICAvLyAzIG9yIDEgaXMgbWF0Y2hlZFxuICAgIGlmKCB0aGlzLm1vZGUgIT09IEhJU1RPUlkgKXtcbiAgICAgIHRoaXMuX3NldEhhc2godGhpcy5sb2NhdGlvbiwgdG8sIG9wdGlvbnMucmVwbGFjZSlcbiAgICAgIGlmKCBpZnJhbWUgJiYgdGhpcy5nZXRQYXRoKGlmcmFtZS5sb2NhdGlvbikgIT09IHRvICl7XG4gICAgICAgIGlmKCFvcHRpb25zLnJlcGxhY2UpIGlmcmFtZS5kb2N1bWVudC5vcGVuKCkuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fc2V0SGFzaCh0aGlzLmlmcmFtZS5sb2NhdGlvbiwgdG8sIG9wdGlvbnMucmVwbGFjZSlcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIGhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlPyAncmVwbGFjZVN0YXRlJzogJ3B1c2hTdGF0ZSddKCB7fSwgb3B0aW9ucy50aXRsZSB8fCBcIlwiICwgXy5jbGVhblBhdGgoIHRoaXMucm9vdCArIHRvICkgKVxuICAgIH1cblxuICAgIGlmKCAhb3B0aW9ucy5zaWxlbnQgKSB0aGlzLmVtaXQoJ2NoYW5nZScsIHRvKTtcbiAgfSxcbiAgX2F1dG9saW5rOiBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW9kZSE9PUhJU1RPUlkpIHJldHVybjtcbiAgICAvLyBvbmx5IGluIGh0bWw1IG1vZGUsIHRoZSBhdXRvbGluayBpcyB3b3Jrc1xuICAgIC8vIGlmKHRoaXMubW9kZSAhPT0gMikgcmV0dXJuO1xuICAgIHZhciBwcmVmaXggPSB0aGlzLnByZWZpeCwgc2VsZiA9IHRoaXM7XG4gICAgYnJvd3Nlci5vbiggZG9jdW1lbnQuYm9keSwgXCJjbGlja1wiLCBmdW5jdGlvbihldil7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQgfHwgZXYuc3JjRWxlbWVudDtcbiAgICAgIGlmKCB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImFcIiApIHJldHVybjtcbiAgICAgIHZhciB0bXAgPSAoYnJvd3Nlci5nZXRIcmVmKHRhcmdldCl8fFwiXCIpLm1hdGNoKHNlbGYuclByZWZpeCk7XG4gICAgICB2YXIgaGFzaCA9IHRtcCAmJiB0bXBbMV0/IHRtcFsxXTogXCJcIjtcblxuICAgICAgaWYoIWhhc2gpIHJldHVybjtcbiAgICAgIFxuICAgICAgZXYucHJldmVudERlZmF1bHQgJiYgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGYubmF2KCBoYXNoIClcbiAgICAgIHJldHVybiAoZXYucmV0dXJuVmFsdWUgPSBmYWxzZSk7XG4gICAgfSApXG4gIH0sXG4gIF9zZXRIYXNoOiBmdW5jdGlvbihsb2NhdGlvbiwgcGF0aCwgcmVwbGFjZSl7XG4gICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICBpZiAocmVwbGFjZSl7XG4gICAgICBsb2NhdGlvbi5yZXBsYWNlKGhyZWYgKyB0aGlzLnByZWZpeCsgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgbG9jYXRpb24uaGFzaCA9IHRoaXMucHJlZml4KyBwYXRoO1xuICB9LFxuICAvLyBmb3IgYnJvd3NlciB0aGF0IG5vdCBzdXBwb3J0IG9uaGFzaGNoYW5nZVxuICBfY2hlY2tMb29wOiBmdW5jdGlvbigpe1xuICAgIHZhciBzZWxmID0gdGhpczsgXG4gICAgdGhpcy50aWQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fY2hlY2tQYXRoKCk7XG4gICAgICBzZWxmLl9jaGVja0xvb3AoKTtcbiAgICB9LCB0aGlzLmludGVydmFsICk7XG4gIH0sXG4gIC8vIGlmIHdlIHVzZSByZWFsIHVybCBpbiBoYXNoIGVudiggYnJvd3NlciBubyBoaXN0b3J5IHBvcHN0YXRlIHN1cHBvcnQpXG4gIC8vIG9yIHdlIHVzZSBoYXNoIGluIGh0bWw1c3Vwb29ydCBtb2RlICh3aGVuIHBhc3RlIHVybCBpbiBvdGhlciB1cmwpXG4gIC8vIHRoZW4gLCBoaXN0ZXJ5IHNob3VsZCByZXBhcmEgaXRcbiAgX2ZpeEluaXRTdGF0ZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgcGF0aG5hbWUgPSBfLmNsZWFuUGF0aCh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lKSwgaGFzaCwgaGFzaEluUGF0aE5hbWU7XG5cbiAgICAvLyBkb250IHN1cHBvcnQgaGlzdG9yeSBwb3BzdGF0ZSBidXQgY29uZmlnIHRoZSBodG1sNSBtb2RlXG4gICAgaWYoIHRoaXMubW9kZSAhPT0gSElTVE9SWSAmJiB0aGlzLmh0bWw1KXtcblxuICAgICAgaGFzaEluUGF0aE5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKHRoaXMuclJvb3QsIFwiXCIpXG4gICAgICBpZihoYXNoSW5QYXRoTmFtZSkgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMucm9vdCArIHRoaXMucHJlZml4ICsgaGFzaEluUGF0aE5hbWUpO1xuXG4gICAgfWVsc2UgaWYoIHRoaXMubW9kZSA9PT0gSElTVE9SWSAvKiAmJiBwYXRobmFtZSA9PT0gdGhpcy5yb290Ki8pe1xuXG4gICAgICBoYXNoID0gdGhpcy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UodGhpcy5wcmVmaXgsIFwiXCIpO1xuICAgICAgaWYoaGFzaCkgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCBfLmNsZWFuUGF0aCh0aGlzLnJvb3QgKyBoYXNoKSlcblxuICAgIH1cbiAgfSxcbiAgLy8gVGhhbmtzIGZvciBiYWNrYm9uZS5oaXN0b3J5IGFuZCBodHRwczovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1oYXNoY2hhbmdlL2Jsb2IvbWFzdGVyL2pxdWVyeS5iYS1oYXNoY2hhbmdlLmpzXG4gIC8vIGZvciBoZWxwaW5nIHN0YXRlbWFuIGZpeGluZyB0aGUgb2xkaWUgaGFzaCBoaXN0b3J5IGlzc3VlcyB3aGVuIHdpdGggaWZyYW1lIGhhY2tcbiAgX2ZpeEhhc2hQcm9iZWxtOiBmdW5jdGlvbihwYXRoKXtcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyksIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDo7JztcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICBpZnJhbWUudGl0bGUgPSBcIlwiO1xuICAgIHRoaXMuaWZyYW1lID0gYm9keS5pbnNlcnRCZWZvcmUoaWZyYW1lLCBib2R5LmZpcnN0Q2hpbGQpLmNvbnRlbnRXaW5kb3c7XG4gICAgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XG4gICAgdGhpcy5pZnJhbWUubG9jYXRpb24uaGFzaCA9ICcjJyArIHBhdGg7XG4gIH1cbiAgXG59KVxuXG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gSGlzdGVyeTsiLCJcbnZhciBTdGF0ZU1hbiA9IHJlcXVpcmUoXCIuL3N0YXRlbWFuLmpzXCIpO1xuU3RhdGVNYW4uSGlzdGVyeSA9IHJlcXVpcmUoXCIuL2hpc3RlcnkuanNcIik7XG5TdGF0ZU1hbi51dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcblN0YXRlTWFuLlN0YXRlID0gcmVxdWlyZShcIi4vc3RhdGUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYW47XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5cblxuXG5mdW5jdGlvbiBTdGF0ZShvcHRpb24pe1xuICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbiAgaWYob3B0aW9uKSB0aGlzLmNvbmZpZyhvcHRpb24pO1xufVxuXG5cbi8vcmVnZXhwIGNhY2hlXG5TdGF0ZS5yQ2FjaGUgPSB7fTtcblxuXy5leHRlbmQoIF8uZW1pdGFibGUoIFN0YXRlICksIHtcbiAgXG4gIHN0YXRlOiBmdW5jdGlvbihzdGF0ZU5hbWUsIGNvbmZpZyl7XG4gICAgaWYoXy50eXBlT2Yoc3RhdGVOYW1lKSA9PT0gXCJvYmplY3RcIil7XG4gICAgICBmb3IodmFyIGkgaW4gc3RhdGVOYW1lKXtcbiAgICAgICAgdGhpcy5zdGF0ZShpLCBzdGF0ZU5hbWVbaV0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQsIG5leHQsIG5leHROYW1lLCBzdGF0ZXMgPSB0aGlzLl9zdGF0ZXMsIGk9MDtcblxuICAgIGlmKCB0eXBlb2Ygc3RhdGVOYW1lID09PSBcInN0cmluZ1wiICkgc3RhdGVOYW1lID0gc3RhdGVOYW1lLnNwbGl0KFwiLlwiKTtcblxuICAgIHZhciBzbGVuID0gc3RhdGVOYW1lLmxlbmd0aCwgY3VycmVudCA9IHRoaXM7XG4gICAgdmFyIHN0YWNrID0gW107XG5cblxuICAgIGRve1xuICAgICAgbmV4dE5hbWUgPSBzdGF0ZU5hbWVbaV07XG4gICAgICBuZXh0ID0gc3RhdGVzW25leHROYW1lXTtcbiAgICAgIHN0YWNrLnB1c2gobmV4dE5hbWUpO1xuICAgICAgaWYoIW5leHQpe1xuICAgICAgICBpZighY29uZmlnKSByZXR1cm47XG4gICAgICAgIG5leHQgPSBzdGF0ZXNbbmV4dE5hbWVdID0gbmV3IFN0YXRlKCk7XG4gICAgICAgIF8uZXh0ZW5kKG5leHQsIHtcbiAgICAgICAgICBwYXJlbnQ6IGN1cnJlbnQsXG4gICAgICAgICAgbWFuYWdlcjogY3VycmVudC5tYW5hZ2VyIHx8IGN1cnJlbnQsXG4gICAgICAgICAgbmFtZTogc3RhY2suam9pbihcIi5cIiksXG4gICAgICAgICAgY3VycmVudE5hbWU6IG5leHROYW1lXG4gICAgICAgIH0pXG4gICAgICAgIGN1cnJlbnQuaGFzTmV4dCA9IHRydWU7XG4gICAgICAgIG5leHQuY29uZmlnVXJsKCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgIHN0YXRlcyA9IG5leHQuX3N0YXRlcztcbiAgICB9d2hpbGUoKCsraSkgPCBzbGVuIClcblxuICAgIGlmKGNvbmZpZyl7XG4gICAgICAgbmV4dC5jb25maWcoY29uZmlnKTtcbiAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9LFxuXG4gIGNvbmZpZzogZnVuY3Rpb24oY29uZmlndXJlKXtcblxuICAgIGNvbmZpZ3VyZSA9IHRoaXMuX2dldENvbmZpZyhjb25maWd1cmUpO1xuXG4gICAgZm9yKHZhciBpIGluIGNvbmZpZ3VyZSl7XG4gICAgICB2YXIgcHJvcCA9IGNvbmZpZ3VyZVtpXTtcbiAgICAgIHN3aXRjaChpKXtcbiAgICAgICAgY2FzZSBcInVybFwiOiBcbiAgICAgICAgICBpZih0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHByb3A7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1VybCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImV2ZW50c1wiOiBcbiAgICAgICAgICB0aGlzLm9uKHByb3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIGNoaWxkcmVuIG92ZXJyaWRlXG4gIF9nZXRDb25maWc6IGZ1bmN0aW9uKGNvbmZpZ3VyZSl7XG4gICAgcmV0dXJuIHR5cGVvZiBjb25maWd1cmUgPT09IFwiZnVuY3Rpb25cIj8ge2VudGVyOiBjb25maWd1cmV9IDogY29uZmlndXJlO1xuICB9LFxuXG4gIC8vZnJvbSB1cmwgXG5cbiAgY29uZmlnVXJsOiBmdW5jdGlvbigpe1xuICAgIHZhciB1cmwgPSBcIlwiICwgYmFzZSA9IHRoaXMsIGN1cnJlbnRVcmw7XG4gICAgdmFyIF93YXRjaGVkUGFyYW0gPSBbXTtcblxuICAgIHdoaWxlKCBiYXNlICl7XG5cbiAgICAgIHVybCA9ICh0eXBlb2YgYmFzZS51cmwgPT09IFwic3RyaW5nXCIgPyBiYXNlLnVybDogKGJhc2UuY3VycmVudE5hbWUgfHwgXCJcIikpICsgXCIvXCIgKyB1cmw7XG5cbiAgICAgIC8vIG1lYW5zIGFic29sdXRlO1xuICAgICAgaWYodXJsLmluZGV4T2YoXCJeL1wiKSA9PT0gMCkge1xuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYmFzZSA9IGJhc2UucGFyZW50O1xuICAgIH1cbiAgICB0aGlzLnBhdHRlcm4gPSBfLmNsZWFuUGF0aChcIi9cIiArIHVybCk7XG4gICAgdmFyIHBhdGhBbmRRdWVyeSA9IHRoaXMucGF0dGVybi5zcGxpdChcIj9cIik7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0aEFuZFF1ZXJ5WzBdO1xuICAgIC8vIHNvbWUgUXVlcnkgd2UgbmVlZCB3YXRjaGVkXG5cbiAgICBfLmV4dGVuZCh0aGlzLCBfLm5vcm1hbGl6ZSh0aGlzLnBhdHRlcm4pLCB0cnVlKTtcbiAgfSxcbiAgZW5jb2RlOiBmdW5jdGlvbihwYXJhbSl7XG4gICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICBwYXJhbSA9IHBhcmFtIHx8IHt9O1xuICAgIFxuICAgIHZhciBtYXRjaGVkID0gXCIlXCI7XG5cbiAgICB2YXIgdXJsID0gc3RhdGUubWF0Y2hlcy5yZXBsYWNlKC9cXCgoW1xcdy1dKylcXCkvZywgZnVuY3Rpb24oYWxsLCBjYXB0dXJlKXtcbiAgICAgIHZhciBzZWMgPSBwYXJhbVtjYXB0dXJlXSB8fCBcIlwiO1xuICAgICAgbWF0Y2hlZCs9IGNhcHR1cmUgKyBcIiVcIjtcbiAgICAgIHJldHVybiBzZWM7XG4gICAgfSkgKyBcIj9cIjtcblxuICAgIC8vIHJlbWFpbmVkIGlzIHRoZSBxdWVyeSwgd2UgbmVlZCBjb25jYXQgdGhlbSBhZnRlciB1cmwgYXMgcXVlcnlcbiAgICBmb3IodmFyIGkgaW4gcGFyYW0pIHtcbiAgICAgIGlmKCBtYXRjaGVkLmluZGV4T2YoXCIlXCIraStcIiVcIikgPT09IC0xKSB1cmwgKz0gaSArIFwiPVwiICsgcGFyYW1baV0gKyBcIiZcIjtcbiAgICB9XG4gICAgcmV0dXJuIF8uY2xlYW5QYXRoKCB1cmwucmVwbGFjZSgvKD86XFw/fCYpJC8sXCJcIikgKVxuICB9LFxuICBkZWNvZGU6IGZ1bmN0aW9uKCBwYXRoICl7XG4gICAgdmFyIG1hdGNoZWQgPSB0aGlzLnJlZ2V4cC5leGVjKHBhdGgpLFxuICAgICAga2V5cyA9IHRoaXMua2V5cztcblxuICAgIGlmKG1hdGNoZWQpe1xuXG4gICAgICB2YXIgcGFyYW0gPSB7fTtcbiAgICAgIGZvcih2YXIgaSA9MCxsZW49a2V5cy5sZW5ndGg7aTxsZW47aSsrKXtcbiAgICAgICAgcGFyYW1ba2V5c1tpXV0gPSBtYXRjaGVkW2krMV0gXG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICAvLyBieSBkZWZhdWx0LCBhbGwgbGlmZWN5Y2xlIGlzIHBlcm1pdHRlZFxuXG4gIGFzeW5jOiBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvciggJ3BsZWFzZSB1c2Ugb3B0aW9uLmFzeW5jIGluc3RlYWQnKVxuICB9XG5cbn0pXG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTsiLCJ2YXIgU3RhdGUgPSByZXF1aXJlKFwiLi9zdGF0ZS5qc1wiKSxcbiAgSGlzdGVyeSA9IHJlcXVpcmUoXCIuL2hpc3RlcnkuanNcIiksXG4gIGJyb3cgPSByZXF1aXJlKFwiLi9icm93c2VyLmpzXCIpLFxuICBfID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKSxcbiAgYmFzZVRpdGxlID0gZG9jdW1lbnQudGl0bGUsXG4gIHN0YXRlRm4gPSBTdGF0ZS5wcm90b3R5cGUuc3RhdGU7XG5cblxuZnVuY3Rpb24gU3RhdGVNYW4ob3B0aW9ucyl7XG5cbiAgaWYodGhpcyBpbnN0YW5jZW9mIFN0YXRlTWFuID09PSBmYWxzZSl7IHJldHVybiBuZXcgU3RhdGVNYW4ob3B0aW9ucyl9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAvLyBpZihvcHRpb25zLmhpc3RvcnkpIHRoaXMuaGlzdG9yeSA9IG9wdGlvbnMuaGlzdG9yeTtcblxuICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgdGhpcy5fc3Rhc2hDYWxsYmFjayA9IFtdO1xuICB0aGlzLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFjdGl2ZSA9IHRoaXM7XG4gIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICB0aGlzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCx0aXRsZTtcbiAgICB3aGlsZSggY3VyICl7XG4gICAgICB0aXRsZSA9IGN1ci50aXRsZTtcbiAgICAgIGlmKHRpdGxlKSBicmVhazsgXG4gICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgIH1cbiAgICBkb2N1bWVudC50aXRsZSA9IHR5cGVvZiB0aXRsZSA9PT0gXCJmdW5jdGlvblwiPyBjdXIudGl0bGUoKTogU3RyaW5nKCB0aXRsZSB8fCBiYXNlVGl0bGUgKSA7XG4gIH0pXG5cbn1cblxuXG5fLmV4dGVuZCggXy5lbWl0YWJsZSggU3RhdGVNYW4gKSwge1xuICAgIC8vIGtlZXAgYmxhbmtcbiAgICBuYW1lOiAnJyxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihzdGF0ZU5hbWUsIGNvbmZpZyl7XG5cbiAgICAgIHZhciBhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgIGlmKHR5cGVvZiBzdGF0ZU5hbWUgPT09IFwic3RyaW5nXCIgJiYgYWN0aXZlKXtcbiAgICAgICAgIHN0YXRlTmFtZSA9IHN0YXRlTmFtZS5yZXBsYWNlKFwiflwiLCBhY3RpdmUubmFtZSlcbiAgICAgICAgIGlmKGFjdGl2ZS5wYXJlbnQpIHN0YXRlTmFtZSA9IHN0YXRlTmFtZS5yZXBsYWNlKFwiXlwiLCBhY3RpdmUucGFyZW50Lm5hbWUgfHwgXCJcIik7XG4gICAgICB9XG4gICAgICAvLyBeIHJlcHJlc2VudCBjdXJyZW50LnBhcmVudFxuICAgICAgLy8gfiByZXByZXNlbnQgIGN1cnJlbnRcbiAgICAgIC8vIG9ubHkgXG4gICAgICByZXR1cm4gc3RhdGVGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucyl7XG5cbiAgICAgIGlmKCAhdGhpcy5oaXN0b3J5ICkgdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3Rlcnkob3B0aW9ucyk7IFxuICAgICAgaWYoICF0aGlzLmhpc3RvcnkuaXNTdGFydCApe1xuICAgICAgICB0aGlzLmhpc3Rvcnkub24oXCJjaGFuZ2VcIiwgXy5iaW5kKHRoaXMuX2FmdGVyUGF0aENoYW5nZSwgdGhpcykpO1xuICAgICAgICB0aGlzLmhpc3Rvcnkuc3RhcnQoKTtcbiAgICAgIH0gXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuaGlzdG9yeS5zdG9wKCk7XG4gICAgfSxcbiAgICAvLyBAVE9ETyBkaXJlY3QgZ28gdGhlIHBvaW50IHN0YXRlXG4gICAgZ286IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb24sIGNhbGxiYWNrKXtcbiAgICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcbiAgICAgIGlmKHR5cGVvZiBzdGF0ZSA9PT0gXCJzdHJpbmdcIikgc3RhdGUgPSB0aGlzLnN0YXRlKHN0YXRlKTtcblxuICAgICAgaWYoIXN0YXRlKSByZXR1cm47XG5cbiAgICAgIGlmKHR5cGVvZiBvcHRpb24gPT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uO1xuICAgICAgICBvcHRpb24gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0aW9uLmVuY29kZSAhPT0gZmFsc2Upe1xuICAgICAgICB2YXIgdXJsID0gc3RhdGUuZW5jb2RlKG9wdGlvbi5wYXJhbSlcbiAgICAgICAgb3B0aW9uLnBhdGggPSB1cmw7XG4gICAgICAgIHRoaXMubmF2KHVybCwge3NpbGVudDogdHJ1ZSwgcmVwbGFjZTogb3B0aW9uLnJlcGxhY2V9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ28oc3RhdGUsIG9wdGlvbiwgY2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5hdjogZnVuY3Rpb24odXJsLCBvcHRpb25zLCBjYWxsYmFjayl7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKXtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgb3B0aW9ucy5wYXRoID0gdXJsO1xuXG4gICAgICB0aGlzLmhpc3RvcnkubmF2KCB1cmwsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZighb3B0aW9ucy5zaWxlbnQpIHRoaXMuX2FmdGVyUGF0aENoYW5nZSggXy5jbGVhblBhdGgodXJsKSAsIG9wdGlvbnMgLCBjYWxsYmFjaylcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKHBhdGgpe1xuXG4gICAgICB2YXIgcGF0aEFuZFF1ZXJ5ID0gcGF0aC5zcGxpdChcIj9cIik7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLl9maW5kUXVlcnkocGF0aEFuZFF1ZXJ5WzFdKTtcbiAgICAgIHBhdGggPSBwYXRoQW5kUXVlcnlbMF07XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9maW5kU3RhdGUodGhpcywgcGF0aCk7XG4gICAgICBpZihzdGF0ZSkgXy5leHRlbmQoc3RhdGUucGFyYW0sIHF1ZXJ5KTtcbiAgICAgIHJldHVybiBzdGF0ZTtcblxuICAgIH0sXG4gICAgZW5jb2RlOiBmdW5jdGlvbihzdGF0ZU5hbWUsIHBhcmFtKXtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUoc3RhdGVOYW1lKTtcbiAgICAgIHJldHVybiBzdGF0ZT8gc3RhdGUuZW5jb2RlKHBhcmFtKSA6ICcnO1xuICAgIH0sXG4gICAgLy8gbm90aWZ5IHNwZWNpZnkgc3RhdGVcbiAgICAvLyBjaGVjayB0aGUgYWN0aXZlIHN0YXRlbmFtZSB3aGV0aGVyIHRvIG1hdGNoIHRoZSBwYXNzZWQgY29uZGl0aW9uIChzdGF0ZU5hbWUgYW5kIHBhcmFtKVxuICAgIGlzOiBmdW5jdGlvbihzdGF0ZU5hbWUsIHBhcmFtLCBpc1N0cmljdCl7XG4gICAgICBpZighc3RhdGVOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc3RhdGVOYW1lID0gKHN0YXRlTmFtZS5uYW1lIHx8IHN0YXRlTmFtZSk7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudCwgY3VycmVudE5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICB2YXIgbWF0Y2hQYXRoID0gaXNTdHJpY3Q/IGN1cnJlbnROYW1lID09PSBzdGF0ZU5hbWUgOiAoY3VycmVudE5hbWUgKyBcIi5cIikuaW5kZXhPZihzdGF0ZU5hbWUgKyBcIi5cIik9PT0wO1xuICAgICAgcmV0dXJuIG1hdGNoUGF0aCAmJiAoIXBhcmFtIHx8IF8uZXFsKHBhcmFtLCB0aGlzLnBhcmFtKSk7IFxuICAgIH0sXG4gICAgLy8gYWZ0ZXIgcGF0aGNoYW5nZSBjaGFuZ2VkXG4gICAgLy8gQFRPRE86IGFmdGVyUGF0aENoYW5nZSBuZWVkIGJhc2VkIG9uIGRlY29kZVxuICAgIF9hZnRlclBhdGhDaGFuZ2U6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMgLGNhbGxiYWNrKXtcblxuICAgICAgdGhpcy5lbWl0KFwiaGlzdG9yeTpjaGFuZ2VcIiwgcGF0aCk7XG5cbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuZGVjb2RlKHBhdGgpO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgb3B0aW9ucy5wYXRoID0gcGF0aDtcblxuICAgICAgaWYoIWZvdW5kKXtcbiAgICAgICAgLy8gbG9jLm5hdihcIiRkZWZhdWx0XCIsIHtzaWxlbnQ6IHRydWV9KVxuICAgICAgICByZXR1cm4gdGhpcy5fbm90Zm91bmQob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMucGFyYW0gPSBmb3VuZC5wYXJhbTtcblxuICAgICAgdGhpcy5fZ28oIGZvdW5kLCBvcHRpb25zLCBjYWxsYmFjayApO1xuICAgIH0sXG4gICAgX25vdGZvdW5kOiBmdW5jdGlvbihvcHRpb25zKXtcblxuICAgICAgLy8gdmFyICRub3Rmb3VuZCA9IHRoaXMuc3RhdGUoXCIkbm90Zm91bmRcIik7XG5cbiAgICAgIC8vIGlmKCAkbm90Zm91bmQgKSB0aGlzLl9nbygkbm90Zm91bmQsIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KFwibm90Zm91bmRcIiwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICAvLyBnb3RvIHRoZSBzdGF0ZSB3aXRoIHNvbWUgb3B0aW9uXG4gICAgX2dvOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9uLCBjYWxsYmFjayl7XG5cbiAgICAgIHZhciBvdmVyO1xuXG4gICAgICAvLyBpZih0eXBlb2Ygc3RhdGUgPT09IFwic3RyaW5nXCIpIHN0YXRlID0gdGhpcy5zdGF0ZShzdGF0ZSk7XG5cbiAgICAgIC8vIGlmKCFzdGF0ZSkgcmV0dXJuIF8ubG9nKFwiZGVzdGluYXRpb24gaXMgbm90IGRlZmluZWRcIilcblxuICAgICAgaWYoc3RhdGUuaGFzTmV4dCAmJiB0aGlzLnN0cmljdCkgcmV0dXJuIHRoaXMuX25vdGZvdW5kKHtuYW1lOiBzdGF0ZS5uYW1lfSk7XG5cbiAgICAgIC8vIG5vdCB0b3VjaCB0aGUgZW5kIGluIHByZXZpb3VzIHRyYW5zdGlvblxuXG4gICAgICAvLyBpZiggdGhpcy5wZW5kaW5nICl7XG4gICAgICAvLyAgIHZhciBwZW5kaW5nQ3VycmVudCA9IHRoaXMucGVuZGluZy5jdXJyZW50O1xuICAgICAgLy8gICB0aGlzLnBlbmRpbmcuc3RvcCgpO1xuICAgICAgLy8gICBfLmxvZyhcIm5hdmluZyB0byBbXCIgKyBwZW5kaW5nQ3VycmVudC5uYW1lICsgXCJdIHdpbGwgYmUgc3RvcGVkLCB0cnlpbmcgdG8gW1wiK3N0YXRlLm5hbWUrXCJdIG5vd1wiKTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGlmKHRoaXMuYWN0aXZlICE9PSB0aGlzLmN1cnJlbnQpe1xuICAgICAgLy8gICAvLyB3ZSBuZWVkIHJldHVyblxuICAgICAgLy8gICBfLmxvZyhcIm5hdmluZyB0byBbXCIgKyB0aGlzLmN1cnJlbnQubmFtZSArIFwiXSB3aWxsIGJlIHN0b3BlZCwgdHJ5aW5nIHRvIFtcIitzdGF0ZS5uYW1lK1wiXSBub3dcIik7XG4gICAgICAvLyAgIHRoaXMuY3VycmVudCA9IHRoaXMuYWN0aXZlO1xuICAgICAgLy8gICAvLyBiYWNrIHRvIGJlZm9yZVxuICAgICAgLy8gfVxuICAgICAgb3B0aW9uLnBhcmFtID0gb3B0aW9uLnBhcmFtIHx8IHt9O1xuXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgYmFzZVN0YXRlID0gdGhpcy5fZmluZEJhc2UoY3VycmVudCwgc3RhdGUpLFxuICAgICAgICBwcmVwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuXG4gICAgICBpZiggdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgKSB0aGlzLl9zdGFzaENhbGxiYWNrLnB1c2goY2FsbGJhY2spO1xuICAgICAgLy8gaWYgd2UgZG9uZSB0aGUgbmF2aWdhdGluZyB3aGVuIHN0YXJ0XG4gICAgICBmdW5jdGlvbiBkb25lKHN1Y2Nlc3Mpe1xuICAgICAgICBvdmVyID0gdHJ1ZTtcbiAgICAgICAgaWYoIHN1Y2Nlc3MgIT09IGZhbHNlICkgc2VsZi5lbWl0KFwiZW5kXCIpO1xuICAgICAgICBzZWxmLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICBzZWxmLl9wb3BTdGFzaChvcHRpb24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBvcHRpb24ucHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgb3B0aW9uLmN1cnJlbnQgPSBzdGF0ZTtcblxuICAgICAgaWYoY3VycmVudCAhPT0gc3RhdGUpe1xuICAgICAgICBvcHRpb24uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZG9uZShmYWxzZSk7XG4gICAgICAgICAgc2VsZi5uYXYoIHByZXBhdGg/IHByZXBhdGg6IFwiL1wiLCB7c2lsZW50OnRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVtaXQoXCJiZWdpblwiLCBvcHRpb24pO1xuXG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBzdG9wIGl0IGluICdiZWdpbicgbGlzdGVuZXJcbiAgICAgIGlmKG92ZXIgPT09IHRydWUpIHJldHVybjtcblxuICAgICAgaWYoY3VycmVudCAhPT0gc3RhdGUpe1xuICAgICAgICAvLyBvcHRpb24gYXMgdHJhbnNpdGlvbiBvYmplY3QuXG5cbiAgICAgICAgb3B0aW9uLnBoYXNlID0gJ3Blcm1pc3Npb24nO1xuICAgICAgICB0aGlzLl93YWxrKGN1cnJlbnQsIHN0YXRlLCBvcHRpb24sIHRydWUgLCBfLmJpbmQoIGZ1bmN0aW9uKCBub3RSZWplY3RlZCApe1xuXG4gICAgICAgICAgaWYoIG5vdFJlamVjdGVkPT09ZmFsc2UgKXtcbiAgICAgICAgICAgIC8vIGlmIHJlamVjdCBpbiBjYWxsRm9yUGVybWlzc2lvbiwgd2Ugd2lsbCByZXR1cm4gdG8gb2xkIFxuICAgICAgICAgICAgcHJlcGF0aCAmJiB0aGlzLm5hdiggcHJlcGF0aCwge3NpbGVudDogdHJ1ZX0pXG5cbiAgICAgICAgICAgIGRvbmUoZmFsc2UsIDIpXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Fib3J0Jywgb3B0aW9uKTtcblxuICAgICAgICAgIH0gXG5cbiAgICAgICAgICAvLyBzdG9wIHByZXZpb3VzIHBlbmRpbmcuXG4gICAgICAgICAgaWYodGhpcy5wZW5kaW5nKSB0aGlzLnBlbmRpbmcuc3RvcCgpIFxuICAgICAgICAgIHRoaXMucGVuZGluZyA9IG9wdGlvbjtcbiAgICAgICAgICB0aGlzLnBhdGggPSBvcHRpb24ucGF0aDtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBvcHRpb24uY3VycmVudDtcbiAgICAgICAgICB0aGlzLnBhcmFtID0gb3B0aW9uLnBhcmFtO1xuICAgICAgICAgIHRoaXMucHJldmlvdXMgPSBvcHRpb24ucHJldmlvdXM7XG4gICAgICAgICAgb3B0aW9uLnBoYXNlID0gJ25hdmlnYXRpb24nO1xuICAgICAgICAgIHRoaXMuX3dhbGsoY3VycmVudCwgc3RhdGUsIG9wdGlvbiwgZmFsc2UsIF8uYmluZChmdW5jdGlvbiggbm90UmVqZWN0ZWQgKXtcblxuICAgICAgICAgICAgaWYoIG5vdFJlamVjdGVkID09PSBmYWxzZSApe1xuICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgICAgZG9uZShmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnYWJvcnQnLCBvcHRpb24pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gb3B0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIG9wdGlvbi5waGFzZSA9ICdjb21wbGV0aW9uJztcbiAgICAgICAgICAgIHJldHVybiBkb25lKClcblxuICAgICAgICAgIH0sIHRoaXMpIClcblxuICAgICAgICB9LCB0aGlzKSApXG5cbiAgICAgIH1lbHNle1xuICAgICAgICBzZWxmLl9jaGVja1F1ZXJ5QW5kUGFyYW0oYmFzZVN0YXRlLCBvcHRpb24pO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuICAgIF9wb3BTdGFzaDogZnVuY3Rpb24ob3B0aW9uKXtcblxuICAgICAgdmFyIHN0YXNoID0gdGhpcy5fc3Rhc2hDYWxsYmFjaywgbGVuID0gc3Rhc2gubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9zdGFzaENhbGxiYWNrID0gW107XG5cbiAgICAgIGlmKCFsZW4pIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgc3Rhc2hbaV0uY2FsbCh0aGlzLCBvcHRpb24pXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHRoZSB0cmFuc2l0aW9uIGxvZ2ljICBVc2VkIGluIEJvdGggY2FuTGVhdmUgY2FuRW50ZXIgJiYgbGVhdmUgZW50ZXIgTGlmZUN5Y2xlXG5cbiAgICBfd2FsazogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbiwgY2FsbEZvclBlcm1pdCAsIGNhbGxiYWNrKXtcblxuICAgICAgLy8gbm90aGluZyAtPiBhcHAuc3RhdGVcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9maW5kQmFzZShmcm9tICwgdG8pO1xuXG5cbiAgICAgIG9wdGlvbi5iYXNja3dhcmQgPSB0cnVlO1xuICAgICAgdGhpcy5fdHJhbnNpdCggZnJvbSwgcGFyZW50LCBvcHRpb24sIGNhbGxGb3JQZXJtaXQgLCBfLmJpbmQoIGZ1bmN0aW9uKCBub3RSZWplY3RlZCApe1xuXG4gICAgICAgIGlmKCBub3RSZWplY3RlZCA9PT0gZmFsc2UgKSByZXR1cm4gY2FsbGJhY2soIG5vdFJlamVjdGVkICk7XG5cbiAgICAgICAgLy8gb25seSBhY3R1YWwgdHJhbnNpdG9uIG5lZWQgdXBkYXRlIGJhc2Ugc3RhdGU7XG4gICAgICAgIGlmKCAhY2FsbEZvclBlcm1pdCApICB0aGlzLl9jaGVja1F1ZXJ5QW5kUGFyYW0ocGFyZW50LCBvcHRpb24pXG5cbiAgICAgICAgb3B0aW9uLmJhc2Nrd2FyZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90cmFuc2l0KCBwYXJlbnQsIHRvLCBvcHRpb24sIGNhbGxGb3JQZXJtaXQsICBjYWxsYmFjaylcblxuICAgICAgfSwgdGhpcykgKVxuXG4gICAgfSxcblxuICAgIF90cmFuc2l0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9uLCBjYWxsRm9yUGVybWl0LCBjYWxsYmFjayl7XG4gICAgICAvLyAgdG91Y2ggdGhlIGVuZGluZ1xuICAgICAgaWYoIGZyb20gPT09IHRvICkgcmV0dXJuIGNhbGxiYWNrKCk7XG5cbiAgICAgIHZhciBiYWNrID0gZnJvbS5uYW1lLmxlbmd0aCA+IHRvLm5hbWUubGVuZ3RoO1xuICAgICAgdmFyIG1ldGhvZCA9IGJhY2s/ICdsZWF2ZSc6ICdlbnRlcic7XG4gICAgICB2YXIgYXBwbGllZDtcblxuICAgICAgLy8gdXNlIGNhbkVudGVyIHRvIGRldGVjdCBwZXJtaXNzaW9uXG4gICAgICBpZiggY2FsbEZvclBlcm1pdCkgbWV0aG9kID0gJ2NhbicgKyBtZXRob2QucmVwbGFjZSgvXlxcdy8sIGZ1bmN0aW9uKGEpeyByZXR1cm4gYS50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gICAgICB2YXIgbG9vcCA9IF8uYmluZChmdW5jdGlvbiggbm90UmVqZWN0ZWQgKXtcblxuXG4gICAgICAgIC8vIHN0b3AgdHJhbnNpdGlvbiBvciB0b3VjaCB0aGUgZW5kXG4gICAgICAgIGlmKCBhcHBsaWVkID09PSB0byB8fCBub3RSZWplY3RlZCA9PT0gZmFsc2UgKSByZXR1cm4gY2FsbGJhY2sobm90UmVqZWN0ZWQpO1xuXG4gICAgICAgIGlmKCAhYXBwbGllZCApIHtcblxuICAgICAgICAgIGFwcGxpZWQgPSBiYWNrPyBmcm9tIDogdGhpcy5fY29tcHV0ZU5leHQoZnJvbSwgdG8pO1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgYXBwbGllZCA9IHRoaXMuX2NvbXB1dGVOZXh0KGFwcGxpZWQsIHRvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAoYmFjayAmJiBhcHBsaWVkID09PSB0bykgfHwgIWFwcGxpZWQgKXJldHVybiBjYWxsYmFjayggbm90UmVqZWN0ZWQgKVxuXG4gICAgICAgIHRoaXMuX21vdmVPbiggYXBwbGllZCwgbWV0aG9kLCBvcHRpb24sIGxvb3AgKTtcblxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGxvb3AoKTtcbiAgICB9LFxuXG4gICAgX21vdmVPbjogZnVuY3Rpb24oIGFwcGxpZWQsIG1ldGhvZCwgb3B0aW9uLCBjYWxsYmFjayl7XG5cbiAgICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBpc1BlbmRpbmcgPSBmYWxzZTtcblxuICAgICAgb3B0aW9uLmFzeW5jID0gZnVuY3Rpb24oKXtcblxuICAgICAgICBpc1BlbmRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBkb25lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb25lKCBub3RSZWplY3RlZCApe1xuICAgICAgICBpZiggaXNEb25lICkgcmV0dXJuO1xuICAgICAgICBpc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soIG5vdFJlamVjdGVkICk7XG4gICAgICB9XG5cbiAgICAgIFxuXG4gICAgICBvcHRpb24uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGRvbmUoIGZhbHNlICk7XG4gICAgICB9XG5cblxuICAgICAgdGhpcy5hY3RpdmUgPSBhcHBsaWVkO1xuICAgICAgdmFyIHJldFZhbHVlID0gYXBwbGllZFttZXRob2RdPyBhcHBsaWVkW21ldGhvZF0oIG9wdGlvbiApOiB0cnVlO1xuXG4gICAgICBpZihtZXRob2QgPT09ICdlbnRlcicpIGFwcGxpZWQudmlzaXRlZCA9IHRydWU7XG4gICAgICAvLyBwcm9taXNlXG4gICAgICAvLyBuZWVkIGJyZWFkayAsIGlmIHdlIGNhbGwgb3B0aW9uLnN0b3AgZmlyc3Q7XG5cbiAgICAgIGlmKCBfLmlzUHJvbWlzZShyZXRWYWx1ZSkgKXtcblxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFByb21pc2UocmV0VmFsdWUsIGRvbmUpOyBcblxuICAgICAgfVxuXG4gICAgICAvLyBpZiBoYXZlbid0IGNhbGwgb3B0aW9uLmFzeW5jIHlldFxuICAgICAgaWYoICFpc1BlbmRpbmcgKSBkb25lKCByZXRWYWx1ZSApXG5cbiAgICB9LFxuXG5cbiAgICBfd3JhcFByb21pc2U6IGZ1bmN0aW9uKCBwcm9taXNlLCBuZXh0ICl7XG5cbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oIG5leHQsIGZ1bmN0aW9uKCl7bmV4dChmYWxzZSl9KSA7XG5cbiAgICB9LFxuXG4gICAgX2NvbXB1dGVOZXh0OiBmdW5jdGlvbiggZnJvbSwgdG8gKXtcblxuICAgICAgdmFyIGZuYW1lID0gZnJvbS5uYW1lO1xuICAgICAgdmFyIHRuYW1lID0gdG8ubmFtZTtcblxuICAgICAgdmFyIHRzcGxpdCA9IHRuYW1lLnNwbGl0KCcuJylcbiAgICAgIHZhciBmc3BsaXQgPSBmbmFtZS5zcGxpdCgnLicpXG5cbiAgICAgIHZhciB0bGVuID0gdHNwbGl0Lmxlbmd0aDtcbiAgICAgIHZhciBmbGVuID0gZnNwbGl0Lmxlbmd0aDtcblxuICAgICAgaWYoZm5hbWUgPT09ICcnKSBmbGVuID0gMDtcbiAgICAgIGlmKHRuYW1lID09PSAnJykgdGxlbiA9IDA7XG5cbiAgICAgIGlmKCBmbGVuIDwgdGxlbiApe1xuICAgICAgICBmc3BsaXRbZmxlbl0gPSB0c3BsaXRbZmxlbl07XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZnNwbGl0LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZShmc3BsaXQuam9pbignLicpKVxuXG4gICAgfSxcblxuICAgIF9maW5kUXVlcnk6IGZ1bmN0aW9uKHF1ZXJ5c3RyKXtcblxuICAgICAgdmFyIHF1ZXJpZXMgPSBxdWVyeXN0ciAmJiBxdWVyeXN0ci5zcGxpdChcIiZcIiksIHF1ZXJ5PSB7fTtcbiAgICAgIGlmKHF1ZXJpZXMpe1xuICAgICAgICB2YXIgbGVuID0gcXVlcmllcy5sZW5ndGg7XG4gICAgICAgIHZhciBxdWVyeSA9IHt9O1xuICAgICAgICBmb3IodmFyIGkgPTA7IGk8IGxlbjsgaSsrKXtcbiAgICAgICAgICB2YXIgdG1wID0gcXVlcmllc1tpXS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgcXVlcnlbdG1wWzBdXSA9IHRtcFsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHF1ZXJ5O1xuXG4gICAgfSxcbiAgICBfZmluZFN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgcGF0aCl7XG4gICAgICB2YXIgc3RhdGVzID0gc3RhdGUuX3N0YXRlcywgZm91bmQsIHBhcmFtO1xuXG4gICAgICAvLyBsZWFmLXN0YXRlIGhhcyB0aGUgaGlnaCBwcmlvcml0eSB1cG9uIGJyYW5jaC1zdGF0ZVxuICAgICAgaWYoc3RhdGUuaGFzTmV4dCl7XG4gICAgICAgIGZvcih2YXIgaSBpbiBzdGF0ZXMpIGlmKHN0YXRlcy5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgICAgICAgZm91bmQgPSB0aGlzLl9maW5kU3RhdGUoIHN0YXRlc1tpXSwgcGF0aCApO1xuICAgICAgICAgIGlmKCBmb3VuZCApIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW4gc3RyaWN0IG1vZGUgb25seSBsZWFmIGNhbiBiZSB0b3VjaGVkXG4gICAgICAvLyBpZiBhbGwgY2hpbGRyZW4gaXMgZG9uLiB3aWxsIHRyeSBpdCBzZWxmXG4gICAgICBwYXJhbSA9IHN0YXRlLnJlZ2V4cCAmJiBzdGF0ZS5kZWNvZGUocGF0aCk7XG4gICAgICBpZihwYXJhbSl7XG4gICAgICAgIHN0YXRlLnBhcmFtID0gcGFyYW07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBmaW5kIHRoZSBzYW1lIGJyYW5jaDtcbiAgICBfZmluZEJhc2U6IGZ1bmN0aW9uKG5vdywgYmVmb3JlKXtcblxuICAgICAgaWYoIW5vdyB8fCAhYmVmb3JlIHx8IG5vdyA9PSB0aGlzIHx8IGJlZm9yZSA9PSB0aGlzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBucCA9IG5vdywgYnAgPSBiZWZvcmUsIHRtcDtcbiAgICAgIHdoaWxlKG5wICYmIGJwKXtcbiAgICAgICAgdG1wID0gYnA7XG4gICAgICAgIHdoaWxlKHRtcCl7XG4gICAgICAgICAgaWYobnAgPT09IHRtcCkgcmV0dXJuIHRtcDtcbiAgICAgICAgICB0bXAgPSB0bXAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIG5wID0gbnAucGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gY2hlY2sgdGhlIHF1ZXJ5IGFuZCBQYXJhbVxuICAgIF9jaGVja1F1ZXJ5QW5kUGFyYW06IGZ1bmN0aW9uKGJhc2VTdGF0ZSwgb3B0aW9ucyl7XG5cbiAgICAgIHZhciBmcm9tID0gYmFzZVN0YXRlO1xuICAgICAgd2hpbGUoIGZyb20gIT09IHRoaXMgKXtcbiAgICAgICAgZnJvbS51cGRhdGUgJiYgZnJvbS51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgIGZyb20gPSBmcm9tLnBhcmVudDtcbiAgICAgIH1cblxuICAgIH1cblxufSwgdHJ1ZSlcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYW47XG5cbiIsInZhciBfID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBzbGljZSA9IFtdLnNsaWNlLCBvMnN0ciA9ICh7fSkudG9TdHJpbmc7XG5cblxuLy8gbWVyZ2UgbzIncyBwcm9wZXJ0aWVzIHRvIE9iamVjdCBvMS4gXG5fLmV4dGVuZCA9IGZ1bmN0aW9uKG8xLCBvMiwgb3ZlcnJpZGUpe1xuICBmb3IodmFyIGkgaW4gbzIpIGlmKG92ZXJyaWRlIHx8IG8xW2ldID09PSB1bmRlZmluZWQpe1xuICAgIG8xW2ldID0gbzJbaV1cbiAgfVxuICByZXR1cm4gbzE7XG59XG5cblxuXG5fLnNsaWNlID0gZnVuY3Rpb24oYXJyLCBpbmRleCl7XG4gIHJldHVybiBzbGljZS5jYWxsKGFyciwgaW5kZXgpO1xufVxuXG5fLnR5cGVPZiA9IGZ1bmN0aW9uIHR5cGVPZiAobykge1xuICByZXR1cm4gbyA9PSBudWxsID8gU3RyaW5nKG8pIDogbzJzdHIuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbn1cblxuLy9zdHJpY3QgZXFsXG5fLmVxbCA9IGZ1bmN0aW9uKG8xLCBvMil7XG4gIHZhciB0MSA9IF8udHlwZU9mKG8xKSwgdDIgPSBfLnR5cGVPZihvMik7XG4gIGlmKCB0MSAhPT0gdDIpIHJldHVybiBmYWxzZTtcbiAgaWYodDEgPT09ICdvYmplY3QnKXtcbiAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgIC8vIG9ubHkgY2hlY2sgdGhlIGZpcnN0J3MgcHJvcGVydGllXG4gICAgZm9yKHZhciBpIGluIG8xKXtcbiAgICAgIGlmKCBvMVtpXSAhPT0gbzJbaV0gKSBlcXVhbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cbiAgcmV0dXJuIG8xID09PSBvMjtcbn1cblxuXG4vLyBzbWFsbCBlbWl0dGVyIFxuXy5lbWl0YWJsZSA9IChmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBub3JtKGV2KXtcbiAgICB2YXIgZXZlbnRBbmROYW1lc3BhY2UgPSAoZXZ8fCcnKS5zcGxpdCgnOicpO1xuICAgIHJldHVybiB7ZXZlbnQ6IGV2ZW50QW5kTmFtZXNwYWNlWzBdLCBuYW1lc3BhY2U6IGV2ZW50QW5kTmFtZXNwYWNlWzFdfVxuICB9XG4gIHZhciBBUEkgPSB7XG4gICAgb25jZTogZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgdGhpcy5vZmYoZXZlbnQsIGNhbGxiYWNrKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGNhbGxiYWNrKVxuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgaWYodHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0Jyl7XG4gICAgICAgIGZvciAodmFyIGkgaW4gZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLm9uKGksIGV2ZW50W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZSA9IG5vcm0oZXZlbnQpO1xuICAgICAgZXZlbnQ9bmUuZXZlbnQ7XG4gICAgICBpZihldmVudCAmJiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgKXtcbiAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLl9oYW5kbGVzIHx8ICh0aGlzLl9oYW5kbGVzID0ge30pLFxuICAgICAgICAgIGNhbGxzID0gaGFuZGxlc1tldmVudF0gfHwgKGhhbmRsZXNbZXZlbnRdID0gW10pO1xuICAgICAgICBmbi5fbnMgPSBuZS5uYW1lc3BhY2U7XG4gICAgICAgIGNhbGxzLnB1c2goZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgdmFyIG5lID0gbm9ybShldmVudCk7IGV2ZW50ID0gbmUuZXZlbnQ7XG4gICAgICBpZighZXZlbnQgfHwgIXRoaXMuX2hhbmRsZXMpIHRoaXMuX2hhbmRsZXMgPSB7fTtcblxuICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLl9oYW5kbGVzICwgY2FsbHM7XG5cbiAgICAgIGlmIChjYWxscyA9IGhhbmRsZXNbZXZlbnRdKSB7XG4gICAgICAgIGlmICghZm4gJiYgIW5lLm5hbWVzcGFjZSkge1xuICAgICAgICAgIGhhbmRsZXNbZXZlbnRdID0gW107XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCAoIWZuIHx8IGZuID09PSBjYWxsc1tpXSkgJiYgKCFuZS5uYW1lc3BhY2UgfHwgY2FsbHNbaV0uX25zID09PSBuZS5uYW1lc3BhY2UpICkge1xuICAgICAgICAgICAgICBjYWxscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgbmUgPSBub3JtKGV2ZW50KTsgZXZlbnQgPSBuZS5ldmVudDtcblxuICAgICAgdmFyIGFyZ3MgPSBfLnNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGhhbmRsZXMgPSB0aGlzLl9oYW5kbGVzLCBjYWxscztcblxuICAgICAgaWYgKCFoYW5kbGVzIHx8ICEoY2FsbHMgPSBoYW5kbGVzW2V2ZW50XSkpIHJldHVybiB0aGlzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IGNhbGxzW2ldO1xuICAgICAgICBpZiggIW5lLm5hbWVzcGFjZSB8fCBmbi5fbnMgPT09IG5lLm5hbWVzcGFjZSApIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iail7XG4gICAgICBvYmogPSB0eXBlb2Ygb2JqID09IFwiZnVuY3Rpb25cIiA/IG9iai5wcm90b3R5cGUgOiBvYmo7XG4gICAgICByZXR1cm4gXy5leHRlbmQob2JqLCBBUEkpXG4gIH1cbn0pKCk7XG5cblxuXG5fLmJpbmQgPSBmdW5jdGlvbihmbiwgY29udGV4dCl7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbnZhciByRGJTbGFzaCA9IC9cXC8rL2csIC8vIGRvdWJsZSBzbGFzaFxuICByRW5kU2xhc2ggPSAvXFwvJC87ICAgIC8vIGVuZCBzbGFzaFxuXG5fLmNsZWFuUGF0aCA9IGZ1bmN0aW9uIChwYXRoKXtcbiAgcmV0dXJuIChcIi9cIiArIHBhdGgpLnJlcGxhY2UoIHJEYlNsYXNoLFwiL1wiICkucmVwbGFjZSggckVuZFNsYXNoLCBcIlwiICkgfHwgXCIvXCI7XG59XG5cbi8vIG5vcm1hbGl6ZSB0aGUgcGF0aFxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoKSB7XG4gIC8vIG1lYW5zIGlzIGZyb20gXG4gIC8vICg/OlxcOihbXFx3LV0rKSk/KD86XFwoKFteXFwvXSs/KVxcKSl8KFxcKnsyLH0pfChcXCooPyFcXCopKSkvZ1xuICB2YXIgcHJlSW5kZXggPSAwO1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbWF0Y2hlcyA9IFwiXCI7XG5cbiAgcGF0aCA9IF8uY2xlYW5QYXRoKHBhdGgpO1xuXG4gIHZhciByZWdTdHIgPSBwYXRoXG4gICAgLy8gIDppZChjYXB0dXJlKT8gfCAoY2FwdHVyZSkgICB8ICAqKiB8ICogXG4gICAgLnJlcGxhY2UoL1xcOihbXFx3LV0rKSg/OlxcKChbXlxcL10rPylcXCkpP3woPzpcXCgoW15cXC9dKylcXCkpfChcXCp7Mix9KXwoXFwqKD8hXFwqKSkvZywgXG4gICAgICBmdW5jdGlvbihhbGwsIGtleSwga2V5Zm9ybWF0LCBjYXB0dXJlLCBtd2lsZCwgc3dpbGQsIHN0YXJ0QXQpIHtcbiAgICAgICAgLy8gbW92ZSB0aGUgdW5jYXB0dXJlZCBmcmFnbWVudCBpbiB0aGUgcGF0aFxuICAgICAgICBpZihzdGFydEF0ID4gcHJlSW5kZXgpIG1hdGNoZXMgKz0gcGF0aC5zbGljZShwcmVJbmRleCwgc3RhcnRBdCk7XG4gICAgICAgIHByZUluZGV4ID0gc3RhcnRBdCArIGFsbC5sZW5ndGg7XG4gICAgICAgIGlmKCBrZXkgKXtcbiAgICAgICAgICBtYXRjaGVzICs9IFwiKFwiICsga2V5ICsgXCIpXCI7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSlcbiAgICAgICAgICByZXR1cm4gXCIoXCIrKCBrZXlmb3JtYXQgfHwgXCJbXFxcXHctXStcIikrXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlcyArPSBcIihcIiArIGluZGV4ICsgXCIpXCI7XG5cbiAgICAgICAga2V5cy5wdXNoKCBpbmRleCsrICk7XG5cbiAgICAgICAgaWYoIGNhcHR1cmUgKXtcbiAgICAgICAgICAgLy8gc3ViIGNhcHR1cmUgZGV0ZWN0XG4gICAgICAgICAgcmV0dXJuIFwiKFwiICsgY2FwdHVyZSArICBcIilcIjtcbiAgICAgICAgfSBcbiAgICAgICAgaWYobXdpbGQpIHJldHVybiBcIiguKilcIjtcbiAgICAgICAgaWYoc3dpbGQpIHJldHVybiBcIihbXlxcXFwvXSopXCI7XG4gICAgfSlcblxuICBpZihwcmVJbmRleCAhPT0gcGF0aC5sZW5ndGgpIG1hdGNoZXMgKz0gcGF0aC5zbGljZShwcmVJbmRleClcblxuICByZXR1cm4ge1xuICAgIHJlZ2V4cDogbmV3IFJlZ0V4cChcIl5cIiArIHJlZ1N0ciArXCIvPyRcIiksXG4gICAga2V5czoga2V5cyxcbiAgICBtYXRjaGVzOiBtYXRjaGVzIHx8IHBhdGhcbiAgfVxufVxuXG5fLmxvZyA9IGZ1bmN0aW9uKG1zZywgdHlwZSl7XG4gIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGVbdHlwZSB8fCBcImxvZ1wiXShtc2cpXG59XG5cbl8uaXNQcm9taXNlID0gZnVuY3Rpb24oIG9iaiApe1xuXG4gIHJldHVybiAhIW9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xuXG59XG5cblxuXG5fLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZVBhdGg7XG5cbiJdfQ==
